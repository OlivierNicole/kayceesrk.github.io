<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="BatUref.html">
<link rel="next" href="Batteries.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="BatArray" rel="Chapter" href="BatArray.html">
<link title="BatAvlTree" rel="Chapter" href="BatAvlTree.html">
<link title="BatBase64" rel="Chapter" href="BatBase64.html">
<link title="BatBig_int" rel="Chapter" href="BatBig_int.html">
<link title="BatBigarray" rel="Chapter" href="BatBigarray.html">
<link title="BatBitSet" rel="Chapter" href="BatBitSet.html">
<link title="BatBool" rel="Chapter" href="BatBool.html">
<link title="BatBounded" rel="Chapter" href="BatBounded.html">
<link title="BatBuffer" rel="Chapter" href="BatBuffer.html">
<link title="BatBytes" rel="Chapter" href="BatBytes.html">
<link title="BatCache" rel="Chapter" href="BatCache.html">
<link title="BatChar" rel="Chapter" href="BatChar.html">
<link title="BatCharParser" rel="Chapter" href="BatCharParser.html">
<link title="BatComplex" rel="Chapter" href="BatComplex.html">
<link title="BatConcurrent" rel="Chapter" href="BatConcurrent.html">
<link title="BatDeque" rel="Chapter" href="BatDeque.html">
<link title="BatDigest" rel="Chapter" href="BatDigest.html">
<link title="BatDllist" rel="Chapter" href="BatDllist.html">
<link title="BatDynArray" rel="Chapter" href="BatDynArray.html">
<link title="BatEnum" rel="Chapter" href="BatEnum.html">
<link title="BatFile" rel="Chapter" href="BatFile.html">
<link title="BatFingerTree" rel="Chapter" href="BatFingerTree.html">
<link title="BatFloat" rel="Chapter" href="BatFloat.html">
<link title="BatFormat" rel="Chapter" href="BatFormat.html">
<link title="BatGc" rel="Chapter" href="BatGc.html">
<link title="BatGenlex" rel="Chapter" href="BatGenlex.html">
<link title="BatGlobal" rel="Chapter" href="BatGlobal.html">
<link title="BatHashcons" rel="Chapter" href="BatHashcons.html">
<link title="BatHashtbl" rel="Chapter" href="BatHashtbl.html">
<link title="BatHeap" rel="Chapter" href="BatHeap.html">
<link title="BatIMap" rel="Chapter" href="BatIMap.html">
<link title="BatIO" rel="Chapter" href="BatIO.html">
<link title="BatISet" rel="Chapter" href="BatISet.html">
<link title="BatInnerIO" rel="Chapter" href="BatInnerIO.html">
<link title="BatInnerPervasives" rel="Chapter" href="BatInnerPervasives.html">
<link title="BatInnerWeaktbl" rel="Chapter" href="BatInnerWeaktbl.html">
<link title="BatInt" rel="Chapter" href="BatInt.html">
<link title="BatInt32" rel="Chapter" href="BatInt32.html">
<link title="BatInt64" rel="Chapter" href="BatInt64.html">
<link title="BatInterfaces" rel="Chapter" href="BatInterfaces.html">
<link title="BatLazyList" rel="Chapter" href="BatLazyList.html">
<link title="BatLexing" rel="Chapter" href="BatLexing.html">
<link title="BatList" rel="Chapter" href="BatList.html">
<link title="BatLog" rel="Chapter" href="BatLog.html">
<link title="BatLogger" rel="Chapter" href="BatLogger.html">
<link title="BatMap" rel="Chapter" href="BatMap.html">
<link title="BatMarshal" rel="Chapter" href="BatMarshal.html">
<link title="BatMultiMap" rel="Chapter" href="BatMultiMap.html">
<link title="BatMultiPMap" rel="Chapter" href="BatMultiPMap.html">
<link title="BatMutex" rel="Chapter" href="BatMutex.html">
<link title="BatNativeint" rel="Chapter" href="BatNativeint.html">
<link title="BatNum" rel="Chapter" href="BatNum.html">
<link title="BatNumber" rel="Chapter" href="BatNumber.html">
<link title="BatOo" rel="Chapter" href="BatOo.html">
<link title="BatOptParse" rel="Chapter" href="BatOptParse.html">
<link title="BatOption" rel="Chapter" href="BatOption.html">
<link title="BatOrd" rel="Chapter" href="BatOrd.html">
<link title="BatParserCo" rel="Chapter" href="BatParserCo.html">
<link title="BatPathGen" rel="Chapter" href="BatPathGen.html">
<link title="BatPervasives" rel="Chapter" href="BatPervasives.html">
<link title="BatPrintexc" rel="Chapter" href="BatPrintexc.html">
<link title="BatPrintf" rel="Chapter" href="BatPrintf.html">
<link title="BatQueue" rel="Chapter" href="BatQueue.html">
<link title="BatRMutex" rel="Chapter" href="BatRMutex.html">
<link title="BatRandom" rel="Chapter" href="BatRandom.html">
<link title="BatRef" rel="Chapter" href="BatRef.html">
<link title="BatRefList" rel="Chapter" href="BatRefList.html">
<link title="BatResult" rel="Chapter" href="BatResult.html">
<link title="BatReturn" rel="Chapter" href="BatReturn.html">
<link title="BatScanf" rel="Chapter" href="BatScanf.html">
<link title="BatSeq" rel="Chapter" href="BatSeq.html">
<link title="BatSet" rel="Chapter" href="BatSet.html">
<link title="BatSplay" rel="Chapter" href="BatSplay.html">
<link title="BatStack" rel="Chapter" href="BatStack.html">
<link title="BatStream" rel="Chapter" href="BatStream.html">
<link title="BatString" rel="Chapter" href="BatString.html">
<link title="BatSubstring" rel="Chapter" href="BatSubstring.html">
<link title="BatSys" rel="Chapter" href="BatSys.html">
<link title="BatText" rel="Chapter" href="BatText.html">
<link title="BatTuple" rel="Chapter" href="BatTuple.html">
<link title="BatUChar" rel="Chapter" href="BatUChar.html">
<link title="BatUTF8" rel="Chapter" href="BatUTF8.html">
<link title="BatUnit" rel="Chapter" href="BatUnit.html">
<link title="BatUnix" rel="Chapter" href="BatUnix.html">
<link title="BatUref" rel="Chapter" href="BatUref.html">
<link title="BatVect" rel="Chapter" href="BatVect.html">
<link title="Batteries" rel="Chapter" href="Batteries.html">
<link title="BatteriesConfig" rel="Chapter" href="BatteriesConfig.html">
<link title="BatteriesExceptionless" rel="Chapter" href="BatteriesExceptionless.html">
<link title="BatteriesPrint" rel="Chapter" href="BatteriesPrint.html">
<link title="BatteriesThread" rel="Chapter" href="BatteriesThread.html">
<link title="Extlib" rel="Chapter" href="Extlib.html"><link title="Creation and conversions" rel="Section" href="#6_Creationandconversions">
<link title="Properties " rel="Section" href="#6_Properties">
<link title="Operations " rel="Section" href="#6_Operations">
<link title="Conversion" rel="Section" href="#6_Conversion">
<link title="Iteration and higher-order functions " rel="Section" href="#6_Iterationandhigherorderfunctions">
<link title="Predicates" rel="Section" href="#6_Predicates">
<link title="Convenience Functions" rel="Section" href="#6_ConvenienceFunctions">
<link title="Boilerplate code" rel="Section" href="#6_Boilerplatecode">
<title>Batteries user guide : BatVect</title>
</head>
<body>
<div class="navbar"><a class="pre" href="BatUref.html" title="BatUref">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Batteries.html" title="Batteries">Next</a>
</div>
<h1>Module <a href="type_BatVect.html">BatVect</a></h1>

<pre><span class="keyword">module</span> BatVect: <code class="code">{</code> <a href="BatVect.html">..</a> <code class="code">}</code></pre><div class="info module top">
Extensible vectors with constant-time append/prepend.
<p>

    This module implements extensible arrays which work very much like ropes
    as described in
    <b>Boehm, H., Atkinson, R., and Plass, M.</b> 1995. <em>Ropes: an alternative to
    strings.</em>  Softw. Pract. Exper. 25, 12 (Dec. 1995), 1315-1330.
<p>

    These vectors have some interesting properties:<ul>
<li>lower space overhead than other structures based on balanced trees such as Vec.
    The overhead can be adjusted, allowing to make get faster at the expense of set
    and viceversa.</li>
<li>appending or prepending a small vector to an arbitrarily large one in amortized
    constant time</li>
<li>concat, substring, insert, remove operations in amortized logarithmic time</li>
<li>access to and modification of vectors in logarithmic time</li>
</ul>

    <div class="h8" id="8_Functionalnatureandpersistence">Functional nature and persistence</div>
<p>

    All operations but <code class="code">destructive_set</code> (provided for efficient ephemeral usage)
    are non-destructive: the original vect is never modified.  When a new vect is
    returned as the result of an operation, it will share as much data as possible
    with its "parent". For instance, if a vect of length <code class="code">n</code> undergoes <code class="code">m</code>
    operations (assume <code class="code">n &gt;&gt; m</code>) like set, append or prepend, the modified vector
    will only require <code class="code"><span class="constructor">O</span>(m)</code> space in addition to that taken by the original vect.
<p>

    However, Vect is an amortized data structure, and its use in a persistent setting
    can easily degrade its amortized time bounds. It is thus mainly intended to be used
    ephemerally. In some cases, it is possible to use Vect persistently with the same
    amortized bounds by explicitly rebalancing vects to be reused using <code class="code">balance</code>.
    Special care must be taken to avoid calling <code class="code">balance</code> too frequently; in the limit,
    calling <code class="code">balance</code> after each modification would defeat the purpose of amortization.
<p>

    This module is not thread-safe.<br>
<b>Author(s):</b> Mauricio Fernandez<br>
</div>
<hr width="100%">

<pre><span id="TYPEt"><span class="keyword">type</span> t <code class="type">'a</code></span> </pre>
<div class="info ">
The type of a polymorphic vect.<br>
</div>


<pre><span id="EXCEPTIONOut_of_bounds"><span class="keyword">exception</span> Out_of_bounds</span></pre>
<div class="info ">
Raised when an operation violates the bounds of the vect.<br>
</div>

<pre><span id="VALmax_length"><span class="keyword">let</span> max_length</span> : <code class="type">int</code></pre><div class="info ">
Maximum length of the vect.<br>
</div>
<br>
<h6 id="6_Creationandconversions">Creation and conversions</h6><br>

<pre><span id="VALempty"><span class="keyword">let</span> empty</span> : <code class="type"><a href="BatVect.html#TYPEt">t</a> 'a</code></pre><div class="info ">
The empty vect.<br>
</div>

<pre><span id="VALsingleton"><span class="keyword">let</span> singleton</span> : <code class="type">'a => <a href="BatVect.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Returns a vect of length 1 holding only the given element.<br>
</div>

<pre><span id="VALof_array"><span class="keyword">let</span> of_array</span> : <code class="type">array 'a => <a href="BatVect.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">of_array s</code> returns a vect corresponding to the array <code class="code">s</code>.
    Operates in <code class="code"><span class="constructor">O</span>(n)</code> time.<br>
</div>

<pre><span id="VALto_array"><span class="keyword">let</span> to_array</span> : <code class="type"><a href="BatVect.html#TYPEt">t</a> 'a => array 'a</code></pre><div class="info ">
<code class="code">to_array r</code> returns an array corresponding to the vect <code class="code">r</code>.<br>
</div>

<pre><span id="VALto_list"><span class="keyword">let</span> to_list</span> : <code class="type"><a href="BatVect.html#TYPEt">t</a> 'a => list 'a</code></pre><div class="info ">
Returns a list with the elements contained in the vect.<br>
</div>

<pre><span id="VALof_list"><span class="keyword">let</span> of_list</span> : <code class="type">list 'a => <a href="BatVect.html#TYPEt">t</a> 'a</code></pre>
<pre><span id="VALmake"><span class="keyword">let</span> make</span> : <code class="type">int => 'a => <a href="BatVect.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">make i c</code> returns a vect of length <code class="code">i</code> whose elements are all equal to
    <code class="code">c</code>; it is similar to Array.make<br>
</div>

<pre><span id="VALinit"><span class="keyword">let</span> init</span> : <code class="type">int => (int => 'a) => <a href="BatVect.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">init n f</code> returns a fresh vect of length <code class="code">n</code>,
    with element number <code class="code">i</code> initialized to the result of <code class="code">f i</code>.
    In other terms, <code class="code">init n f</code> tabulates the results of <code class="code">f</code>
    applied to the integers <code class="code">0</code> to <code class="code">n-1</code>.<br>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">n &lt; 0</code> or <code class="code">n &gt; max_length</code>.<br>
</div>
<br>
<h6 id="6_Properties">Properties </h6><br>

<pre><span id="VALis_empty"><span class="keyword">let</span> is_empty</span> : <code class="type"><a href="BatVect.html#TYPEt">t</a> 'a => bool</code></pre><div class="info ">
Returns whether the vect is empty or not.<br>
</div>

<pre><span id="VALheight"><span class="keyword">let</span> height</span> : <code class="type"><a href="BatVect.html#TYPEt">t</a> 'a => int</code></pre><div class="info ">
Returns the height (depth) of the vect.<br>
</div>

<pre><span id="VALlength"><span class="keyword">let</span> length</span> : <code class="type"><a href="BatVect.html#TYPEt">t</a> 'a => int</code></pre><div class="info ">
Returns the length of the vect (<code class="code"><span class="constructor">O</span>(1)</code>).<br>
</div>
<br>
<h6 id="6_Operations">Operations </h6><br>

<pre><span id="VALbalance"><span class="keyword">let</span> balance</span> : <code class="type"><a href="BatVect.html#TYPEt">t</a> 'a => <a href="BatVect.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">balance r</code> returns a balanced copy of the <code class="code">r</code> vect. Note that vects are
    automatically rebalanced when their height exceeds a given threshold, but
    <code class="code">balance</code> allows to invoke that operation explicity.<br>
</div>

<pre><span id="VALconcat"><span class="keyword">let</span> concat</span> : <code class="type"><a href="BatVect.html#TYPEt">t</a> 'a => <a href="BatVect.html#TYPEt">t</a> 'a => <a href="BatVect.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">concat r u</code> concatenates the <code class="code">r</code> and <code class="code">u</code> vects. In general, it operates
    in <code class="code"><span class="constructor">O</span>(log(min n1 n2))</code> amortized time.
    Small vects are treated specially and can be appended/prepended in
    amortized <code class="code"><span class="constructor">O</span>(1)</code> time.<br>
</div>

<pre><span id="VALappend"><span class="keyword">let</span> append</span> : <code class="type">'a => <a href="BatVect.html#TYPEt">t</a> 'a => <a href="BatVect.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">append c r</code> returns a new vect with the <code class="code">c</code> element at the end
    in amortized <code class="code"><span class="constructor">O</span>(1)</code> time.<br>
</div>

<pre><span id="VALprepend"><span class="keyword">let</span> prepend</span> : <code class="type">'a => <a href="BatVect.html#TYPEt">t</a> 'a => <a href="BatVect.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">prepend c r</code> returns a new vect with the <code class="code">c</code> character at the
    beginning in amortized <code class="code"><span class="constructor">O</span>(1)</code> time.<br>
</div>

<pre><span id="VALget"><span class="keyword">let</span> get</span> : <code class="type"><a href="BatVect.html#TYPEt">t</a> 'a => int => 'a</code></pre><div class="info ">
<code class="code">get v n</code> returns the (n+1)th element from the vect <code class="code">v</code>; i.e.
    <code class="code">get v 0</code> returns the first element.
    Operates in worst-case <code class="code"><span class="constructor">O</span>(log size)</code> time.<br>
<b>Raises</b> <code>Out_of_bounds</code> if a character out of bounds is requested.<br>
</div>

<pre><span id="VALat"><span class="keyword">let</span> at</span> : <code class="type"><a href="BatVect.html#TYPEt">t</a> 'a => int => 'a</code></pre><div class="info ">
as <code class="code">get</code><br>
</div>

<pre><span id="VALset"><span class="keyword">let</span> set</span> : <code class="type"><a href="BatVect.html#TYPEt">t</a> 'a => int => 'a => <a href="BatVect.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">set v n c</code> returns a copy of the <code class="code">v</code> vect where the (n+1)th element
    (see also <code class="code">get</code>) has been set to <code class="code">c</code>.
    Operates in worst-case <code class="code"><span class="constructor">O</span>(log size)</code> time.<br>
</div>

<pre><span id="VALmodify"><span class="keyword">let</span> modify</span> : <code class="type"><a href="BatVect.html#TYPEt">t</a> 'a => int => ('a => 'a) => <a href="BatVect.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">modify v n f</code> is equivalent to <code class="code">set v n (f (get v n))</code>, but
    more efficient.  Operates in worst-case <code class="code"><span class="constructor">O</span>(log size)</code> time.<br>
</div>

<pre><span id="VALdestructive_set"><span class="keyword">let</span> destructive_set</span> : <code class="type"><a href="BatVect.html#TYPEt">t</a> 'a => int => 'a => unit</code></pre><div class="info ">
<code class="code">destructive_set n e v</code> sets the element of index <code class="code">n</code> in the <code class="code">v</code> vect
    to <code class="code">e</code>. <b>This operation is destructive</b>, and will also affect vects
    sharing the modified leaf with <code class="code">v</code>. Use with caution.<br>
</div>

<pre><span id="VALsub"><span class="keyword">let</span> sub</span> : <code class="type"><a href="BatVect.html#TYPEt">t</a> 'a => int => int => <a href="BatVect.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">sub m n r</code> returns a sub-vect of <code class="code">r</code> containing all the elements
    whose indexes range from <code class="code">m</code> to <code class="code">m + n - 1</code> (included).<br>
<b>Raises</b> <code>Out_of_bounds</code> in the same cases as Array.sub.
    Operates in worst-case <code class="code"><span class="constructor">O</span>(log size)</code> time.<br>
</div>

<pre><span id="VALinsert"><span class="keyword">let</span> insert</span> : <code class="type">int => <a href="BatVect.html#TYPEt">t</a> 'a => <a href="BatVect.html#TYPEt">t</a> 'a => <a href="BatVect.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">insert n r u</code> returns a copy of the <code class="code">u</code> vect where <code class="code">r</code> has been
    inserted between the elements with index <code class="code">n</code> and <code class="code">n + 1</code> in the
    original vect. The length of the new vect is
    <code class="code">length u + length r</code>.
    Operates in amortized <code class="code"><span class="constructor">O</span>(log(size r) + log(size u))</code> time.<br>
</div>

<pre><span id="VALremove"><span class="keyword">let</span> remove</span> : <code class="type">int => int => <a href="BatVect.html#TYPEt">t</a> 'a => <a href="BatVect.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">remove m n r</code> returns the vect resulting from deleting the
    elements with indexes ranging from <code class="code">m</code> to <code class="code">m + n - 1</code> (included)
    from the original vect <code class="code">r</code>. The length of the new vect is
    <code class="code">length r - n</code>.
    Operates in amortized <code class="code"><span class="constructor">O</span>(log(size r))</code> time.<br>
</div>
<br>
<h6 id="6_Conversion">Conversion</h6><br>

<pre><span id="VALenum"><span class="keyword">let</span> enum</span> : <code class="type"><a href="BatVect.html#TYPEt">t</a> 'a => <a href="BatEnum.html#TYPEt">BatEnum.t</a> 'a</code></pre><div class="info ">
Returns an enumeration of the elements of the vector.
    Behavior of the enumeration is undefined if the contents of the vector changes afterwards.<br>
</div>

<pre><span id="VALof_enum"><span class="keyword">let</span> of_enum</span> : <code class="type"><a href="BatEnum.html#TYPEt">BatEnum.t</a> 'a => <a href="BatVect.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Build a vector from an enumeration.<br>
</div>

<pre><span id="VALbackwards"><span class="keyword">let</span> backwards</span> : <code class="type"><a href="BatVect.html#TYPEt">t</a> 'a => <a href="BatEnum.html#TYPEt">BatEnum.t</a> 'a</code></pre><div class="info ">
Returns an enumeration of the elements of a vector, from last to first.
    Behavior of the enumeration is undefined if the contents of the vector changes afterwards.<br>
</div>

<pre><span id="VALof_backwards"><span class="keyword">let</span> of_backwards</span> : <code class="type"><a href="BatEnum.html#TYPEt">BatEnum.t</a> 'a => <a href="BatVect.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Build a vector from an enumeration, from last to first.<br>
</div>
<br>
<h6 id="6_Iterationandhigherorderfunctions">Iteration and higher-order functions </h6><br>

<pre><span id="VALiter"><span class="keyword">let</span> iter</span> : <code class="type">('a => unit) => <a href="BatVect.html#TYPEt">t</a> 'a => unit</code></pre><div class="info ">
<code class="code">iter f r</code> applies <code class="code">f</code> to all the elements in the <code class="code">r</code> vect,
    in order.<br>
</div>

<pre><span id="VALiteri"><span class="keyword">let</span> iteri</span> : <code class="type">(int => 'a => unit) => <a href="BatVect.html#TYPEt">t</a> 'a => unit</code></pre><div class="info ">
Operates like iter, but also passes the index of the character
    to the given function.<br>
</div>

<pre><span id="VALrangeiter"><span class="keyword">let</span> rangeiter</span> : <code class="type">('a => unit) => int => int => <a href="BatVect.html#TYPEt">t</a> 'a => unit</code></pre><div class="info ">
<code class="code">rangeiter f m n r</code> applies <code class="code">f</code> to all the elements whose
    indices <code class="code">k</code> satisfy <code class="code">m</code> &lt;= <code class="code">k</code> &lt; <code class="code">m + n</code>.
    It is thus equivalent to <code class="code">iter f (sub m n r)</code>, but does not
    create an intermediary vect. <code class="code">rangeiter</code> operates in worst-case
    <code class="code"><span class="constructor">O</span>(n + log m)</code> time, which improves on the <code class="code"><span class="constructor">O</span>(n log m)</code> bound
    from an explicit loop using <code class="code">get</code>.<br>
<b>Raises</b> <code>Out_of_bounds</code> in the same cases as <code class="code">sub</code>.<br>
</div>

<pre><span id="VALfold_left"><span class="keyword">let</span> fold_left</span> : <code class="type">('b => 'a => 'b) => 'b => <a href="BatVect.html#TYPEt">t</a> 'a => 'b</code></pre><div class="info ">
<code class="code">fold_left f a r</code> computes <code class="code"> f (... (f (f a r0) r1)...) rN-1 </code>
    where <code class="code">rn = <span class="constructor">Vect</span>.get n r </code> and <code class="code"><span class="constructor">N</span> = length r</code>.<br>
</div>

<pre><span id="VALfold"><span class="keyword">let</span> fold</span> : <code class="type">('b => 'a => 'b) => 'b => <a href="BatVect.html#TYPEt">t</a> 'a => 'b</code></pre><div class="info ">
An alias for <a href="BatVect.html#VALfold_left"><code class="code"><span class="constructor">BatVect</span>.fold_left</code></a><br>
</div>

<pre><span id="VALreduce"><span class="keyword">let</span> reduce</span> : <code class="type">('a => 'a => 'a) => <a href="BatVect.html#TYPEt">t</a> 'a => 'a</code></pre><div class="info ">
as <a href="BatVect.html#VALfold_left"><code class="code"><span class="constructor">BatVect</span>.fold_left</code></a>, but no initial value - just applies reducing
    function to elements from left to right.<br>
</div>

<pre><span id="VALfold_right"><span class="keyword">let</span> fold_right</span> : <code class="type">('a => 'b => 'b) => <a href="BatVect.html#TYPEt">t</a> 'a => 'b => 'b</code></pre><div class="info ">
<code class="code">fold_right f r a</code> computes <code class="code"> f (r0 ... (f rN-2 (f rN-1 a)) ...)) </code>
    where <code class="code">rn = <span class="constructor">Vect</span>.get n r </code> and <code class="code"><span class="constructor">N</span> = length r</code>.<br>
</div>

<pre><span id="VALfoldi"><span class="keyword">let</span> foldi</span> : <code class="type">(int => 'b => 'a => 'b) => 'b => <a href="BatVect.html#TYPEt">t</a> 'a => 'b</code></pre><div class="info ">
As <a href="BatVect.html#VALfold"><code class="code"><span class="constructor">BatVect</span>.fold</code></a>, but with the position of each value passed to the
    folding function<br>
</div>

<pre><span id="VALmap"><span class="keyword">let</span> map</span> : <code class="type">('a => 'b) => <a href="BatVect.html#TYPEt">t</a> 'a => <a href="BatVect.html#TYPEt">t</a> 'b</code></pre><div class="info ">
<code class="code">map f v</code> returns a vect isomorphic to <code class="code">v</code> where each element of index
    <code class="code">i</code> equals <code class="code">f (get v i)</code>. Therefore, the height of the returned vect
    is the same as that of the original one. Operates in <code class="code"><span class="constructor">O</span>(n)</code> time.<br>
</div>

<pre><span id="VALmapi"><span class="keyword">let</span> mapi</span> : <code class="type">(int => 'a => 'b) => <a href="BatVect.html#TYPEt">t</a> 'a => <a href="BatVect.html#TYPEt">t</a> 'b</code></pre><div class="info ">
Same as <a href="BatVect.html#VALmap"><code class="code"><span class="constructor">BatVect</span>.map</code></a>, but the
    function is applied to the index of the element as first argument,
    and the element itself as second argument.<br>
</div>
<br>
<h6 id="6_Predicates">Predicates</h6><br>

<pre><span id="VALfor_all"><span class="keyword">let</span> for_all</span> : <code class="type">('a => bool) => <a href="BatVect.html#TYPEt">t</a> 'a => bool</code></pre><div class="info ">
<code class="code">for_all p [a0; a1; ...; an]</code> checks if all elements of the vect
    satisfy the predicate <code class="code">p</code>.  That is, it returns
    <code class="code"> (p a0) <span class="keywordsign">&amp;&amp;</span> (p a1) <span class="keywordsign">&amp;&amp;</span> ... <span class="keywordsign">&amp;&amp;</span> (p an)</code>.<br>
</div>

<pre><span id="VALexists"><span class="keyword">let</span> exists</span> : <code class="type">('a => bool) => <a href="BatVect.html#TYPEt">t</a> 'a => bool</code></pre><div class="info ">
<code class="code">exists p [a0; a1; ...; an]</code> checks if at least one element of
    the vect satisfies the predicate <code class="code">p</code>.  That is, it returns
    <code class="code"> (p a0) <span class="keywordsign">||</span> (p a1) <span class="keywordsign">||</span> ... <span class="keywordsign">||</span> (p an)</code>.<br>
</div>

<pre><span id="VALfind"><span class="keyword">let</span> find</span> : <code class="type">('a => bool) => <a href="BatVect.html#TYPEt">t</a> 'a => 'a</code></pre><div class="info ">
<code class="code">find p a</code> returns the first element of vect <code class="code">a</code>
    that satisfies the predicate <code class="code">p</code>.<br>
<b>Raises</b> <code>Not_found</code> if there is no value that satisfies <code class="code">p</code> in the
    vect <code class="code">a</code>.<br>
</div>

<pre><span id="VALmem"><span class="keyword">let</span> mem</span> : <code class="type">'a => <a href="BatVect.html#TYPEt">t</a> 'a => bool</code></pre><div class="info ">
<code class="code">mem m a</code> is true if and only if <code class="code">m</code> is equal to an element of <code class="code">a</code>.<br>
</div>

<pre><span id="VALmemq"><span class="keyword">let</span> memq</span> : <code class="type">'a => <a href="BatVect.html#TYPEt">t</a> 'a => bool</code></pre><div class="info ">
Same as <code class="code"><span class="constructor">Vect</span>.mem</code> but uses physical equality instead of
    structural equality to compare vect elements.<br>
</div>

<pre><span id="VALfindi"><span class="keyword">let</span> findi</span> : <code class="type">('a => bool) => <a href="BatVect.html#TYPEt">t</a> 'a => int</code></pre><div class="info ">
<code class="code">findi p a</code> returns the index of the first element of vect <code class="code">a</code>
    that satisfies the predicate <code class="code">p</code>.<br>
<b>Raises</b> <code>Not_found</code> if there is no value that satisfies <code class="code">p</code> in the
    vect <code class="code">a</code>.<br>
</div>

<pre><span id="VALfilter"><span class="keyword">let</span> filter</span> : <code class="type">('a => bool) => <a href="BatVect.html#TYPEt">t</a> 'a => <a href="BatVect.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">filter f v</code> returns a vect with the elements <code class="code">x</code> from <code class="code">v</code> such that
    <code class="code">f x</code> returns <code class="code"><span class="keyword">true</span></code>. Operates in <code class="code"><span class="constructor">O</span>(n)</code> time.<br>
</div>

<pre><span id="VALfilter_map"><span class="keyword">let</span> filter_map</span> : <code class="type">('a => option 'b) => <a href="BatVect.html#TYPEt">t</a> 'a => <a href="BatVect.html#TYPEt">t</a> 'b</code></pre><div class="info ">
<code class="code">filter_map f e</code> returns a vect consisting of all elements
    <code class="code">x</code> such that <code class="code">f y</code> returns <code class="code"><span class="constructor">Some</span> x</code> , where <code class="code">y</code> is an element
    of <code class="code">e</code>.<br>
</div>

<pre><span id="VALfind_all"><span class="keyword">let</span> find_all</span> : <code class="type">('a => bool) => <a href="BatVect.html#TYPEt">t</a> 'a => <a href="BatVect.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">find_all</code> is another name for <code class="code"><span class="constructor">Vect</span>.filter</code>.<br>
</div>

<pre><span id="VALpartition"><span class="keyword">let</span> partition</span> : <code class="type">('a => bool) => <a href="BatVect.html#TYPEt">t</a> 'a => (<a href="BatVect.html#TYPEt">t</a> 'a, <a href="BatVect.html#TYPEt">t</a> 'a)</code></pre><div class="info ">
<code class="code">partition p v</code> returns a pair of vects <code class="code">(v1, v2)</code>, where
    <code class="code">v1</code> is the vect of all the elements of <code class="code">v</code> that
    satisfy the predicate <code class="code">p</code>, and <code class="code">v2</code> is the vect of all the
    elements of <code class="code">v</code> that do not satisfy <code class="code">p</code>.
    The order of the elements in the input vect is preserved.<br>
</div>
<br>
<h6 id="6_ConvenienceFunctions">Convenience Functions</h6><br>

<pre><span id="VALfirst"><span class="keyword">let</span> first</span> : <code class="type"><a href="BatVect.html#TYPEt">t</a> 'a => 'a</code></pre>
<pre><span id="VALlast"><span class="keyword">let</span> last</span> : <code class="type"><a href="BatVect.html#TYPEt">t</a> 'a => 'a</code></pre><div class="info ">
These return the first and last values in the vector<br>
</div>

<pre><span id="VALshift"><span class="keyword">let</span> shift</span> : <code class="type"><a href="BatVect.html#TYPEt">t</a> 'a => ('a, <a href="BatVect.html#TYPEt">t</a> 'a)</code></pre><div class="info ">
Return the first element of a vector and its last <code class="code">n-1</code> elements.<br>
</div>

<pre><span id="VALpop"><span class="keyword">let</span> pop</span> : <code class="type"><a href="BatVect.html#TYPEt">t</a> 'a => ('a, <a href="BatVect.html#TYPEt">t</a> 'a)</code></pre><div class="info ">
Return the last element of a vector and its first <code class="code">n-1</code> elements.<br>
</div>
<br>
<h6 id="6_Boilerplatecode">Boilerplate code</h6><br>

<pre><span id="VALprint"><span class="keyword">let</span> print</span> : <code class="type">first::string? =><br>       last::string? =><br>       sep::string? =><br>       (<a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> 'a => 'b => unit) =><br>       <a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> 'a => <a href="BatVect.html#TYPEt">t</a> 'b => unit</code></pre>
<pre><span id="VALcompare"><span class="keyword">let</span> compare</span> : <code class="type"><a href="BatOrd.html#TYPEcomp">BatOrd.comp</a> 'a => <a href="BatOrd.html#TYPEcomp">BatOrd.comp</a> (<a href="BatVect.html#TYPEt">t</a> 'a)</code></pre>
<pre><span id="VALequal"><span class="keyword">let</span> equal</span> : <code class="type"><a href="BatOrd.html#TYPEeq">BatOrd.eq</a> 'a => <a href="BatOrd.html#TYPEeq">BatOrd.eq</a> (<a href="BatVect.html#TYPEt">t</a> 'a)</code></pre>
<pre><span id="VALord"><span class="keyword">let</span> ord</span> : <code class="type"><a href="BatOrd.html#TYPEord">BatOrd.ord</a> 'a => <a href="BatOrd.html#TYPEord">BatOrd.ord</a> (<a href="BatVect.html#TYPEt">t</a> 'a)</code></pre></body></html>