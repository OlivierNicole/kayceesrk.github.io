<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Batteries.BitSet.html">
<link rel="next" href="Batteries.Dllist.html">
<link rel="Up" href="Batteries.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="BatArray" rel="Chapter" href="BatArray.html">
<link title="BatAvlTree" rel="Chapter" href="BatAvlTree.html">
<link title="BatBase64" rel="Chapter" href="BatBase64.html">
<link title="BatBig_int" rel="Chapter" href="BatBig_int.html">
<link title="BatBigarray" rel="Chapter" href="BatBigarray.html">
<link title="BatBitSet" rel="Chapter" href="BatBitSet.html">
<link title="BatBool" rel="Chapter" href="BatBool.html">
<link title="BatBounded" rel="Chapter" href="BatBounded.html">
<link title="BatBuffer" rel="Chapter" href="BatBuffer.html">
<link title="BatBytes" rel="Chapter" href="BatBytes.html">
<link title="BatCache" rel="Chapter" href="BatCache.html">
<link title="BatChar" rel="Chapter" href="BatChar.html">
<link title="BatCharParser" rel="Chapter" href="BatCharParser.html">
<link title="BatComplex" rel="Chapter" href="BatComplex.html">
<link title="BatConcurrent" rel="Chapter" href="BatConcurrent.html">
<link title="BatDeque" rel="Chapter" href="BatDeque.html">
<link title="BatDigest" rel="Chapter" href="BatDigest.html">
<link title="BatDllist" rel="Chapter" href="BatDllist.html">
<link title="BatDynArray" rel="Chapter" href="BatDynArray.html">
<link title="BatEnum" rel="Chapter" href="BatEnum.html">
<link title="BatFile" rel="Chapter" href="BatFile.html">
<link title="BatFingerTree" rel="Chapter" href="BatFingerTree.html">
<link title="BatFloat" rel="Chapter" href="BatFloat.html">
<link title="BatFormat" rel="Chapter" href="BatFormat.html">
<link title="BatGc" rel="Chapter" href="BatGc.html">
<link title="BatGenlex" rel="Chapter" href="BatGenlex.html">
<link title="BatGlobal" rel="Chapter" href="BatGlobal.html">
<link title="BatHashcons" rel="Chapter" href="BatHashcons.html">
<link title="BatHashtbl" rel="Chapter" href="BatHashtbl.html">
<link title="BatHeap" rel="Chapter" href="BatHeap.html">
<link title="BatIMap" rel="Chapter" href="BatIMap.html">
<link title="BatIO" rel="Chapter" href="BatIO.html">
<link title="BatISet" rel="Chapter" href="BatISet.html">
<link title="BatInnerIO" rel="Chapter" href="BatInnerIO.html">
<link title="BatInnerPervasives" rel="Chapter" href="BatInnerPervasives.html">
<link title="BatInnerWeaktbl" rel="Chapter" href="BatInnerWeaktbl.html">
<link title="BatInt" rel="Chapter" href="BatInt.html">
<link title="BatInt32" rel="Chapter" href="BatInt32.html">
<link title="BatInt64" rel="Chapter" href="BatInt64.html">
<link title="BatInterfaces" rel="Chapter" href="BatInterfaces.html">
<link title="BatLazyList" rel="Chapter" href="BatLazyList.html">
<link title="BatLexing" rel="Chapter" href="BatLexing.html">
<link title="BatList" rel="Chapter" href="BatList.html">
<link title="BatLog" rel="Chapter" href="BatLog.html">
<link title="BatLogger" rel="Chapter" href="BatLogger.html">
<link title="BatMap" rel="Chapter" href="BatMap.html">
<link title="BatMarshal" rel="Chapter" href="BatMarshal.html">
<link title="BatMultiMap" rel="Chapter" href="BatMultiMap.html">
<link title="BatMultiPMap" rel="Chapter" href="BatMultiPMap.html">
<link title="BatMutex" rel="Chapter" href="BatMutex.html">
<link title="BatNativeint" rel="Chapter" href="BatNativeint.html">
<link title="BatNum" rel="Chapter" href="BatNum.html">
<link title="BatNumber" rel="Chapter" href="BatNumber.html">
<link title="BatOo" rel="Chapter" href="BatOo.html">
<link title="BatOptParse" rel="Chapter" href="BatOptParse.html">
<link title="BatOption" rel="Chapter" href="BatOption.html">
<link title="BatOrd" rel="Chapter" href="BatOrd.html">
<link title="BatParserCo" rel="Chapter" href="BatParserCo.html">
<link title="BatPathGen" rel="Chapter" href="BatPathGen.html">
<link title="BatPervasives" rel="Chapter" href="BatPervasives.html">
<link title="BatPrintexc" rel="Chapter" href="BatPrintexc.html">
<link title="BatPrintf" rel="Chapter" href="BatPrintf.html">
<link title="BatQueue" rel="Chapter" href="BatQueue.html">
<link title="BatRMutex" rel="Chapter" href="BatRMutex.html">
<link title="BatRandom" rel="Chapter" href="BatRandom.html">
<link title="BatRef" rel="Chapter" href="BatRef.html">
<link title="BatRefList" rel="Chapter" href="BatRefList.html">
<link title="BatResult" rel="Chapter" href="BatResult.html">
<link title="BatReturn" rel="Chapter" href="BatReturn.html">
<link title="BatScanf" rel="Chapter" href="BatScanf.html">
<link title="BatSeq" rel="Chapter" href="BatSeq.html">
<link title="BatSet" rel="Chapter" href="BatSet.html">
<link title="BatSplay" rel="Chapter" href="BatSplay.html">
<link title="BatStack" rel="Chapter" href="BatStack.html">
<link title="BatStream" rel="Chapter" href="BatStream.html">
<link title="BatString" rel="Chapter" href="BatString.html">
<link title="BatSubstring" rel="Chapter" href="BatSubstring.html">
<link title="BatSys" rel="Chapter" href="BatSys.html">
<link title="BatText" rel="Chapter" href="BatText.html">
<link title="BatTuple" rel="Chapter" href="BatTuple.html">
<link title="BatUChar" rel="Chapter" href="BatUChar.html">
<link title="BatUTF8" rel="Chapter" href="BatUTF8.html">
<link title="BatUnit" rel="Chapter" href="BatUnit.html">
<link title="BatUnix" rel="Chapter" href="BatUnix.html">
<link title="BatUref" rel="Chapter" href="BatUref.html">
<link title="BatVect" rel="Chapter" href="BatVect.html">
<link title="Batteries" rel="Chapter" href="Batteries.html">
<link title="BatteriesConfig" rel="Chapter" href="BatteriesConfig.html">
<link title="BatteriesExceptionless" rel="Chapter" href="BatteriesExceptionless.html">
<link title="BatteriesPrint" rel="Chapter" href="BatteriesPrint.html">
<link title="BatteriesThread" rel="Chapter" href="BatteriesThread.html">
<link title="Extlib" rel="Chapter" href="Extlib.html"><link title="In-place Update" rel="Section" href="#6_InplaceUpdate">
<link title="In-place Update" rel="Section" href="#6_InplaceUpdate">
<link title="Return new bitset" rel="Section" href="#6_Returnnewbitset">
<link title="Return new bitset" rel="Section" href="#6_Returnnewbitset">
<link title="Boilerplate code" rel="Section" href="#6_Boilerplatecode">
<title>Batteries user guide : Batteries.Bit_set</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Batteries.BitSet.html" title="Batteries.BitSet">Previous</a>
&nbsp;<a class="up" href="Batteries.html" title="Batteries">Up</a>
&nbsp;<a class="post" href="Batteries.Dllist.html" title="Batteries.Dllist">Next</a>
</div>
<h1>Module <a href="type_Batteries.Bit_set.html">Batteries.Bit_set</a></h1>

<pre><span class="keyword">module</span> Bit_set: <code class="type"><a href="BatBitSet.html">BatBitSet</a></code></pre><hr width="100%">

<pre><span id="TYPEt"><span class="keyword">type</span> t<code class="type"></code></span> </pre>


<pre><span id="VALempty"><span class="keyword">let</span> empty</span> : <code class="type">unit => <a href="BatBitSet.html#TYPEt">t</a></code></pre><div class="info ">
Create an empty bitset of capacity 0, the bitset will
    automatically expand when needed.
<p>

    Example: <code class="code"><span class="constructor">BitSet</span>.empty ()</code><br>
</div>

<pre><span id="VALcreate"><span class="keyword">let</span> create</span> : <code class="type">int => <a href="BatBitSet.html#TYPEt">t</a></code></pre><div class="info ">
Create an empty bitset with at least an initial capacity (in number of bits).
<p>

    Example: <code class="code"><span class="constructor">BitSet</span>.create 0 = <span class="constructor">BitSet</span>.empty ()</code><br>
<b>Raises</b> <code>Invalid_argument</code> on negative capacity<br>
</div>

<pre><span id="VALcreate_full"><span class="keyword">let</span> create_full</span> : <code class="type">int => <a href="BatBitSet.html#TYPEt">t</a></code></pre><div class="info ">
Create a full bitset with at least initial capacity (in number of bits).
    All the bit under the defined capacity will be set.
<p>

    Example: <code class="code"><span class="constructor">BitSet</span>.count (<span class="constructor">BitSet</span>.create_full n) = n</code><br>
<b>Raises</b> <code>Invalid_argument</code> on negative capacity<br>
</div>

<pre><span id="VALcopy"><span class="keyword">let</span> copy</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => <a href="BatBitSet.html#TYPEt">t</a></code></pre><div class="info ">
Copy a bitset : further modifications of first one will not affect the
    copy.
<p>

    Example: <code class="code">
    <span class="keyword">let</span> a = <span class="constructor">Bitset</span>.create 8 <span class="keyword">in</span>
    <span class="keyword">let</span> b = <span class="constructor">BitSet</span>.copy a <span class="keyword">in</span>
    <span class="constructor">BitSet</span>.set a 6;
    <span class="constructor">BitSet</span>.mem a 6 <span class="keywordsign">&amp;&amp;</span> not (<span class="constructor">BitSet</span>.mem b 6)</code><br>
</div>

<pre><span id="VALmem"><span class="keyword">let</span> mem</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => int => bool</code></pre><div class="info ">
<code class="code">mem s n</code> returns true if nth-bit in the bitset <code class="code">s</code> is set,
    or false otherwise.
<p>

    Example: <code class="code"><span class="keyword">let</span> a = <span class="constructor">BitSet</span>.create_full 256 <span class="keyword">in</span> not (<span class="constructor">BitSet</span>.mem a 300)</code><br>
<b>Raises</b> <code>Invalid_argument</code> on negative index (<code class="code">n &lt; 0</code>)<br>
</div>

<pre><span id="VALcount"><span class="keyword">let</span> count</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => int</code></pre><div class="info ">
<code class="code">count s</code> returns the number of bits set in the bitset <code class="code">s</code>. Also
    known as Population Count, or <code class="code">cardinal</code> for sets.
<p>

    Example: <code class="code"><span class="constructor">BitSet</span>.count (<span class="constructor">BitSet</span>.of_list [6;4;2;2;1]) = 4</code><br>
</div>

<pre><span id="VALnext_set_bit"><span class="keyword">let</span> next_set_bit</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => int => option int</code></pre><div class="info ">
<code class="code">next_set_bit s n</code> returns <code class="code"><span class="constructor">Some</span> m</code> when <code class="code">m</code> is the next set
    element with index greater than or equal <code class="code">n</code>, or None if no such
    element exists (i.e. <code class="code">n</code> is greater than the largest element)
<p>

    More efficient than scanning with repeated <code class="code"><span class="constructor">BitSet</span>.mem</code>.<br>
<b>Raises</b> <code>Invalid_argument</code> on negative index (<code class="code">n &lt; 0</code>)<br>
</div>
<br>
<h6 id="6_InplaceUpdate">In-place Update</h6><br>
<br>
<h6 id="6_InplaceUpdate">In-place Update</h6><br>
<br>
These functions modify an existing bitset.<br>

<pre><span id="VALset"><span class="keyword">let</span> set</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => int => unit</code></pre><div class="info ">
<code class="code">set s n</code> sets the <code class="code">n</code>th-bit in the bitset <code class="code">s</code> to true.<br>
<b>Raises</b> <code>Invalid_argument</code> on negative index (<code class="code">n &lt; 0</code>)<br>
</div>

<pre><span id="VALunset"><span class="keyword">let</span> unset</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => int => unit</code></pre><div class="info ">
<code class="code">unset s n</code> sets the <code class="code">n</code>th-bit in the bitset <code class="code">s</code> to false.<br>
<b>Raises</b> <code>Invalid_argument</code> on negative index (<code class="code">n &lt; 0</code>)<br>
</div>

<pre><span id="VALput"><span class="keyword">let</span> put</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => bool => int => unit</code></pre><div class="info ">
<code class="code">put s v n</code> sets the nth-bit in the bitset <code class="code">s</code> to <code class="code">v</code>.<br>
<b>Raises</b> <code>Invalid_argument</code> on negative index (<code class="code">n &lt; 0</code>)<br>
</div>

<pre><span id="VALtoggle"><span class="keyword">let</span> toggle</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => int => unit</code></pre><div class="info ">
<code class="code">toggle s n</code> changes the nth-bit value in the bitset <code class="code">s</code>.<br>
<b>Raises</b> <code>Invalid_argument</code> on negative index (<code class="code">n &lt; 0</code>)<br>
</div>

<pre><span id="VALintersect"><span class="keyword">let</span> intersect</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => <a href="BatBitSet.html#TYPEt">t</a> => unit</code></pre><div class="info ">
<code class="code">intersect s t</code> sets <code class="code">s</code> to the intersection of the sets <code class="code">s</code> and <code class="code">t</code>.<br>
</div>

<pre><span id="VALunite"><span class="keyword">let</span> unite</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => <a href="BatBitSet.html#TYPEt">t</a> => unit</code></pre><div class="info ">
<code class="code">unite s t</code> sets <code class="code">s</code> to the union of the sets <code class="code">s</code> and <code class="code">t</code>.<br>
</div>

<pre><span id="VALdifferentiate"><span class="keyword">let</span> differentiate</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => <a href="BatBitSet.html#TYPEt">t</a> => unit</code></pre><div class="info ">
<code class="code">differentiate s t</code> removes the elements of <code class="code">t</code> from <code class="code">s</code>.<br>
</div>

<pre><span id="VALdifferentiate_sym"><span class="keyword">let</span> differentiate_sym</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => <a href="BatBitSet.html#TYPEt">t</a> => unit</code></pre><div class="info ">
<code class="code">differentiate_sym s t</code> sets <code class="code">s</code> to the symmetrical difference of the
    sets <code class="code">s</code> and <code class="code">t</code>.<br>
</div>
<br>
<h6 id="6_Returnnewbitset">Return new bitset</h6><br>
<br>
<h6 id="6_Returnnewbitset">Return new bitset</h6><br>
<br>
These functions return a new bitset that shares nothing with the
    input bitset.  This is not as efficient as the in-place update.<br>

<pre><span id="VALadd"><span class="keyword">let</span> add</span> : <code class="type">int => <a href="BatBitSet.html#TYPEt">t</a> => <a href="BatBitSet.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">add n s</code> returns a copy of <code class="code">s</code> with bit <code class="code">n</code> true.<br>
<b>Raises</b> <code>Invalid_argument</code> on negative index (<code class="code">n &lt; 0</code>)<br>
</div>

<pre><span id="VALremove"><span class="keyword">let</span> remove</span> : <code class="type">int => <a href="BatBitSet.html#TYPEt">t</a> => <a href="BatBitSet.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">remove n s</code> returns a copy of <code class="code">s</code> with bit <code class="code">n</code> false.<br>
<b>Raises</b> <code>Invalid_argument</code> on negative index (<code class="code">n &lt; 0</code>)<br>
</div>

<pre><span id="VALinter"><span class="keyword">let</span> inter</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => <a href="BatBitSet.html#TYPEt">t</a> => <a href="BatBitSet.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">inter s t</code> returns the intersection of sets <code class="code">s</code> and <code class="code">t</code>.<br>
</div>

<pre><span id="VALunion"><span class="keyword">let</span> union</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => <a href="BatBitSet.html#TYPEt">t</a> => <a href="BatBitSet.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">union s t</code> return the union of sets <code class="code">s</code>  and <code class="code">t</code>.<br>
</div>

<pre><span id="VALdiff"><span class="keyword">let</span> diff</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => <a href="BatBitSet.html#TYPEt">t</a> => <a href="BatBitSet.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">diff s t</code> returns <code class="code">s</code>-<code class="code">t</code>.<br>
</div>

<pre><span id="VALsym_diff"><span class="keyword">let</span> sym_diff</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => <a href="BatBitSet.html#TYPEt">t</a> => <a href="BatBitSet.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">sym_diff s t</code> returns the symmetrical difference of <code class="code">s</code> and <code class="code">t</code>.<br>
</div>
<br>
<h6 id="6_Boilerplatecode">Boilerplate code</h6><br>

<pre><span id="VALprint"><span class="keyword">let</span> print</span> : <code class="type"><a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> 'a => <a href="BatBitSet.html#TYPEt">t</a> => unit</code></pre>
<pre><span id="VALenum"><span class="keyword">let</span> enum</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => <a href="BatEnum.html#TYPEt">BatEnum.t</a> int</code></pre><div class="info ">
<code class="code">enum s</code> returns an enumeration of bits which are set
    in the bitset <code class="code">s</code>.<br>
</div>

<pre><span id="VALof_enum"><span class="keyword">let</span> of_enum</span> : <code class="type">cap::int? => <a href="BatEnum.html#TYPEt">BatEnum.t</a> int => <a href="BatBitSet.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">of_enum ~cap e</code> builds a bitset of capacity <code class="code">cap</code> an enumeration
    of ints <code class="code">e</code>.
<p>

    Note: Performance of this function may be poor if enumeration is
    in increasing order and the max.<br>
</div>

<pre><span id="VALof_list"><span class="keyword">let</span> of_list</span> : <code class="type">cap::int? => list int => <a href="BatBitSet.html#TYPEt">t</a></code></pre><div class="info ">
As <code class="code">of_enum</code>, but from a list<br>
</div>

<pre><span id="VALcompare"><span class="keyword">let</span> compare</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => <a href="BatBitSet.html#TYPEt">t</a> => int</code></pre><div class="info ">
<code class="code">compare s1 s2</code> compares two bitsets using a lexicographic
    ordering.  Highest bit indexes are compared first. The capacity of
    the bitsets is not important for this comparison, only the bits
    starting with the highest set bit and going down.<br>
</div>

<pre><span id="VALequal"><span class="keyword">let</span> equal</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => <a href="BatBitSet.html#TYPEt">t</a> => bool</code></pre><div class="info ">
<code class="code">equal s1 s2</code> returns true if, and only if, all bits values in s1 are
    the same as in s2.<br>
</div>

<pre><span id="VALord"><span class="keyword">let</span> ord</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => <a href="BatBitSet.html#TYPEt">t</a> => <a href="BatOrd.html#TYPEorder">BatOrd.order</a></code></pre><div class="info ">
<code class="code">ord s1 s2</code> returns <code class="code"><span class="constructor">BatOrd</span>.<span class="constructor">Lt</span></code>, <code class="code"><span class="constructor">BatOrd</span>.<span class="constructor">Eq</span></code> or <code class="code"><span class="constructor">BatOrd</span>.<span class="constructor">Gt</span></code> if <code class="code">compare s1 s2</code>
    is, respectively, <code class="code">&lt; 0</code>, <code class="code">0</code> or <code class="code">&gt; 0</code>.<br>
</div>

<pre><span id="VALcapacity"><span class="keyword">let</span> capacity</span> : <code class="type"><a href="BatBitSet.html#TYPEt">t</a> => int</code></pre><div class="info ">
<h6 id="6_Internals">Internals</h6>
<p>
<code class="code">capacity s</code> returns the number of bits, both set and unset, stored
      in <code class="code">s</code>.  This is guaranteed to be larger than the largest element
      (set bit index) in <code class="code">s</code>.<br>
</div>
</body></html>