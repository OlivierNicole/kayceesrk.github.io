<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Batteries.Lexing.html">
<link rel="next" href="Batteries.Map.html">
<link rel="Up" href="Batteries.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="BatArray" rel="Chapter" href="BatArray.html">
<link title="BatAvlTree" rel="Chapter" href="BatAvlTree.html">
<link title="BatBase64" rel="Chapter" href="BatBase64.html">
<link title="BatBig_int" rel="Chapter" href="BatBig_int.html">
<link title="BatBigarray" rel="Chapter" href="BatBigarray.html">
<link title="BatBitSet" rel="Chapter" href="BatBitSet.html">
<link title="BatBool" rel="Chapter" href="BatBool.html">
<link title="BatBounded" rel="Chapter" href="BatBounded.html">
<link title="BatBuffer" rel="Chapter" href="BatBuffer.html">
<link title="BatBytes" rel="Chapter" href="BatBytes.html">
<link title="BatCache" rel="Chapter" href="BatCache.html">
<link title="BatChar" rel="Chapter" href="BatChar.html">
<link title="BatCharParser" rel="Chapter" href="BatCharParser.html">
<link title="BatComplex" rel="Chapter" href="BatComplex.html">
<link title="BatConcurrent" rel="Chapter" href="BatConcurrent.html">
<link title="BatDeque" rel="Chapter" href="BatDeque.html">
<link title="BatDigest" rel="Chapter" href="BatDigest.html">
<link title="BatDllist" rel="Chapter" href="BatDllist.html">
<link title="BatDynArray" rel="Chapter" href="BatDynArray.html">
<link title="BatEnum" rel="Chapter" href="BatEnum.html">
<link title="BatFile" rel="Chapter" href="BatFile.html">
<link title="BatFingerTree" rel="Chapter" href="BatFingerTree.html">
<link title="BatFloat" rel="Chapter" href="BatFloat.html">
<link title="BatFormat" rel="Chapter" href="BatFormat.html">
<link title="BatGc" rel="Chapter" href="BatGc.html">
<link title="BatGenlex" rel="Chapter" href="BatGenlex.html">
<link title="BatGlobal" rel="Chapter" href="BatGlobal.html">
<link title="BatHashcons" rel="Chapter" href="BatHashcons.html">
<link title="BatHashtbl" rel="Chapter" href="BatHashtbl.html">
<link title="BatHeap" rel="Chapter" href="BatHeap.html">
<link title="BatIMap" rel="Chapter" href="BatIMap.html">
<link title="BatIO" rel="Chapter" href="BatIO.html">
<link title="BatISet" rel="Chapter" href="BatISet.html">
<link title="BatInnerIO" rel="Chapter" href="BatInnerIO.html">
<link title="BatInnerPervasives" rel="Chapter" href="BatInnerPervasives.html">
<link title="BatInnerWeaktbl" rel="Chapter" href="BatInnerWeaktbl.html">
<link title="BatInt" rel="Chapter" href="BatInt.html">
<link title="BatInt32" rel="Chapter" href="BatInt32.html">
<link title="BatInt64" rel="Chapter" href="BatInt64.html">
<link title="BatInterfaces" rel="Chapter" href="BatInterfaces.html">
<link title="BatLazyList" rel="Chapter" href="BatLazyList.html">
<link title="BatLexing" rel="Chapter" href="BatLexing.html">
<link title="BatList" rel="Chapter" href="BatList.html">
<link title="BatLog" rel="Chapter" href="BatLog.html">
<link title="BatLogger" rel="Chapter" href="BatLogger.html">
<link title="BatMap" rel="Chapter" href="BatMap.html">
<link title="BatMarshal" rel="Chapter" href="BatMarshal.html">
<link title="BatMultiMap" rel="Chapter" href="BatMultiMap.html">
<link title="BatMultiPMap" rel="Chapter" href="BatMultiPMap.html">
<link title="BatMutex" rel="Chapter" href="BatMutex.html">
<link title="BatNativeint" rel="Chapter" href="BatNativeint.html">
<link title="BatNum" rel="Chapter" href="BatNum.html">
<link title="BatNumber" rel="Chapter" href="BatNumber.html">
<link title="BatOo" rel="Chapter" href="BatOo.html">
<link title="BatOptParse" rel="Chapter" href="BatOptParse.html">
<link title="BatOption" rel="Chapter" href="BatOption.html">
<link title="BatOrd" rel="Chapter" href="BatOrd.html">
<link title="BatParserCo" rel="Chapter" href="BatParserCo.html">
<link title="BatPathGen" rel="Chapter" href="BatPathGen.html">
<link title="BatPervasives" rel="Chapter" href="BatPervasives.html">
<link title="BatPrintexc" rel="Chapter" href="BatPrintexc.html">
<link title="BatPrintf" rel="Chapter" href="BatPrintf.html">
<link title="BatQueue" rel="Chapter" href="BatQueue.html">
<link title="BatRMutex" rel="Chapter" href="BatRMutex.html">
<link title="BatRandom" rel="Chapter" href="BatRandom.html">
<link title="BatRef" rel="Chapter" href="BatRef.html">
<link title="BatRefList" rel="Chapter" href="BatRefList.html">
<link title="BatResult" rel="Chapter" href="BatResult.html">
<link title="BatReturn" rel="Chapter" href="BatReturn.html">
<link title="BatScanf" rel="Chapter" href="BatScanf.html">
<link title="BatSeq" rel="Chapter" href="BatSeq.html">
<link title="BatSet" rel="Chapter" href="BatSet.html">
<link title="BatSplay" rel="Chapter" href="BatSplay.html">
<link title="BatStack" rel="Chapter" href="BatStack.html">
<link title="BatStream" rel="Chapter" href="BatStream.html">
<link title="BatString" rel="Chapter" href="BatString.html">
<link title="BatSubstring" rel="Chapter" href="BatSubstring.html">
<link title="BatSys" rel="Chapter" href="BatSys.html">
<link title="BatText" rel="Chapter" href="BatText.html">
<link title="BatTuple" rel="Chapter" href="BatTuple.html">
<link title="BatUChar" rel="Chapter" href="BatUChar.html">
<link title="BatUTF8" rel="Chapter" href="BatUTF8.html">
<link title="BatUnit" rel="Chapter" href="BatUnit.html">
<link title="BatUnix" rel="Chapter" href="BatUnix.html">
<link title="BatUref" rel="Chapter" href="BatUref.html">
<link title="BatVect" rel="Chapter" href="BatVect.html">
<link title="Batteries" rel="Chapter" href="Batteries.html">
<link title="BatteriesConfig" rel="Chapter" href="BatteriesConfig.html">
<link title="BatteriesExceptionless" rel="Chapter" href="BatteriesExceptionless.html">
<link title="BatteriesPrint" rel="Chapter" href="BatteriesPrint.html">
<link title="BatteriesThread" rel="Chapter" href="BatteriesThread.html">
<link title="Extlib" rel="Chapter" href="Extlib.html"><link title="Base operations" rel="Section" href="#6_Baseoperations">
<link title="Constructors" rel="Section" href="#6_Constructors">
<link title="Iterators" rel="Section" href="#6_Iterators">
<link title="Iterators on two lists" rel="Section" href="#6_Iteratorsontwolists">
<link title="List scanning" rel="Section" href="#6_Listscanning">
<link title="List searching" rel="Section" href="#6_Listsearching">
<link title="Association lists" rel="Section" href="#6_Associationlists">
<link title="List transformations" rel="Section" href="#6_Listtransformations">
<link title="BatEnum functions" rel="Section" href="#6_BatEnumfunctions">
<link title="List of pairs" rel="Section" href="#6_Listofpairs">
<link title="Sorting" rel="Section" href="#6_Sorting">
<link title="Utilities" rel="Section" href="#6_Utilities">
<link title="Boilerplate code" rel="Section" href="#6_Boilerplatecode">
<link title="Boilerplate code" rel="Section" href="#6_Boilerplatecode">
<link title="Obsolete functions" rel="Section" href="#6_Obsoletefunctions">
<link title="Override modules" rel="Section" href="#6_Overridemodules">
<link title="Override modules" rel="Section" href="#6_Overridemodules">
<link title="Unary predicate, One list" rel="Subsection" href="#7_UnarypredicateOnelist">
<link title="Binary predicate, Two lists" rel="Subsection" href="#7_BinarypredicateTwolists">
<link title="Printing" rel="Subsection" href="#7_Printing">
<title>Batteries user guide : Batteries.List</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Batteries.Lexing.html" title="Batteries.Lexing">Previous</a>
&nbsp;<a class="up" href="Batteries.html" title="Batteries">Up</a>
&nbsp;<a class="post" href="Batteries.Map.html" title="Batteries.Map">Next</a>
</div>
<h1>Module <a href="type_Batteries.List.html">Batteries.List</a></h1>

<pre><span class="keyword">module</span> List: <code class="type"><a href="BatList.html">BatList</a></code></pre><hr width="100%">
<br>
List operations.<br>

<pre><span id="TYPEt"><span class="keyword">type</span> t <code class="type">'a</code></span> = <code class="type">list 'a</code> </pre>
<div class="info ">
The type of lists<br>
</div>


<pre><span class="keyword">include</span> <a href="BatEnum.Enumerable.html">BatEnum.Enumerable</a></pre>

<pre><span class="keyword">include</span> <a href="BatInterfaces.Mappable.html">BatInterfaces.Mappable</a></pre>
<br>
<h6 id="6_Baseoperations">Base operations</h6><br>

<pre><span id="VALis_empty"><span class="keyword">let</span> is_empty</span> : <code class="type">list 'a => bool</code></pre><div class="info ">
<code class="code">is_empty e</code> returns true if <code class="code">e</code> does not contains any element.<br>
</div>

<pre><span id="VALcons"><span class="keyword">let</span> cons</span> : <code class="type">'a => list 'a => list 'a</code></pre><div class="info ">
<code class="code">cons h t</code> returns the list starting with <code class="code">h</code> and continuing as <code class="code">t</code><br>
</div>

<pre><span id="VALfirst"><span class="keyword">let</span> first</span> : <code class="type">list 'a => 'a</code></pre><div class="info ">
Returns the first element of the list, or<br>
<b>Raises</b> <code>Empty_list</code> if
    the list is empty (similar to <code class="code">hd</code>).<br>
</div>

<pre><span id="VALhd"><span class="keyword">let</span> hd</span> : <code class="type">list 'a => 'a</code></pre><div class="info ">
Similar to <code class="code">first</code>, but<br>
<b>Raises</b> <code>Failure</code> if the list is empty.<br>
</div>

<pre><span id="VALtl"><span class="keyword">let</span> tl</span> : <code class="type">list 'a => list 'a</code></pre><div class="info ">
Return the given list without its first element.<br>
<b>Raises</b> <code>Failure</code> if the list is empty.<br>
</div>

<pre><span id="VALlast"><span class="keyword">let</span> last</span> : <code class="type">list 'a => 'a</code></pre><div class="info ">
Returns the last element of the list, or<br>
<b>Raises</b> <code>Empty_list</code> if
    the list is empty. This function takes linear time.<br>
</div>

<pre><span id="VALlength"><span class="keyword">let</span> length</span> : <code class="type">list 'a => int</code></pre><div class="info ">
Return the length (number of elements) of the given list.<br>
</div>

<pre><span id="VALat"><span class="keyword">let</span> at</span> : <code class="type">list 'a => int => 'a</code></pre><div class="info ">
<code class="code">at l n</code> returns the n-th element of the list <code class="code">l</code> or<br>
<b>Raises</b> <code>Invalid_argument</code> if the index is outside of <code class="code">l</code> bounds.  O(l)<br>
</div>

<pre><span id="VALrev"><span class="keyword">let</span> rev</span> : <code class="type">list 'a => list 'a</code></pre><div class="info ">
List reversal.<br>
</div>

<pre><span id="VALappend"><span class="keyword">let</span> append</span> : <code class="type">list 'a => list 'a => list 'a</code></pre><div class="info ">
Catenate two lists.  Same function as the infix operator <code class="code">@</code>.
    Tail-recursive O(length of the first argument).<br>
</div>

<pre><span id="VALrev_append"><span class="keyword">let</span> rev_append</span> : <code class="type">list 'a => list 'a => list 'a</code></pre><div class="info ">
<code class="code"><span class="constructor">List</span>.rev_append l1 l2</code> reverses <code class="code">l1</code> and concatenates it to <code class="code">l2</code>.<br>
</div>

<pre><span id="VALconcat"><span class="keyword">let</span> concat</span> : <code class="type">list (list 'a) => list 'a</code></pre><div class="info ">
Concatenate a list of lists.  The elements of the argument are all
    concatenated together (in the same order) to give the result.
    Tail-recursive
    (length of the argument + length of the longest sub-list).<br>
</div>

<pre><span id="VALflatten"><span class="keyword">let</span> flatten</span> : <code class="type">list (list 'a) => list 'a</code></pre><div class="info ">
Same as <code class="code">concat</code>.<br>
</div>

<pre><span id="VALsingleton"><span class="keyword">let</span> singleton</span> : <code class="type">'a => list 'a</code></pre><div class="info ">
Create a list consisting of exactly one element.<br>
<b>Since</b> 2.1<br>
</div>
<br>
<h6 id="6_Constructors">Constructors</h6><br>

<pre><span id="VALmake"><span class="keyword">let</span> make</span> : <code class="type">int => 'a => list 'a</code></pre><div class="info ">
Similar to <code class="code"><span class="constructor">String</span>.make</code>, <code class="code">make n x</code> returns a
    list containing <code class="code">n</code> elements <code class="code">x</code>.<br>
</div>

<pre><span id="VALrange"><span class="keyword">let</span> range</span> : <code class="type">int => [< `Downto | `To ] => int => list int</code></pre><div class="info ">
<code class="code">range 1 <span class="keywordsign">`</span><span class="constructor">To</span> 3</code> = <code class="code">[1; 2; 3]</code>.
    <code class="code">range 3 <span class="keywordsign">`</span><span class="constructor">Downto</span> 1</code> = <code class="code">[3; 2; 1]</code>.<br>
<b>Since</b> 2.2.0<br>
<b>Raises</b><ul><li><code>Invalid_argument</code> in (<code class="code">range i <span class="keywordsign">`</span><span class="constructor">To</span> j</code>) if (i &gt; j).</li>
<li><code>Invalid_argument</code> in (<code class="code">range i <span class="keywordsign">`</span><span class="constructor">Downto</span> j</code>) if (i &lt; j).</li>
</ul>
</div>

<pre><span id="VALinit"><span class="keyword">let</span> init</span> : <code class="type">int => (int => 'a) => list 'a</code></pre><div class="info ">
Similar to <code class="code"><span class="constructor">Array</span>.init</code>, <code class="code">init n f</code> returns the list containing
    the results of (f 0),(f 1).... (f (n-1)).<br>
<b>Raises</b> <code>Invalid_argument</code> if n &lt; 0.<br>
</div>

<pre><span id="VALunfold"><span class="keyword">let</span> unfold</span> : <code class="type">'b => ('b => option ('a, 'b)) => list 'a</code></pre><div class="info ">
<code class="code">unfold init f</code> creates a list by repeatedly applying <code class="code">f</code> to the
    second element of its own result, starting from the initial value
    <code class="code">init</code>. The first element of each result is accumulated in
    a list. The list is terminated and returned as soon as <code class="code">f</code> returns
    <code class="code"><span class="constructor">None</span></code>.
<p>

    Example: <code class="code"><span class="constructor">List</span>.unfold 0 (<span class="keyword">fun</span> x <span class="keywordsign">-&gt;</span> <span class="keyword">if</span> x = 3 <span class="keyword">then</span> <span class="constructor">None</span> <span class="keyword">else</span> <span class="constructor">Some</span> (string_of_int x, x+1))</code>
    will return <code class="code">[<span class="string">"0"</span>;<span class="string">"1"</span>;<span class="string">"2"</span>]</code><br>
<b>Since</b> 2.1<br>
</div>

<pre><span id="VALunfold_exc"><span class="keyword">let</span> unfold_exc</span> : <code class="type">(unit => 'a) => (list 'a, exn)</code></pre><div class="info ">
Creates a list containing the results of sequential calls
    to <code class="code">f()</code>. <code class="code">f()</code> is called repeatedly until it throws an exception.
    Both the results list, as well as the exception
    thrown are returned in a <code class="code">(results_list, exn)</code> pair.
    Warning: if calls to <code class="code">f()</code> never throw an exception, unfold_exc
    is an infinite loop.<br>
<b>Since</b> 2.3.0<br>
</div>
<br>
<h6 id="6_Iterators">Iterators</h6><br>

<pre><span id="VALiter"><span class="keyword">let</span> iter</span> : <code class="type">('a => unit) => list 'a => unit</code></pre><div class="info ">
<code class="code"><span class="constructor">List</span>.iter f [a0; a1; ...; an]</code> applies function <code class="code">f</code> in turn to
    <code class="code">a0; a1; ...; an</code>. It is equivalent to
    <code class="code"><span class="keyword">begin</span> f a0; f a1; ...; f an; () <span class="keyword">end</span></code>.<br>
</div>

<pre><span id="VALiteri"><span class="keyword">let</span> iteri</span> : <code class="type">(int => 'a => unit) => list 'a => unit</code></pre><div class="info ">
<code class="code">iteri f l</code> will call <code class="code">(f 0 a0); (f 1 a1) ... (f n an)</code> where
    <code class="code">a0..an</code> are the elements of the list <code class="code">l</code>.<br>
</div>

<pre><span id="VALmap"><span class="keyword">let</span> map</span> : <code class="type">('a => 'b) => list 'a => list 'b</code></pre><div class="info ">
<code class="code">map f [a0; a1; ...; an]</code> applies function <code class="code">f</code> to <code class="code">a0, a1, ..., an</code>,
    and builds the list <code class="code">[f a0; f a1; ...; f an]</code>
    with the results returned by <code class="code">f</code>.  Tail-recursive.<br>
</div>

<pre><span id="VALrev_map"><span class="keyword">let</span> rev_map</span> : <code class="type">('a => 'b) => list 'a => list 'b</code></pre><div class="info ">
<code class="code"><span class="constructor">List</span>.rev_map f l</code> gives the same result as
    <code class="code"><span class="constructor">List</span>.rev</code><code class="code"> (</code><code class="code"><span class="constructor">List</span>.map</code><code class="code"> f l)</code>.<br>
</div>

<pre><span id="VALmapi"><span class="keyword">let</span> mapi</span> : <code class="type">(int => 'a => 'b) => list 'a => list 'b</code></pre><div class="info ">
<code class="code">mapi f l</code> will build the list containing
    <code class="code">(f 0 a0); (f 1 a1) ... (f n an)</code> where <code class="code">a0..an</code> are the elements of
    the list <code class="code">l</code>.<br>
</div>

<pre><span id="VALfold_left"><span class="keyword">let</span> fold_left</span> : <code class="type">('a => 'b => 'a) => 'a => list 'b => 'a</code></pre><div class="info ">
<code class="code"><span class="constructor">List</span>.fold_left f a [b0; b1; ...; bn]</code> is
    <code class="code">f (... (f (f a b0) b1) ...) bn</code>.<br>
</div>

<pre><span id="VALfold_lefti"><span class="keyword">let</span> fold_lefti</span> : <code class="type">('a => int => 'b => 'a) => 'a => list 'b => 'a</code></pre><div class="info ">
As <code class="code">fold_left</code>, but with the index of the element, from <code class="code">0</code> to
    <code class="code">length li - 1</code>, as additional argument.<br>
<b>Since</b> 2.3.0<br>
</div>

<pre><span id="VALfold_right"><span class="keyword">let</span> fold_right</span> : <code class="type">('a => 'b => 'b) => list 'a => 'b => 'b</code></pre><div class="info ">
<code class="code"><span class="constructor">List</span>.fold_right f [a0; a1; ...; an] b</code> is
    <code class="code">f a0 (f a1 (... (f an b) ...))</code>.  Tail-recursive.<br>
</div>

<pre><span id="VALfold_righti"><span class="keyword">let</span> fold_righti</span> : <code class="type">(int => 'b => 'a => 'a) => list 'b => 'a => 'a</code></pre><div class="info ">
As <code class="code">fold_right</code>, but with the index of the element, from <code class="code">0</code> to
    <code class="code">length li - 1</code>, as additional argument.<br>
<b>Since</b> 2.3.0<br>
</div>

<pre><span id="VALreduce"><span class="keyword">let</span> reduce</span> : <code class="type">('a => 'a => 'a) => list 'a => 'a</code></pre><div class="info ">
<code class="code"><span class="constructor">List</span>.reduce f h::t</code> is <code class="code">fold_left f h t</code>.<br>
<b>Raises</b> <code>Invalid_argument</code> on empty list.<br>
</div>

<pre><span id="VALmax"><span class="keyword">let</span> max</span> : <code class="type">list 'a => 'a</code></pre><div class="info ">
<code class="code">max l</code> returns the largest value in <code class="code">l</code> as judged by
    <code class="code"><span class="constructor">Pervasives</span>.compare</code><br>
</div>

<pre><span id="VALmin"><span class="keyword">let</span> min</span> : <code class="type">list 'a => 'a</code></pre><div class="info ">
<code class="code">min l</code> returns the smallest value in <code class="code">l</code> as judged by
    <code class="code"><span class="constructor">Pervasives</span>.compare</code><br>
</div>

<pre><span id="VALsum"><span class="keyword">let</span> sum</span> : <code class="type">list int => int</code></pre><div class="info ">
<code class="code">sum l</code> returns the sum of the integers of <code class="code">l</code><br>
<b>Raises</b> <code>Invalid_argument</code> on the empty list.<br>
</div>

<pre><span id="VALfsum"><span class="keyword">let</span> fsum</span> : <code class="type">list float => float</code></pre><div class="info ">
<code class="code">fsum l</code> returns the sum of the floats of <code class="code">l</code><br>
<b>Raises</b> <code>Invalid_argument</code> on the empty list.<br>
</div>

<pre><span id="VALkahan_sum"><span class="keyword">let</span> kahan_sum</span> : <code class="type">list float => float</code></pre><div class="info ">
<code class="code">kahan_sum l</code> returns a numerically-accurate sum of the floats of
    <code class="code">l</code>. See <a href="BatArray.html#VALfsum"><code class="code"><span class="constructor">BatArray</span>.fsum</code></a> for more details.<br>
<b>Since</b> 2.2.0<br>
</div>

<pre><span id="VALmin_max"><span class="keyword">let</span> min_max</span> : <code class="type">cmp::('a => 'a => int)? => list 'a => ('a, 'a)</code></pre><div class="info ">
<code class="code">min_max l</code> returns the pair (smallest, largest) from <code class="code">l</code> as judged by
    <code class="code"><span class="constructor">Pervasives</span>.compare</code> (by default). You can provide another
    comparison function via the optional <code class="code">cmp</code> parameter.<br>
<b>Since</b> 2.1<br>
<b>Raises</b> <code>Invalid_argument</code> on an empty list.<br>
</div>
<br>
<h6 id="6_Iteratorsontwolists">Iterators on two lists</h6><br>

<pre><span id="VALiter2"><span class="keyword">let</span> iter2</span> : <code class="type">('a => 'b => unit) => list 'a => list 'b => unit</code></pre><div class="info ">
<code class="code"><span class="constructor">List</span>.iter2 f [a0; a1; ...; an] [b0; b1; ...; bn]</code> calls in turn
    <code class="code">f a0 b0; f a1 b1; ...; f an bn</code>.<br>
<b>Raises</b> <code>Different_list_size</code> if the two lists have
    different lengths.<br>
</div>

<pre><span id="VALmap2"><span class="keyword">let</span> map2</span> : <code class="type">('a => 'b => 'c) => list 'a => list 'b => list 'c</code></pre><div class="info ">
<code class="code"><span class="constructor">List</span>.map2 f [a0; a1; ...; an] [b0; b1; ...; bn]</code> is
    <code class="code">[f a0 b0; f a1 b1; ...; f an bn]</code>.<br>
<b>Raises</b> <code>Different_list_size</code> if the two lists have
    different lengths.  Tail-recursive.<br>
</div>

<pre><span id="VALrev_map2"><span class="keyword">let</span> rev_map2</span> : <code class="type">('a => 'b => 'c) => list 'a => list 'b => list 'c</code></pre><div class="info ">
<code class="code"><span class="constructor">List</span>.rev_map2 f l1 l2</code> gives the same result as
    <code class="code"><span class="constructor">List</span>.rev</code><code class="code"> (</code><code class="code"><span class="constructor">List</span>.map2</code><code class="code"> f l1 l2)</code>, but is tail-recursive and
    more efficient.<br>
</div>

<pre><span id="VALfold_left2"><span class="keyword">let</span> fold_left2</span> : <code class="type">('a => 'b => 'c => 'a) => 'a => list 'b => list 'c => 'a</code></pre><div class="info ">
<code class="code"><span class="constructor">List</span>.fold_left2 f a [b0; b1; ...; bn] [c0; c1; ...; cn]</code> is
    <code class="code">f (... (f (f a b0 c0) b1 c1) ...) bn cn</code>.<br>
<b>Raises</b> <code>Different_list_size</code> if the two lists have
    different lengths.<br>
</div>

<pre><span id="VALfold_right2"><span class="keyword">let</span> fold_right2</span> : <code class="type">('a => 'b => 'c => 'c) => list 'a => list 'b => 'c => 'c</code></pre><div class="info ">
<code class="code"><span class="constructor">List</span>.fold_right2 f [a0; a1; ...; an] [b0; b1; ...; bn] c</code> is
    <code class="code">f a0 b0 (f a1 b1 (... (f an bn c) ...))</code>.<br>
<b>Raises</b> <code>Different_list_size</code> if the two lists have
    different lengths.  Tail-recursive.<br>
</div>
<br>
<h6 id="6_Listscanning">List scanning</h6><br>

<pre><span id="VALmem"><span class="keyword">let</span> mem</span> : <code class="type">'a => list 'a => bool</code></pre><div class="info ">
<code class="code">mem a l</code> is true if and only if <code class="code">a</code> is equal
    to an element of <code class="code">l</code>.<br>
</div>

<pre><span id="VALmem_cmp"><span class="keyword">let</span> mem_cmp</span> : <code class="type">('a => 'a => int) => 'a => list 'a => bool</code></pre><div class="info ">
Same as <code class="code"><span class="constructor">List</span>.mem</code>, but the comparator function is explicitely
    provided.<br>
<b>Since</b> 2.2.0<br>
</div>

<pre><span id="VALmemq"><span class="keyword">let</span> memq</span> : <code class="type">'a => list 'a => bool</code></pre><div class="info ">
Same as <code class="code"><span class="constructor">List</span>.mem</code>, but uses physical equality instead of structural
    equality to compare list elements.<br>
</div>
<br>
<div class="h7" id="7_UnarypredicateOnelist">Unary predicate, One list</div><br>

<pre><span id="VALfor_all"><span class="keyword">let</span> for_all</span> : <code class="type">('a => bool) => list 'a => bool</code></pre><div class="info ">
<code class="code">for_all p [a0; a1; ...; an]</code> checks if all elements of the list
    satisfy the predicate <code class="code">p</code>. That is, it returns
    <code class="code">(p a0) <span class="keywordsign">&amp;&amp;</span> (p a1) <span class="keywordsign">&amp;&amp;</span> ... <span class="keywordsign">&amp;&amp;</span> (p an)</code>.<br>
</div>

<pre><span id="VALexists"><span class="keyword">let</span> exists</span> : <code class="type">('a => bool) => list 'a => bool</code></pre><div class="info ">
<code class="code">exists p [a0; a1; ...; an]</code> checks if at least one element of
    the list satisfies the predicate <code class="code">p</code>. That is, it returns
    <code class="code">(p a0) <span class="keywordsign">||</span> (p a1) <span class="keywordsign">||</span> ... <span class="keywordsign">||</span> (p an)</code>.<br>
</div>
<br>
<div class="h7" id="7_BinarypredicateTwolists">Binary predicate, Two lists</div><br>

<pre><span id="VALfor_all2"><span class="keyword">let</span> for_all2</span> : <code class="type">('a => 'b => bool) => list 'a => list 'b => bool</code></pre><div class="info ">
Same as <code class="code"><span class="constructor">List</span>.for_all</code>, but for a two-argument predicate.<br>
<b>Raises</b> <code>Invalid_argument</code> if the two lists have
    different lengths.<br>
</div>

<pre><span id="VALexists2"><span class="keyword">let</span> exists2</span> : <code class="type">('a => 'b => bool) => list 'a => list 'b => bool</code></pre><div class="info ">
Same as <code class="code"><span class="constructor">List</span>.exists</code>, but for a two-argument predicate.<br>
<b>Raises</b> <code>Invalid_argument</code> if the two lists have
    different lengths.<br>
</div>

<pre><span id="VALsubset"><span class="keyword">let</span> subset</span> : <code class="type">('a => 'b => int) => list 'a => list 'b => bool</code></pre><div class="info ">
<code class="code">subset cmp l l'</code> check if all elements of the list <code class="code">l</code>
    is contained in the list <code class="code">l'</code> by applying <code class="code">cmp</code> as comparator.<br>
<b>Since</b> 2.2.0<br>
</div>
<br>
<h6 id="6_Listsearching">List searching</h6><br>

<pre><span id="VALfind"><span class="keyword">let</span> find</span> : <code class="type">('a => bool) => list 'a => 'a</code></pre><div class="info ">
<code class="code">find p l</code> returns the first element of the list <code class="code">l</code>
    that satisfies the predicate <code class="code">p</code>.<br>
<b>Raises</b> <code>Not_found</code> if there is no value that satisfies <code class="code">p</code> in the
    list <code class="code">l</code>.<br>
</div>

<pre><span id="VALfind_exn"><span class="keyword">let</span> find_exn</span> : <code class="type">('a => bool) => exn => list 'a => 'a</code></pre><div class="info ">
<code class="code">find_exn p e l</code> returns the first element of <code class="code">l</code> such as <code class="code">p x</code>
    returns <code class="code"><span class="keyword">true</span></code> or raises <code class="code">e</code> if such an element has not been found.<br>
</div>

<pre><span id="VALfindi"><span class="keyword">let</span> findi</span> : <code class="type">(int => 'a => bool) => list 'a => (int, 'a)</code></pre><div class="info ">
<code class="code">findi p e l</code> returns the first element <code class="code">ai</code> of <code class="code">l</code> along with its
    index <code class="code">i</code> such that <code class="code">p i ai</code> is true, or<br>
<b>Raises</b> <code>Not_found</code> if no
    such element has been found.<br>
</div>

<pre><span id="VALfind_map"><span class="keyword">let</span> find_map</span> : <code class="type">('a => option 'b) => list 'a => 'b</code></pre><div class="info ">
<code class="code">find_map pred list</code> finds the first element of <code class="code">list</code> for which
    <code class="code">pred element</code> returns <code class="code"><span class="constructor">Some</span> r</code>.  It returns <code class="code">r</code> immediately
    once found or<br>
<b>Raises</b> <code>Not_found</code> if no element matches the
    predicate.  See also <a href="BatList.html#VALfilter_map"><code class="code"><span class="constructor">BatList</span>.filter_map</code></a>.<br>
</div>

<pre><span id="VALrfind"><span class="keyword">let</span> rfind</span> : <code class="type">('a => bool) => list 'a => 'a</code></pre><div class="info ">
<code class="code">rfind p l</code> returns the last element <code class="code">x</code> of <code class="code">l</code> such as <code class="code">p x</code> returns
    <code class="code"><span class="keyword">true</span></code> or<br>
<b>Raises</b> <code>Not_found</code> if such element as not been found.<br>
</div>

<pre><span id="VALfilter"><span class="keyword">let</span> filter</span> : <code class="type">('a => bool) => list 'a => list 'a</code></pre><div class="info ">
<code class="code">filter p l</code> returns all the elements of the list <code class="code">l</code>
    that satisfy the predicate <code class="code">p</code>.  The order of the elements
    in the input list is preserved.<br>
</div>

<pre><span id="VALfilteri"><span class="keyword">let</span> filteri</span> : <code class="type">(int => 'a => bool) => list 'a => list 'a</code></pre><div class="info ">
<code class="code">filter p [a0; a1; ...; an]</code> returns all the elements <code class="code">ai</code> of index <code class="code">i</code>
    that satisfy the predicate <code class="code">p i ai</code>.  The order of the elements
    in the input list is preserved.<br>
<b>Since</b> 2.2.0<br>
</div>

<pre><span id="VALfilter_map"><span class="keyword">let</span> filter_map</span> : <code class="type">('a => option 'b) => list 'a => list 'b</code></pre><div class="info ">
<code class="code">filter_map f l</code> calls <code class="code">(f a0) (f a1).... (f an)</code> where <code class="code">a0,a1..an</code> are
    the elements of <code class="code">l</code>. It returns the list of elements <code class="code">bi</code> such as
    <code class="code">f ai = <span class="constructor">Some</span> bi</code> (when <code class="code">f</code> returns <code class="code"><span class="constructor">None</span></code>, the corresponding element of
    <code class="code">l</code> is discarded).<br>
</div>

<pre><span id="VALfilteri_map"><span class="keyword">let</span> filteri_map</span> : <code class="type">(int => 'a => option 'b) => list 'a => list 'b</code></pre><div class="info ">
<code class="code">filter_map f l</code> calls <code class="code">(f 0 a0) (f 1 a1).... (f n an)</code> where <code class="code">a0,a1..an</code> are
    the elements of <code class="code">l</code>. It returns the list of elements <code class="code">bi</code> such as
    <code class="code">f ai = <span class="constructor">Some</span> bi</code> (when <code class="code">f</code> returns <code class="code"><span class="constructor">None</span></code>, the corresponding element of
    <code class="code">l</code> is discarded).<br>
<b>Since</b> 2.2.0<br>
</div>

<pre><span id="VALfind_all"><span class="keyword">let</span> find_all</span> : <code class="type">('a => bool) => list 'a => list 'a</code></pre><div class="info ">
<code class="code">find_all</code> is another name for <code class="code"><span class="constructor">List</span>.filter</code>.<br>
</div>

<pre><span id="VALpartition"><span class="keyword">let</span> partition</span> : <code class="type">('a => bool) => list 'a => (list 'a, list 'a)</code></pre><div class="info ">
<code class="code">partition p l</code> returns a pair of lists <code class="code">(l1, l2)</code>, where
    <code class="code">l1</code> is the list of all the elements of <code class="code">l</code> that
    satisfy the predicate <code class="code">p</code>, and <code class="code">l2</code> is the list of all the
    elements of <code class="code">l</code> that do not satisfy <code class="code">p</code>.
    The order of the elements in the input list is preserved.<br>
</div>

<pre><span id="VALindex_of"><span class="keyword">let</span> index_of</span> : <code class="type">'a => list 'a => option int</code></pre><div class="info ">
<code class="code">index_of e l</code> returns the index of the first occurrence of <code class="code">e</code>
    in <code class="code">l</code>, or <code class="code"><span class="constructor">None</span></code> if there is no occurrence of <code class="code">e</code> in <code class="code">l</code><br>
</div>

<pre><span id="VALindex_ofq"><span class="keyword">let</span> index_ofq</span> : <code class="type">'a => list 'a => option int</code></pre><div class="info ">
<code class="code">index_ofq e l</code> behaves as <code class="code">index_of e l</code> except it uses
    physical equality<br>
</div>

<pre><span id="VALrindex_of"><span class="keyword">let</span> rindex_of</span> : <code class="type">'a => list 'a => option int</code></pre><div class="info ">
<code class="code">rindex_of e l</code> returns the index of the last occurrence of <code class="code">e</code>
    in <code class="code">l</code>, or <code class="code"><span class="constructor">None</span></code> if there is no occurrence of <code class="code">e</code> in <code class="code">l</code><br>
</div>

<pre><span id="VALrindex_ofq"><span class="keyword">let</span> rindex_ofq</span> : <code class="type">'a => list 'a => option int</code></pre><div class="info ">
<code class="code">rindex_ofq e l</code> behaves as <code class="code">rindex_of e l</code> except it uses
    physical equality<br>
</div>

<pre><span id="VALunique"><span class="keyword">let</span> unique</span> : <code class="type">eq::('a => 'a => bool)? => list 'a => list 'a</code></pre><div class="info ">
<code class="code">unique cmp l</code> returns the list <code class="code">l</code> without any duplicate element.
    The default comparator ( = ) is used if no comparison function
    specified.
<p>

    Implementation Note: The current implementation removes any
    elements where the tail of the list contains an equal element,
    thus it keeps the *last* copy of each equal element.
<p>

    This function takes O(n^2) time.<br>
<b>Since</b> 2.0<br>
<b>See also</b> <code class="code">sort_unique</code> to save time in cases when reordering the list is
    acceptable<br>
</div>

<pre><span id="VALunique_cmp"><span class="keyword">let</span> unique_cmp</span> : <code class="type">cmp::('a => 'a => int)? => list 'a => list 'a</code></pre><div class="info ">
As <code class="code">unique</code>, except comparator parameter returns an int.  Default
    comparator is <code class="code"><span class="constructor">Pervasives</span>.compare</code>.  This function takes O(n log n)
    time.
<p>

    Implementation Note: The current implementation removes subsequent
    elements that compare as equal to earlier elements in the list,
    thus it keeps the *first* copy of each equal element.<br>
<b>Since</b> 1.3.0<br>
</div>

<pre><span id="VALunique_hash"><span class="keyword">let</span> unique_hash</span> : <code class="type">hash::('a => int)? => eq::('a => 'a => bool)? => list 'a => list 'a</code></pre><div class="info ">
As <code class="code">unique</code>, except uses a hash table to cut down the expected
    runtime to linear, assuming a good hash function.  <code class="code">?hash</code>
    defaults to <code class="code"><span class="constructor">Hashtbl</span>.hash</code> and <code class="code">?eq</code> defaults to <code class="code">(=)</code>.
<p>

    Implementation Note: The current implementation removes subsequent
    elements that hash and compare as equal to earlier elements in the
    list, thus it keeps the *first* copy of each equal element.<br>
<b>Since</b> 2.0.0<br>
</div>
<br>
<h6 id="6_Associationlists">Association lists</h6><br>

<pre><span id="VALassoc"><span class="keyword">let</span> assoc</span> : <code class="type">'a => list ('a, 'b) => 'b</code></pre><div class="info ">
<code class="code">assoc a l</code> returns the value associated with key <code class="code">a</code> in the list of
    pairs <code class="code">l</code>. That is,
    <code class="code">assoc a [ ...; (a,b); ...] = b</code>
    if <code class="code">(a,b)</code> is the leftmost binding of <code class="code">a</code> in list <code class="code">l</code>.<br>
<b>Raises</b> <code>Not_found</code> if there is no value associated with <code class="code">a</code> in the
    list <code class="code">l</code>.<br>
</div>

<pre><span id="VALassoc_inv"><span class="keyword">let</span> assoc_inv</span> : <code class="type">'b => list ('a, 'b) => 'a</code></pre><div class="info ">
<code class="code">assoc_inv b l</code> returns the key associated with value <code class="code">b</code> in the list of
    pairs <code class="code">l</code>. That is, <code class="code">assoc b [ ...; (a,b); ...] = a</code>
    if <code class="code">(a,b)</code> is the leftmost binding of <code class="code">a</code> in list <code class="code">l</code>.<br>
<b>Raises</b> <code>Not_found</code> if there is no key associated with <code class="code">b</code> in the
    list <code class="code">l</code>.<br>
</div>

<pre><span id="VALremove_assoc"><span class="keyword">let</span> remove_assoc</span> : <code class="type">'a => list ('a, 'b) => list ('a, 'b)</code></pre><div class="info ">
<code class="code">remove_assoc a l</code> returns the list of
    pairs <code class="code">l</code> without the first pair with key <code class="code">a</code>, if any.
    Tail-recursive.<br>
</div>

<pre><span id="VALmem_assoc"><span class="keyword">let</span> mem_assoc</span> : <code class="type">'a => list ('a, 'b) => bool</code></pre><div class="info ">
Same as <code class="code"><span class="constructor">List</span>.assoc</code>, but simply return true if a binding exists,
    and false if no bindings exist for the given key.<br>
</div>

<pre><span id="VALassq"><span class="keyword">let</span> assq</span> : <code class="type">'a => list ('a, 'b) => 'b</code></pre><div class="info ">
Same as <code class="code"><span class="constructor">List</span>.assoc</code>, but uses physical equality instead of structural
    equality to compare keys.<br>
</div>

<pre><span id="VALassq_inv"><span class="keyword">let</span> assq_inv</span> : <code class="type">'b => list ('a, 'b) => 'a</code></pre><div class="info ">
Same as <code class="code"><span class="constructor">List</span>.assoc_inv</code>, but uses physical equality instead of structural
    equality to compare keys.<br>
</div>

<pre><span id="VALremove_assq"><span class="keyword">let</span> remove_assq</span> : <code class="type">'a => list ('a, 'b) => list ('a, 'b)</code></pre><div class="info ">
Same as <code class="code"><span class="constructor">List</span>.remove_assoc</code>, but uses physical equality instead
    of structural equality to compare keys.  Tail-recursive.<br>
</div>

<pre><span id="VALmem_assq"><span class="keyword">let</span> mem_assq</span> : <code class="type">'a => list ('a, 'b) => bool</code></pre><div class="info ">
Same as <code class="code"><span class="constructor">List</span>.mem_assoc</code>, but uses physical equality instead of
    structural equality to compare keys.<br>
</div>

<pre><span id="VALmodify"><span class="keyword">let</span> modify</span> : <code class="type">'a => ('b => 'b) => list ('a, 'b) => list ('a, 'b)</code></pre><div class="info ">
<code class="code">modify a f l</code> returns the same list as <code class="code">l</code> but with value associated
    to key <code class="code">a</code> replaced with <code class="code">f a</code>.<br>
<b>Since</b> 2.1<br>
<b>Raises</b> <code>Not_found</code> if no value is associated with <code class="code">a</code> in <code class="code">l</code><br>
</div>

<pre><span id="VALmodify_def"><span class="keyword">let</span> modify_def</span> : <code class="type">'b => 'a => ('b => 'b) => list ('a, 'b) => list ('a, 'b)</code></pre><div class="info ">
<code class="code">modify_def dfl a f l</code> performs as <code class="code">modify a f l</code> except that it
    add an association from <code class="code">a</code> to <code class="code">f dfl</code> instead of raising <code class="code"><span class="constructor">Not_found</span></code>.<br>
<b>Since</b> 2.1<br>
</div>

<pre><span id="VALmodify_opt"><span class="keyword">let</span> modify_opt</span> : <code class="type">'a => (option 'b => option 'b) => list ('a, 'b) => list ('a, 'b)</code></pre><div class="info ">
<code class="code">modify_opt a f l</code> allows to modify the binding for <code class="code">a</code> in <code class="code">l</code>
    or absence thereof.<br>
<b>Since</b> 2.1<br>
</div>
<br>
<h6 id="6_Listtransformations">List transformations</h6><br>

<pre><span id="VALmodify_at"><span class="keyword">let</span> modify_at</span> : <code class="type">int => ('a => 'a) => list 'a => list 'a</code></pre><div class="info ">
<code class="code">modify_at n f l</code> returns the same list as <code class="code">l</code>
    but with nth-value <code class="code">a</code> replaced with <code class="code">f a</code>.<br>
<b>Since</b> 2.3.0<br>
<b>Raises</b> <code>Invalid_argument</code> if the index is outside of <code class="code">l</code> bounds<br>
</div>

<pre><span id="VALmodify_opt_at"><span class="keyword">let</span> modify_opt_at</span> : <code class="type">int => ('a => option 'a) => list 'a => list 'a</code></pre><div class="info ">
<code class="code">modify_at_opt n f l</code> returns the same list as <code class="code">l</code> but with
    nth-value <code class="code">a</code> removed if <code class="code">f a</code> is <code class="code"><span class="constructor">None</span></code>, and replaced by <code class="code">v</code> if
    it is <code class="code"><span class="constructor">Some</span> v</code>.<br>
<b>Since</b> 2.3.0<br>
<b>Raises</b> <code>Invalid_argument</code> if the index is outside of <code class="code">l</code> bounds<br>
</div>

<pre><span id="VALsplit_at"><span class="keyword">let</span> split_at</span> : <code class="type">int => list 'a => (list 'a, list 'a)</code></pre><div class="info ">
<code class="code">split_at n l</code> returns two lists <code class="code">l1</code> and <code class="code">l2</code>, <code class="code">l1</code> containing the
    first <code class="code">n</code> elements of <code class="code">l</code> and <code class="code">l2</code> the others.<br>
<b>Raises</b> <code>Invalid_argument</code> if
    <code class="code">n</code> is outside of <code class="code">l</code> size bounds.<br>
</div>

<pre><span id="VALsplit_nth"><span class="keyword">let</span> split_nth</span> : <code class="type">int => list 'a => (list 'a, list 'a)</code></pre><div class="info ">
Obsolete. As <code class="code">split_at</code>.<br>
</div>

<pre><span id="VALremove"><span class="keyword">let</span> remove</span> : <code class="type">list 'a => 'a => list 'a</code></pre><div class="info ">
<code class="code">remove l x</code> returns the list <code class="code">l</code> without the first element <code class="code">x</code> found
    or returns  <code class="code">l</code> if no element is equal to <code class="code">x</code>. Elements are compared
    using ( = ).<br>
</div>

<pre><span id="VALremove_if"><span class="keyword">let</span> remove_if</span> : <code class="type">('a => bool) => list 'a => list 'a</code></pre><div class="info ">
<code class="code">remove_if cmp l</code> is similar to <code class="code">remove</code>, but with <code class="code">cmp</code> used
    instead of ( = ).<br>
</div>

<pre><span id="VALremove_at"><span class="keyword">let</span> remove_at</span> : <code class="type">int => list 'a => list 'a</code></pre><div class="info ">
<code class="code">remove_at i l</code> returns the list <code class="code">l</code> without the element at index <code class="code">i</code>.<br>
<b>Since</b> 2.3.0<br>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">i</code> is outside of <code class="code">l</code> size bounds.<br>
</div>

<pre><span id="VALremove_all"><span class="keyword">let</span> remove_all</span> : <code class="type">list 'a => 'a => list 'a</code></pre><div class="info ">
<code class="code">remove_all l x</code> is similar to <code class="code">remove</code> but removes all elements that
    are equal to <code class="code">x</code> and not only the first one.<br>
</div>

<pre><span id="VALtake"><span class="keyword">let</span> take</span> : <code class="type">int => list 'a => list 'a</code></pre><div class="info ">
<code class="code">take n l</code> returns up to the <code class="code">n</code> first elements from list <code class="code">l</code>, if
    available.<br>
</div>

<pre><span id="VALntake"><span class="keyword">let</span> ntake</span> : <code class="type">int => list 'a => list (list 'a)</code></pre><div class="info ">
<code class="code">ntake n l</code> cuts <code class="code">l</code> into lists of size at most <code class="code">n</code>.
    <code class="code">n</code> must be &gt; 0.<br>
<b>Since</b> 2.2.0<br>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">n</code> &lt;= 0.
    Each list in the result has size n, except the last
    one which may have fewer elements in case <code class="code">l</code> was too short.
    Example: <code class="code">ntake 2 [1; 2; 3; 4; 5] = [[1; 2]; [3; 4]; [5]]</code><br>
</div>

<pre><span id="VALdrop"><span class="keyword">let</span> drop</span> : <code class="type">int => list 'a => list 'a</code></pre><div class="info ">
<code class="code">drop n l</code> returns <code class="code">l</code> without the first <code class="code">n</code> elements, or the empty
    list if <code class="code">l</code> have less than <code class="code">n</code> elements.<br>
</div>

<pre><span id="VALtakedrop"><span class="keyword">let</span> takedrop</span> : <code class="type">int => list 'a => (list 'a, list 'a)</code></pre><div class="info ">
<code class="code">take_drop n l</code> is equivalent to <code class="code">(take n l, drop n l)</code>
    but is done in one pass.<br>
<b>Since</b> 2.2.0<br>
</div>

<pre><span id="VALtake_while"><span class="keyword">let</span> take_while</span> : <code class="type">('a => bool) => list 'a => list 'a</code></pre><div class="info ">
<code class="code">take_while p xs</code> returns the (possibly empty) longest prefix of
    elements of <code class="code">xs</code> that satisfy the predicate <code class="code">p</code>.<br>
</div>

<pre><span id="VALdrop_while"><span class="keyword">let</span> drop_while</span> : <code class="type">('a => bool) => list 'a => list 'a</code></pre><div class="info ">
<code class="code">drop_while p xs</code> returns the suffix remaining after
    <code class="code">take_while p xs</code>.<br>
</div>

<pre><span id="VALspan"><span class="keyword">let</span> span</span> : <code class="type">('a => bool) => list 'a => (list 'a, list 'a)</code></pre><div class="info ">
<code class="code">span</code>, applied to a predicate <code class="code">p</code> and a list <code class="code">xs</code>, returns a
    tuple where first element is longest prefix (possibly empty) of xs
    of elements that satisfy p and second element is the remainder of
    the list. This is equivalent to <code class="code">(take_while p xs, drop_while p xs)</code>,
    but is done in one pass.<br>
<b>Since</b> 2.1<br>
</div>

<pre><span id="VALnsplit"><span class="keyword">let</span> nsplit</span> : <code class="type">('a => bool) => list 'a => list (list 'a)</code></pre><div class="info ">
<code class="code">nsplit</code>, applied to a predicate <code class="code">p</code> and a list <code class="code">xs</code>, returns a
    list of lists. <code class="code">xs</code> is split when <code class="code">p x</code> is true and <code class="code">x</code> is excluded
    from the result.
<p>

    If elements that satisfy <code class="code">p</code> are consecutive, or at the beginning
    or end of the input list, the output list will contain empty lists
    marking their position. For example,
    <code class="code">split (<span class="keyword">fun</span> n <span class="keywordsign">-&gt;</span> n&lt;0) [-1;2;-2;-3;4;-5]</code> is <code class="code">[[];[2];[];[4];[]]</code>.
    This is consistent with the behavior of <code class="code"><span class="constructor">String</span>.nsplit</code>, where
    <code class="code"><span class="constructor">String</span>.nsplit <span class="string">";"</span> <span class="string">"1;2;;3;"</span> = [<span class="string">"1"</span>;<span class="string">"2"</span>;<span class="string">""</span>;<span class="string">"3"</span>;<span class="string">""</span>]</code>.
<p>

    Note that for any <code class="code">xss : <span class="keywordsign">'</span>a list list</code> and <code class="code">sep : <span class="keywordsign">'</span>a</code>, we always have
    that <code class="code">flatten (interleave [sep] (nsplit ((=) sep) xss))</code> is <code class="code">xss</code>.<br>
<b>Since</b> 2.1<br>
</div>

<pre><span id="VALgroup_consecutive"><span class="keyword">let</span> group_consecutive</span> : <code class="type">('a => 'a => bool) => list 'a => list (list 'a)</code></pre><div class="info ">
The <code class="code">group_consecutive</code> function takes a list and returns a list of lists such
    that the concatenation of the result is equal to the argument. Moreover, each
    sublist in the result contains only equal elements. For example,
    <code class="code">group_consecutive (=) [3;3;4;3;3] =  [[3;3];[4];[3;3]]</code>.
<p>

    <b>Note:</b> In the next major version, this function is intended to replace the
    current <code class="code">group</code>, which also sorts its input before grouping, and which will
    therefore be renamed into something more pertinent, such as <code class="code">classify</code>,
    <code class="code">regroup</code>, or <code class="code">group_sort</code>.<br>
<b>Since</b> 2.1<br>
</div>

<pre><span id="VALinterleave"><span class="keyword">let</span> interleave</span> : <code class="type">first::'a? => last::'a? => 'a => list 'a => list 'a</code></pre><div class="info ">
<code class="code">interleave ~first ~last sep [a0;a1;a2;...;an]</code> returns
    <code class="code">first; a0; sep; a1; sep; a2; sep; ...; sep; an; last</code><br>
</div>
<br>
<h6 id="6_BatEnumfunctions">BatEnum functions</h6>
<p>

    Abstraction layer.<br>

<pre><span id="VALenum"><span class="keyword">let</span> enum</span> : <code class="type">list 'a => <a href="BatEnum.html#TYPEt">BatEnum.t</a> 'a</code></pre><div class="info ">
Returns an enumeration of the elements of a list. This enumeration may
    be used to visit elements of the list in forward order (i.e. from the
    first element to the last one)<br>
</div>

<pre><span id="VALof_enum"><span class="keyword">let</span> of_enum</span> : <code class="type"><a href="BatEnum.html#TYPEt">BatEnum.t</a> 'a => list 'a</code></pre><div class="info ">
Build a list from an enumeration. In the result, elements appear in the
    same order as they did in the source enumeration.<br>
</div>

<pre><span id="VALbackwards"><span class="keyword">let</span> backwards</span> : <code class="type">list 'a => <a href="BatEnum.html#TYPEt">BatEnum.t</a> 'a</code></pre><div class="info ">
Returns an enumeration of the elements of a list. This enumeration may
    be used to visit elements of the list in backwards order (i.e. from the
    last element to the first one)<br>
</div>

<pre><span id="VALof_backwards"><span class="keyword">let</span> of_backwards</span> : <code class="type"><a href="BatEnum.html#TYPEt">BatEnum.t</a> 'a => list 'a</code></pre><div class="info ">
Build a list from an enumeration. The first element of the enumeration
    becomes the last element of the list, the second element of the
    enumeration
    becomes the second-to-last element of the list...<br>
</div>
<br>
<h6 id="6_Listofpairs">List of pairs</h6><br>

<pre><span id="VALsplit"><span class="keyword">let</span> split</span> : <code class="type">list ('a, 'b) => (list 'a, list 'b)</code></pre><div class="info ">
Transform a list of pairs into a pair of lists:
    <code class="code">split [(a0,b0); (a1,b1); ...; (an,bn)]</code> is <code class="code">([a0; a1; ...; an], [b0;
    b1; ...; bn])</code>.
    Tail-recursive.<br>
</div>

<pre><span id="VALcombine"><span class="keyword">let</span> combine</span> : <code class="type">list 'a => list 'b => list ('a, 'b)</code></pre><div class="info ">
Transform a pair of lists into a list of pairs:
    <code class="code">combine [a0; a1; ...; an] [b0; b1; ...; bn]</code> is
    <code class="code">[(a0,b0); (a1,b1); ...; (an,bn)]</code>.<br>
<b>Raises</b> <code>Different_list_size</code> if the two lists
    have different lengths.  Tail-recursive.<br>
</div>
<br>
<h6 id="6_Sorting">Sorting</h6><br>

<pre><span id="VALsort"><span class="keyword">let</span> sort</span> : <code class="type">('a => 'a => int) => list 'a => list 'a</code></pre><div class="info ">
Sort a list in increasing order according to a comparison
    function.  The comparison function must return 0 if its arguments
    compare as equal, a positive integer if the first is greater,
    and a negative integer if the first is smaller (see Array.sort for
    a complete specification).  For example,
    <code class="code"><span class="constructor">Pervasives</span>.compare</code> is a suitable comparison function.
    The resulting list is sorted in increasing order.
    <code class="code"><span class="constructor">List</span>.sort</code> is guaranteed to run in constant heap space
    (in addition to the size of the result list) and logarithmic
    stack space.
<p>

    The current implementation uses Merge Sort. It runs in constant
    heap space and logarithmic stack space.<br>
</div>

<pre><span id="VALstable_sort"><span class="keyword">let</span> stable_sort</span> : <code class="type">('a => 'a => int) => list 'a => list 'a</code></pre><div class="info ">
Same as <code class="code"><span class="constructor">List</span>.sort</code>, but the sorting algorithm is guaranteed to
    be stable (i.e. elements that compare equal are kept in their
    original order) .
<p>

    The current implementation uses Merge Sort. It runs in constant
    heap space and logarithmic stack space.<br>
</div>

<pre><span id="VALfast_sort"><span class="keyword">let</span> fast_sort</span> : <code class="type">('a => 'a => int) => list 'a => list 'a</code></pre><div class="info ">
Same as <code class="code"><span class="constructor">List</span>.sort</code> or <code class="code"><span class="constructor">List</span>.stable_sort</code>, whichever is faster
    on typical input.<br>
</div>

<pre><span id="VALmerge"><span class="keyword">let</span> merge</span> : <code class="type">('a => 'a => int) => list 'a => list 'a => list 'a</code></pre><div class="info ">
Merge two lists:
    Assuming that <code class="code">l1</code> and <code class="code">l2</code> are sorted according to the
    comparison function <code class="code">cmp</code>, <code class="code">merge cmp l1 l2</code> will return a
    sorted list containting all the elements of <code class="code">l1</code> and <code class="code">l2</code>.
    If several elements compare equal, the elements of <code class="code">l1</code> will be
    before the elements of <code class="code">l2</code>.
    Not tail-recursive (sum of the lengths of the arguments).<br>
</div>

<pre><span id="VALsort_uniq"><span class="keyword">let</span> sort_uniq</span> : <code class="type">('a => 'a => int) => list 'a => list 'a</code></pre><div class="info ">
<code class="code">sort_uniq cmp l</code> returns the list <code class="code">l</code> sorted and without any
    duplicate element. <code class="code">cmp</code> is a usual comparison function providing
    total order.
<p>

    This function takes O(n log n) time.<br>
<b>Since</b> 2.3.0<br>
</div>

<pre><span id="VALsort_unique"><span class="keyword">let</span> sort_unique</span> : <code class="type">('a => 'a => int) => list 'a => list 'a</code></pre><div class="info ">
synonym for <code class="code">sort_uniq</code><br>
</div>
<br>
<h6 id="6_Utilities">Utilities</h6><br>

<pre><span id="VALgroup"><span class="keyword">let</span> group</span> : <code class="type">('a => 'a => int) => list 'a => list (list 'a)</code></pre><div class="info ">
<code class="code">group cmp l</code> returns list of groups and each group consists of
    elements judged equal by comparison function <code class="code">cmp</code>. Groups in the resulting
    list appear in order given by <code class="code">cmp</code>. All groups are always nonempty. <code class="code">group</code>
    returns <code class="code">[]</code> only if <code class="code">l</code> is empty.
<p>

    For example <code class="code">group cmp [f;c;b;e;d;a]</code> can give <code class="code">[[a;b];[c];[d;e;f]]</code> if
    following conditions are met:
    <code class="code">cmp a b = 0</code>, <code class="code">cmp b c = -1</code>, <code class="code">cmp c d = -1</code>, <code class="code">cmp d e = 0</code>,...
<p>

    See the note on <code class="code">group_consecutive</code>.<br>
</div>

<pre><span id="VALcartesian_product"><span class="keyword">let</span> cartesian_product</span> : <code class="type">list 'a => list 'b => list ('a, 'b)</code></pre><div class="info ">
Different from <code class="code"><span class="constructor">List</span>.combine</code>, this returns every pair
    of elements formed out of the two lists.
    <code class="code">cartesian_product [a0; a1; ...; an] [b0; b1; ...; bn] =
    [(a0,b0);(a0,b1); ...; (a0,bn); (a1,b0); ..; (a1, bn);
    ...; (an,bn)]</code>.  The lists can be of unequal size.<br>
</div>

<pre><span id="VALn_cartesian_product"><span class="keyword">let</span> n_cartesian_product</span> : <code class="type">list (list 'a) => list (list 'a)</code></pre><div class="info ">
Given n lists, return the n-way cartesian product of
    these lists.  Given <code class="code">[a;b];[c];[d;e;f]</code>, returns
    <code class="code">[a;c;d];[a;c;e];[a;c;f];[b;c;d];[b;c;e];[b;c;f]</code>, all
    ways of choosing one element from each input list.<br>
</div>

<pre><span id="VALtranspose"><span class="keyword">let</span> transpose</span> : <code class="type">list (list 'a) => list (list 'a)</code></pre><div class="info ">
Transposes a list of lists, turning rows of the input into columns
    of the output and vice versa.<br>
<b>Since</b> 2.0.0<br>
</div>
<br>
<h6 id="6_Boilerplatecode">Boilerplate code</h6><br>
<br>
<h6 id="6_Boilerplatecode">Boilerplate code</h6><br>
<br>
<div class="h7" id="7_Printing">Printing</div><br>

<pre><span id="VALprint"><span class="keyword">let</span> print</span> : <code class="type">first::string? =><br>       last::string? =><br>       sep::string? =><br>       (<a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> 'a => 'b => unit) =><br>       <a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> 'a => list 'b => unit</code></pre><div class="info ">
Print the contents of a list<br>
</div>

<pre><span id="VALeq"><span class="keyword">let</span> eq</span> : <code class="type"><a href="BatOrd.html#TYPEeq">BatOrd.eq</a> 'a => <a href="BatOrd.html#TYPEeq">BatOrd.eq</a> (list 'a)</code></pre>
<pre><span id="VALord"><span class="keyword">let</span> ord</span> : <code class="type"><a href="BatOrd.html#TYPEord">BatOrd.ord</a> 'a => <a href="BatOrd.html#TYPEord">BatOrd.ord</a> (list 'a)</code></pre>
<pre><span id="VALcompare"><span class="keyword">let</span> compare</span> : <code class="type"><a href="BatOrd.html#TYPEcomp">BatOrd.comp</a> 'a => <a href="BatOrd.html#TYPEcomp">BatOrd.comp</a> (list 'a)</code></pre><br>
Comparison and equality for lists based on element comparison and
    equality<br>

<pre><span class="keyword">module</span> <a href="BatList.Eq.html">Eq</a>: <div class="sig_block"><code class="code">(</code><code class="code"><span class="constructor">T</span></code><code class="code"> : </code><code class="type"><a href="BatOrd.Eq.html">BatOrd.Eq</a></code><code class="code">) =&gt; </code><code class="type">Eq</code><code class="type">  with type t = T.t list</code></div></pre>
<pre><span class="keyword">module</span> <a href="BatList.Ord.html">Ord</a>: <div class="sig_block"><code class="code">(</code><code class="code"><span class="constructor">T</span></code><code class="code"> : </code><code class="type"><a href="BatOrd.Ord.html">BatOrd.Ord</a></code><code class="code">) =&gt; </code><code class="type">Ord</code><code class="type">  with type t = T.t list</code></div></pre>
<pre><span class="keyword">module</span> <a href="BatList.Comp.html">Comp</a>: <div class="sig_block"><code class="code">(</code><code class="code"><span class="constructor">T</span></code><code class="code"> : </code><code class="type"><a href="BatOrd.Comp.html">BatOrd.Comp</a></code><code class="code">) =&gt; </code><code class="type">Comp</code><code class="type">  with type t = T.t list</code></div></pre><br>
<h6 id="6_Obsoletefunctions">Obsolete functions</h6><br>

<pre><span id="VALnth"><span class="keyword">let</span> nth</span> : <code class="type">list 'a => int => 'a</code></pre><div class="info ">
Obsolete. As <code class="code">at</code>.<br>
</div>

<pre><span id="VALtakewhile"><span class="keyword">let</span> takewhile</span> : <code class="type">('a => bool) => list 'a => list 'a</code></pre><div class="info ">
obsolete, as <a href="BatList.html#VALtake_while"><code class="code"><span class="constructor">BatList</span>.take_while</code></a><br>
</div>

<pre><span id="VALdropwhile"><span class="keyword">let</span> dropwhile</span> : <code class="type">('a => bool) => list 'a => list 'a</code></pre><div class="info ">
obsolete, as <a href="BatList.html#VALdrop_while"><code class="code"><span class="constructor">BatList</span>.drop_while</code></a><br>
</div>
<br>
<h6 id="6_Overridemodules">Override modules</h6><br>
<br>
<h6 id="6_Overridemodules">Override modules</h6><br>
<br>
The following modules replace functions defined in <code class="code"><span class="constructor">List</span></code> with functions
   behaving slightly differently but having the same name. This is by
   design:
   the functions meant to override the corresponding functions of <code class="code"><span class="constructor">List</span></code>.<br>

<pre><span class="keyword">module</span> <a href="BatList.Exceptionless.html">Exceptionless</a>: <code class="code">{</code> <a href="BatList.Exceptionless.html">..</a> <code class="code">}</code></pre><div class="info">
Exceptionless counterparts for error-raising operations
</div>

<pre><span class="keyword">module</span> <a href="BatList.Infix.html">Infix</a>: <code class="code">{</code> <a href="BatList.Infix.html">..</a> <code class="code">}</code></pre><div class="info">
Infix submodule regrouping all infix operators
</div>

<pre><span class="keyword">module</span> <a href="BatList.Labels.html">Labels</a>: <code class="code">{</code> <a href="BatList.Labels.html">..</a> <code class="code">}</code></pre><div class="info">
Operations on <code class="code"><span class="constructor">List</span></code> with labels.
</div>

<pre><span id="VAL(@)"><span class="keyword">let</span> (@)</span> : <code class="type">list 'a => list 'a => list 'a</code></pre><div class="info ">
Tail recursive <code class="code"><span class="constructor">List</span>.append</code>.<br>
</div>
</body></html>