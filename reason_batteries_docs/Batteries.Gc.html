<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Batteries.Format.html">
<link rel="next" href="Batteries.Genlex.html">
<link rel="Up" href="Batteries.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="BatArray" rel="Chapter" href="BatArray.html">
<link title="BatAvlTree" rel="Chapter" href="BatAvlTree.html">
<link title="BatBase64" rel="Chapter" href="BatBase64.html">
<link title="BatBig_int" rel="Chapter" href="BatBig_int.html">
<link title="BatBigarray" rel="Chapter" href="BatBigarray.html">
<link title="BatBitSet" rel="Chapter" href="BatBitSet.html">
<link title="BatBool" rel="Chapter" href="BatBool.html">
<link title="BatBounded" rel="Chapter" href="BatBounded.html">
<link title="BatBuffer" rel="Chapter" href="BatBuffer.html">
<link title="BatBytes" rel="Chapter" href="BatBytes.html">
<link title="BatCache" rel="Chapter" href="BatCache.html">
<link title="BatChar" rel="Chapter" href="BatChar.html">
<link title="BatCharParser" rel="Chapter" href="BatCharParser.html">
<link title="BatComplex" rel="Chapter" href="BatComplex.html">
<link title="BatConcurrent" rel="Chapter" href="BatConcurrent.html">
<link title="BatDeque" rel="Chapter" href="BatDeque.html">
<link title="BatDigest" rel="Chapter" href="BatDigest.html">
<link title="BatDllist" rel="Chapter" href="BatDllist.html">
<link title="BatDynArray" rel="Chapter" href="BatDynArray.html">
<link title="BatEnum" rel="Chapter" href="BatEnum.html">
<link title="BatFile" rel="Chapter" href="BatFile.html">
<link title="BatFingerTree" rel="Chapter" href="BatFingerTree.html">
<link title="BatFloat" rel="Chapter" href="BatFloat.html">
<link title="BatFormat" rel="Chapter" href="BatFormat.html">
<link title="BatGc" rel="Chapter" href="BatGc.html">
<link title="BatGenlex" rel="Chapter" href="BatGenlex.html">
<link title="BatGlobal" rel="Chapter" href="BatGlobal.html">
<link title="BatHashcons" rel="Chapter" href="BatHashcons.html">
<link title="BatHashtbl" rel="Chapter" href="BatHashtbl.html">
<link title="BatHeap" rel="Chapter" href="BatHeap.html">
<link title="BatIMap" rel="Chapter" href="BatIMap.html">
<link title="BatIO" rel="Chapter" href="BatIO.html">
<link title="BatISet" rel="Chapter" href="BatISet.html">
<link title="BatInnerIO" rel="Chapter" href="BatInnerIO.html">
<link title="BatInnerPervasives" rel="Chapter" href="BatInnerPervasives.html">
<link title="BatInnerWeaktbl" rel="Chapter" href="BatInnerWeaktbl.html">
<link title="BatInt" rel="Chapter" href="BatInt.html">
<link title="BatInt32" rel="Chapter" href="BatInt32.html">
<link title="BatInt64" rel="Chapter" href="BatInt64.html">
<link title="BatInterfaces" rel="Chapter" href="BatInterfaces.html">
<link title="BatLazyList" rel="Chapter" href="BatLazyList.html">
<link title="BatLexing" rel="Chapter" href="BatLexing.html">
<link title="BatList" rel="Chapter" href="BatList.html">
<link title="BatLog" rel="Chapter" href="BatLog.html">
<link title="BatLogger" rel="Chapter" href="BatLogger.html">
<link title="BatMap" rel="Chapter" href="BatMap.html">
<link title="BatMarshal" rel="Chapter" href="BatMarshal.html">
<link title="BatMultiMap" rel="Chapter" href="BatMultiMap.html">
<link title="BatMultiPMap" rel="Chapter" href="BatMultiPMap.html">
<link title="BatMutex" rel="Chapter" href="BatMutex.html">
<link title="BatNativeint" rel="Chapter" href="BatNativeint.html">
<link title="BatNum" rel="Chapter" href="BatNum.html">
<link title="BatNumber" rel="Chapter" href="BatNumber.html">
<link title="BatOo" rel="Chapter" href="BatOo.html">
<link title="BatOptParse" rel="Chapter" href="BatOptParse.html">
<link title="BatOption" rel="Chapter" href="BatOption.html">
<link title="BatOrd" rel="Chapter" href="BatOrd.html">
<link title="BatParserCo" rel="Chapter" href="BatParserCo.html">
<link title="BatPathGen" rel="Chapter" href="BatPathGen.html">
<link title="BatPervasives" rel="Chapter" href="BatPervasives.html">
<link title="BatPrintexc" rel="Chapter" href="BatPrintexc.html">
<link title="BatPrintf" rel="Chapter" href="BatPrintf.html">
<link title="BatQueue" rel="Chapter" href="BatQueue.html">
<link title="BatRMutex" rel="Chapter" href="BatRMutex.html">
<link title="BatRandom" rel="Chapter" href="BatRandom.html">
<link title="BatRef" rel="Chapter" href="BatRef.html">
<link title="BatRefList" rel="Chapter" href="BatRefList.html">
<link title="BatResult" rel="Chapter" href="BatResult.html">
<link title="BatReturn" rel="Chapter" href="BatReturn.html">
<link title="BatScanf" rel="Chapter" href="BatScanf.html">
<link title="BatSeq" rel="Chapter" href="BatSeq.html">
<link title="BatSet" rel="Chapter" href="BatSet.html">
<link title="BatSplay" rel="Chapter" href="BatSplay.html">
<link title="BatStack" rel="Chapter" href="BatStack.html">
<link title="BatStream" rel="Chapter" href="BatStream.html">
<link title="BatString" rel="Chapter" href="BatString.html">
<link title="BatSubstring" rel="Chapter" href="BatSubstring.html">
<link title="BatSys" rel="Chapter" href="BatSys.html">
<link title="BatText" rel="Chapter" href="BatText.html">
<link title="BatTuple" rel="Chapter" href="BatTuple.html">
<link title="BatUChar" rel="Chapter" href="BatUChar.html">
<link title="BatUTF8" rel="Chapter" href="BatUTF8.html">
<link title="BatUnit" rel="Chapter" href="BatUnit.html">
<link title="BatUnix" rel="Chapter" href="BatUnix.html">
<link title="BatUref" rel="Chapter" href="BatUref.html">
<link title="BatVect" rel="Chapter" href="BatVect.html">
<link title="Batteries" rel="Chapter" href="Batteries.html">
<link title="BatteriesConfig" rel="Chapter" href="BatteriesConfig.html">
<link title="BatteriesExceptionless" rel="Chapter" href="BatteriesExceptionless.html">
<link title="BatteriesPrint" rel="Chapter" href="BatteriesPrint.html">
<link title="BatteriesThread" rel="Chapter" href="BatteriesThread.html">
<link title="Extlib" rel="Chapter" href="Extlib.html"><title>Batteries user guide : Batteries.Gc</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Batteries.Format.html" title="Batteries.Format">Previous</a>
&nbsp;<a class="up" href="Batteries.html" title="Batteries">Up</a>
&nbsp;<a class="post" href="Batteries.Genlex.html" title="Batteries.Genlex">Next</a>
</div>
<h1>Module <a href="type_Batteries.Gc.html">Batteries.Gc</a></h1>

<pre><span class="keyword">module</span> Gc: <code class="type"><a href="BatGc.html">BatGc</a></code></pre><hr width="100%">

<pre><span id="TYPEstat"><span class="keyword">type</span> stat<code class="type"></code></span> = <code class="type">Gc.stat</code> = {</pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstat.minor_words">minor_words</span>&nbsp;: <code class="type">float</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Number of words allocated in the minor heap since
        the program was started.  This number is accurate in
        byte-code programs, but only an approximation in programs
        compiled to native code.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstat.promoted_words">promoted_words</span>&nbsp;: <code class="type">float</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Number of words allocated in the minor heap that
        survived a minor collection and were moved to the major heap
        since the program was started.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstat.major_words">major_words</span>&nbsp;: <code class="type">float</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Number of words allocated in the major heap, including
        the promoted words, since the program was started.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstat.minor_collections">minor_collections</span>&nbsp;: <code class="type">int</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Number of minor collections since the program was started.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstat.major_collections">major_collections</span>&nbsp;: <code class="type">int</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Number of major collection cycles completed since the program
        was started.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstat.heap_words">heap_words</span>&nbsp;: <code class="type">int</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Total size of the major heap, in words.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstat.heap_chunks">heap_chunks</span>&nbsp;: <code class="type">int</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Number of contiguous pieces of memory that make up the major heap.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstat.live_words">live_words</span>&nbsp;: <code class="type">int</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Number of words of live data in the major heap, including the header
        words.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstat.live_blocks">live_blocks</span>&nbsp;: <code class="type">int</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Number of live blocks in the major heap.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstat.free_words">free_words</span>&nbsp;: <code class="type">int</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Number of words in the free list.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstat.free_blocks">free_blocks</span>&nbsp;: <code class="type">int</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Number of blocks in the free list.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstat.largest_free">largest_free</span>&nbsp;: <code class="type">int</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Size (in words) of the largest block in the free list.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstat.fragments">fragments</span>&nbsp;: <code class="type">int</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Number of wasted words due to fragmentation.  These are
        1-words free blocks placed between two live blocks.  They
        are not available for allocation.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstat.compactions">compactions</span>&nbsp;: <code class="type">int</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Number of heap compactions since the program was started.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstat.top_heap_words">top_heap_words</span>&nbsp;: <code class="type">int</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Maximum size reached by the major heap, in words.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstat.stack_size">stack_size</span>&nbsp;: <code class="type">int</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Current size of the stack, in words.<br>
<b>Since</b> 3.12.0<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info ">
The memory management counters are returned in a <code class="code">stat</code> record.
<p>

    The total amount of memory allocated by the program since it was started
    is (in words) <code class="code">minor_words + major_words - promoted_words</code>.  Multiply by
    the word size (4 on a 32-bit machine, 8 on a 64-bit machine) to get
    the number of bytes.<br>
</div>


<pre><span id="TYPEcontrol"><span class="keyword">type</span> control<code class="type"></code></span> = <code class="type">Gc.control</code> = {</pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTcontrol.minor_heap_size">minor_heap_size</span>&nbsp;: <code class="type">int</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
The size (in words) of the minor heap.  Changing
        this parameter will trigger a minor collection.  Default: 32k.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTcontrol.major_heap_increment">major_heap_increment</span>&nbsp;: <code class="type">int</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
The minimum number of words to add to the
        major heap when increasing it.  Default: 124k.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTcontrol.space_overhead">space_overhead</span>&nbsp;: <code class="type">int</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
The major GC speed is computed from this parameter.
        This is the memory that will be "wasted" because the GC does not
        immediatly collect unreachable blocks.  It is expressed as a
        percentage of the memory used for live data.
        The GC will work more (use more CPU time and collect
        blocks more eagerly) if <code class="code">space_overhead</code> is smaller.
        Default: 80.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTcontrol.verbose">verbose</span>&nbsp;: <code class="type">int</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
This value controls the GC messages on standard error output.
        It is a sum of some of the following flags, to print messages
        on the corresponding events:<ul>
<li><code class="code">0x001</code> Start of major GC cycle.</li>
<li><code class="code">0x002</code> Minor collection and major GC slice.</li>
<li><code class="code">0x004</code> Growing and shrinking of the heap.</li>
<li><code class="code">0x008</code> Resizing of stacks and memory manager tables.</li>
<li><code class="code">0x010</code> Heap compaction.</li>
<li><code class="code">0x020</code> Change of GC parameters.</li>
<li><code class="code">0x040</code> Computation of major GC slice size.</li>
<li><code class="code">0x080</code> Calling of finalisation functions.</li>
<li><code class="code">0x100</code> Bytecode executable search at start-up.</li>
<li><code class="code">0x200</code> Computation of compaction triggering condition.
        Default: 0.</li>
</ul>
<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTcontrol.max_overhead">max_overhead</span>&nbsp;: <code class="type">int</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Heap compaction is triggered when the estimated amount
        of "wasted" memory is more than <code class="code">max_overhead</code> percent of the
        amount of live data.  If <code class="code">max_overhead</code> is set to 0, heap
        compaction is triggered at the end of each major GC cycle
        (this setting is intended for testing purposes only).
        If <code class="code">max_overhead &gt;= 1000000</code>, compaction is never triggered.
        Default: 500.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTcontrol.stack_limit">stack_limit</span>&nbsp;: <code class="type">int</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
The maximum size of the stack (in words).  This is only
        relevant to the byte-code runtime, as the native code runtime
        uses the operating system's stack.  Default: 256k.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTcontrol.allocation_policy">allocation_policy</span>&nbsp;: <code class="type">int</code>,</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
The policy used for allocating in the heap.  Possible
        values are 0 and 1.  0 is the next-fit policy, which is
        quite fast but can result in fragmentation.  1 is the
        first-fit policy, which can be slower in some cases but
        can be better for programs with fragmentation problems.
        Default: 0.<br>
<b>Since</b> 3.11.0<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info ">
The GC parameters are given as a <code class="code">control</code> record.  Note that
    these parameters can also be initialised by setting the
    OCAMLRUNPARAM environment variable.  See the documentation of
    ocamlrun.<br>
</div>


<pre><span id="VALstat"><span class="keyword">let</span> stat</span> : <code class="type">unit => <a href="BatGc.html#TYPEstat">stat</a></code></pre><div class="info ">
Return the current values of the memory management counters in a
    <code class="code">stat</code> record.  This function examines every heap block to get the
    statistics.<br>
</div>

<pre><span id="VALquick_stat"><span class="keyword">let</span> quick_stat</span> : <code class="type">unit => <a href="BatGc.html#TYPEstat">stat</a></code></pre><div class="info ">
Same as <code class="code">stat</code> except that <code class="code">live_words</code>, <code class="code">live_blocks</code>, <code class="code">free_words</code>,
    <code class="code">free_blocks</code>, <code class="code">largest_free</code>, and <code class="code">fragments</code> are set to 0.  This
    function is much faster than <code class="code">stat</code> because it does not need to go
    through the heap.<br>
</div>

<pre><span id="VALcounters"><span class="keyword">let</span> counters</span> : <code class="type">unit => (float, float, float)</code></pre><div class="info ">
Return <code class="code">(minor_words, promoted_words, major_words)</code>.  This function
    is as fast at <code class="code">quick_stat</code>.<br>
</div>

<pre><span id="VALget"><span class="keyword">let</span> get</span> : <code class="type">unit => <a href="BatGc.html#TYPEcontrol">control</a></code></pre><div class="info ">
Return the current values of the GC parameters in a <code class="code">control</code> record.<br>
</div>

<pre><span id="VALset"><span class="keyword">let</span> set</span> : <code class="type"><a href="BatGc.html#TYPEcontrol">control</a> => unit</code></pre><div class="info ">
<code class="code">set r</code> changes the GC parameters according to the <code class="code">control</code> record <code class="code">r</code>.
    The normal usage is: <code class="code"><span class="constructor">Gc</span>.set { (<span class="constructor">Gc</span>.get()) <span class="keyword">with</span> <span class="constructor">Gc</span>.verbose = 0x00d }</code><br>
</div>

<pre><span id="VALminor"><span class="keyword">let</span> minor</span> : <code class="type">unit => unit</code></pre><div class="info ">
Trigger a minor collection.<br>
</div>

<pre><span id="VALmajor_slice"><span class="keyword">let</span> major_slice</span> : <code class="type">int => int</code></pre><div class="info ">
Do a minor collection and a slice of major collection.  The argument
    is the size of the slice, 0 to use the automatically-computed
    slice size.  In all cases, the result is the computed slice size.<br>
</div>

<pre><span id="VALmajor"><span class="keyword">let</span> major</span> : <code class="type">unit => unit</code></pre><div class="info ">
Do a minor collection and finish the current major collection cycle.<br>
</div>

<pre><span id="VALfull_major"><span class="keyword">let</span> full_major</span> : <code class="type">unit => unit</code></pre><div class="info ">
Do a minor collection, finish the current major collection cycle,
    and perform a complete new cycle.  This will collect all currently
    unreachable blocks.<br>
</div>

<pre><span id="VALcompact"><span class="keyword">let</span> compact</span> : <code class="type">unit => unit</code></pre><div class="info ">
Perform a full major collection and compact the heap.  Note that heap
    compaction is a lengthy operation.<br>
</div>

<pre><span id="VALprint_stat"><span class="keyword">let</span> print_stat</span> : <code class="type"><a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> 'a => unit</code></pre><div class="info ">
Print the current values of the memory management counters (in
    human-readable form) into the channel argument.<br>
</div>

<pre><span id="VALallocated_bytes"><span class="keyword">let</span> allocated_bytes</span> : <code class="type">unit => float</code></pre><div class="info ">
Return the total number of bytes allocated since the program was
    started.  It is returned as a <code class="code">float</code> to avoid overflow problems
    with <code class="code">int</code> on 32-bit machines.<br>
</div>
<br>
Return the current size of the free space inside the minor heap.<br>
<br>
Return the current size of the free space inside the minor heap.<br>
<br>
<code class="code">get_bucket n</code> returns the current size of the <code class="code">n</code>-th future bucket
    of the GC smoothing system. The unit is one millionth of a full GC.
    Raise <code class="code"><span class="constructor">Invalid_argument</span></code> if <code class="code">n</code> is negative, return 0 if n is larger
    than the smoothing window.<br>
<br>
Return the current size of the free space inside the minor heap.<br>
<br>
<code class="code">get_bucket n</code> returns the current size of the <code class="code">n</code>-th future bucket
    of the GC smoothing system. The unit is one millionth of a full GC.
    Raise <code class="code"><span class="constructor">Invalid_argument</span></code> if <code class="code">n</code> is negative, return 0 if n is larger
    than the smoothing window.<br>
<br>
<code class="code">get_credit ()</code> returns the current size of the "work done in advance"
    counter of the GC smoothing system. The unit is one millionth of a
    full GC.<br>
<br>
Return the current size of the free space inside the minor heap.<br>
<br>
<code class="code">get_bucket n</code> returns the current size of the <code class="code">n</code>-th future bucket
    of the GC smoothing system. The unit is one millionth of a full GC.
    Raise <code class="code"><span class="constructor">Invalid_argument</span></code> if <code class="code">n</code> is negative, return 0 if n is larger
    than the smoothing window.<br>
<br>
<code class="code">get_credit ()</code> returns the current size of the "work done in advance"
    counter of the GC smoothing system. The unit is one millionth of a
    full GC.<br>
<br>
Return the number of times we tried to map huge pages and had to fall
    back to small pages. This is always 0 if <code class="code"><span class="constructor">OCAMLRUNPARAM</span></code> contains <code class="code"><span class="constructor">H</span>=1</code>.<br>

<pre><span id="VALfinalise"><span class="keyword">let</span> finalise</span> : <code class="type">('a => unit) => 'a => unit</code></pre><div class="info ">
<code class="code">finalise f v</code> registers <code class="code">f</code> as a finalisation function for <code class="code">v</code>.
    <code class="code">v</code> must be heap-allocated.  <code class="code">f</code> will be called with <code class="code">v</code> as
    argument at some point between the first time <code class="code">v</code> becomes unreachable
    and the time <code class="code">v</code> is collected by the GC.  Several functions can
    be registered for the same value, or even several instances of the
    same function.  Each instance will be called once (or never,
    if the program terminates before <code class="code">v</code> becomes unreachable).
<p>

    The GC will call the finalisation functions in the order of
    deallocation.  When several values become unreachable at the
    same time (i.e. during the same GC cycle), the finalisation
    functions will be called in the reverse order of the corresponding
    calls to <code class="code">finalise</code>.  If <code class="code">finalise</code> is called in the same order
    as the values are allocated, that means each value is finalised
    before the values it depends upon.  Of course, this becomes
    false if additional dependencies are introduced by assignments.
<p>

    Anything reachable from the closure of finalisation functions
    is considered reachable, so the following code will not work
    as expected:<ul>
<li><code class="code"> <span class="keyword">let</span> v = ... <span class="keyword">in</span> <span class="constructor">Gc</span>.finalise (<span class="keyword">fun</span> x <span class="keywordsign">-&gt;</span> ...) v </code></li>
</ul>

    Instead you should write:<ul>
<li><code class="code"> <span class="keyword">let</span> f = <span class="keyword">fun</span> x <span class="keywordsign">-&gt;</span> ... ;; <span class="keyword">let</span> v = ... <span class="keyword">in</span> <span class="constructor">Gc</span>.finalise f v </code></li>
</ul>

    The <code class="code">f</code> function can use all features of OCaml, including
    assignments that make the value reachable again.  It can also
    loop forever (in this case, the other
    finalisation functions will not be called during the execution of f,
    unless it calls <code class="code">finalise_release</code>).
    It can call <code class="code">finalise</code> on <code class="code">v</code> or other values to register other
    functions or even itself.  It can raise an exception; in this case
    the exception will interrupt whatever the program was doing when
    the function was called.
<p>

    <code class="code">finalise</code> will raise <code class="code"><span class="constructor">Invalid_argument</span></code> if <code class="code">v</code> is not
    heap-allocated.  Some examples of values that are not
    heap-allocated are integers, constant constructors, booleans,
    the empty array, the empty list, the unit value.  The exact list
    of what is heap-allocated or not is implementation-dependent.
    Some constant values can be heap-allocated but never deallocated
    during the lifetime of the program, for example a list of integer
    constants; this is also implementation-dependent.
    You should also be aware that compiler optimisations may duplicate
    some immutable values, for example floating-point numbers when
    stored into arrays, so they can be finalised and collected while
    another copy is still in use by the program.
<p>

    The results of calling <code class="code"><span class="constructor">String</span>.make</code>, <code class="code"><span class="constructor">String</span>.create</code>,
    <code class="code"><span class="constructor">Array</span>.make</code>, and <code class="code"><span class="constructor">Pervasives</span>.ref</code> are guaranteed to be
    heap-allocated and non-constant except when the length argument is <code class="code">0</code>.<br>
</div>

<pre><span id="VALfinalise_release"><span class="keyword">let</span> finalise_release</span> : <code class="type">unit => unit</code></pre><div class="info ">
A finalisation function may call <code class="code">finalise_release</code> to tell the
    GC that it can launch the next finalisation function without waiting
    for the current one to return.<br>
</div>

<pre><span id="TYPEalarm"><span class="keyword">type</span> alarm<code class="type"></code></span> = <code class="type">Gc.alarm</code> </pre>
<div class="info ">
An alarm is a piece of data that calls a user function at the end of
    each major GC cycle.  The following functions are provided to create
    and delete alarms.<br>
</div>


<pre><span id="VALcreate_alarm"><span class="keyword">let</span> create_alarm</span> : <code class="type">(unit => unit) => <a href="BatGc.html#TYPEalarm">alarm</a></code></pre><div class="info ">
<code class="code">create_alarm f</code> will arrange for <code class="code">f</code> to be called at the end of each
    major GC cycle, starting with the current cycle or the next one.
    A value of type <code class="code">alarm</code> is returned that you can
    use to call <code class="code">delete_alarm</code>.<br>
</div>

<pre><span id="VALdelete_alarm"><span class="keyword">let</span> delete_alarm</span> : <code class="type"><a href="BatGc.html#TYPEalarm">alarm</a> => unit</code></pre><div class="info ">
<code class="code">delete_alarm a</code> will stop the calls to the function associated
      to <code class="code">a</code>.  Calling <code class="code">delete_alarm a</code> again has no effect.<br>
</div>
</body></html>