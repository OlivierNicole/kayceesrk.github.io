<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Batteries.Oo.html">
<link rel="next" href="Batteries.Printf.html">
<link rel="Up" href="Batteries.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="BatArray" rel="Chapter" href="BatArray.html">
<link title="BatAvlTree" rel="Chapter" href="BatAvlTree.html">
<link title="BatBase64" rel="Chapter" href="BatBase64.html">
<link title="BatBig_int" rel="Chapter" href="BatBig_int.html">
<link title="BatBigarray" rel="Chapter" href="BatBigarray.html">
<link title="BatBitSet" rel="Chapter" href="BatBitSet.html">
<link title="BatBool" rel="Chapter" href="BatBool.html">
<link title="BatBounded" rel="Chapter" href="BatBounded.html">
<link title="BatBuffer" rel="Chapter" href="BatBuffer.html">
<link title="BatBytes" rel="Chapter" href="BatBytes.html">
<link title="BatCache" rel="Chapter" href="BatCache.html">
<link title="BatChar" rel="Chapter" href="BatChar.html">
<link title="BatCharParser" rel="Chapter" href="BatCharParser.html">
<link title="BatComplex" rel="Chapter" href="BatComplex.html">
<link title="BatConcurrent" rel="Chapter" href="BatConcurrent.html">
<link title="BatDeque" rel="Chapter" href="BatDeque.html">
<link title="BatDigest" rel="Chapter" href="BatDigest.html">
<link title="BatDllist" rel="Chapter" href="BatDllist.html">
<link title="BatDynArray" rel="Chapter" href="BatDynArray.html">
<link title="BatEnum" rel="Chapter" href="BatEnum.html">
<link title="BatFile" rel="Chapter" href="BatFile.html">
<link title="BatFingerTree" rel="Chapter" href="BatFingerTree.html">
<link title="BatFloat" rel="Chapter" href="BatFloat.html">
<link title="BatFormat" rel="Chapter" href="BatFormat.html">
<link title="BatGc" rel="Chapter" href="BatGc.html">
<link title="BatGenlex" rel="Chapter" href="BatGenlex.html">
<link title="BatGlobal" rel="Chapter" href="BatGlobal.html">
<link title="BatHashcons" rel="Chapter" href="BatHashcons.html">
<link title="BatHashtbl" rel="Chapter" href="BatHashtbl.html">
<link title="BatHeap" rel="Chapter" href="BatHeap.html">
<link title="BatIMap" rel="Chapter" href="BatIMap.html">
<link title="BatIO" rel="Chapter" href="BatIO.html">
<link title="BatISet" rel="Chapter" href="BatISet.html">
<link title="BatInnerIO" rel="Chapter" href="BatInnerIO.html">
<link title="BatInnerPervasives" rel="Chapter" href="BatInnerPervasives.html">
<link title="BatInnerWeaktbl" rel="Chapter" href="BatInnerWeaktbl.html">
<link title="BatInt" rel="Chapter" href="BatInt.html">
<link title="BatInt32" rel="Chapter" href="BatInt32.html">
<link title="BatInt64" rel="Chapter" href="BatInt64.html">
<link title="BatInterfaces" rel="Chapter" href="BatInterfaces.html">
<link title="BatLazyList" rel="Chapter" href="BatLazyList.html">
<link title="BatLexing" rel="Chapter" href="BatLexing.html">
<link title="BatList" rel="Chapter" href="BatList.html">
<link title="BatLog" rel="Chapter" href="BatLog.html">
<link title="BatLogger" rel="Chapter" href="BatLogger.html">
<link title="BatMap" rel="Chapter" href="BatMap.html">
<link title="BatMarshal" rel="Chapter" href="BatMarshal.html">
<link title="BatMultiMap" rel="Chapter" href="BatMultiMap.html">
<link title="BatMultiPMap" rel="Chapter" href="BatMultiPMap.html">
<link title="BatMutex" rel="Chapter" href="BatMutex.html">
<link title="BatNativeint" rel="Chapter" href="BatNativeint.html">
<link title="BatNum" rel="Chapter" href="BatNum.html">
<link title="BatNumber" rel="Chapter" href="BatNumber.html">
<link title="BatOo" rel="Chapter" href="BatOo.html">
<link title="BatOptParse" rel="Chapter" href="BatOptParse.html">
<link title="BatOption" rel="Chapter" href="BatOption.html">
<link title="BatOrd" rel="Chapter" href="BatOrd.html">
<link title="BatParserCo" rel="Chapter" href="BatParserCo.html">
<link title="BatPathGen" rel="Chapter" href="BatPathGen.html">
<link title="BatPervasives" rel="Chapter" href="BatPervasives.html">
<link title="BatPrintexc" rel="Chapter" href="BatPrintexc.html">
<link title="BatPrintf" rel="Chapter" href="BatPrintf.html">
<link title="BatQueue" rel="Chapter" href="BatQueue.html">
<link title="BatRMutex" rel="Chapter" href="BatRMutex.html">
<link title="BatRandom" rel="Chapter" href="BatRandom.html">
<link title="BatRef" rel="Chapter" href="BatRef.html">
<link title="BatRefList" rel="Chapter" href="BatRefList.html">
<link title="BatResult" rel="Chapter" href="BatResult.html">
<link title="BatReturn" rel="Chapter" href="BatReturn.html">
<link title="BatScanf" rel="Chapter" href="BatScanf.html">
<link title="BatSeq" rel="Chapter" href="BatSeq.html">
<link title="BatSet" rel="Chapter" href="BatSet.html">
<link title="BatSplay" rel="Chapter" href="BatSplay.html">
<link title="BatStack" rel="Chapter" href="BatStack.html">
<link title="BatStream" rel="Chapter" href="BatStream.html">
<link title="BatString" rel="Chapter" href="BatString.html">
<link title="BatSubstring" rel="Chapter" href="BatSubstring.html">
<link title="BatSys" rel="Chapter" href="BatSys.html">
<link title="BatText" rel="Chapter" href="BatText.html">
<link title="BatTuple" rel="Chapter" href="BatTuple.html">
<link title="BatUChar" rel="Chapter" href="BatUChar.html">
<link title="BatUTF8" rel="Chapter" href="BatUTF8.html">
<link title="BatUnit" rel="Chapter" href="BatUnit.html">
<link title="BatUnix" rel="Chapter" href="BatUnix.html">
<link title="BatUref" rel="Chapter" href="BatUref.html">
<link title="BatVect" rel="Chapter" href="BatVect.html">
<link title="Batteries" rel="Chapter" href="Batteries.html">
<link title="BatteriesConfig" rel="Chapter" href="BatteriesConfig.html">
<link title="BatteriesExceptionless" rel="Chapter" href="BatteriesExceptionless.html">
<link title="BatteriesPrint" rel="Chapter" href="BatteriesPrint.html">
<link title="BatteriesThread" rel="Chapter" href="BatteriesThread.html">
<link title="Extlib" rel="Chapter" href="Extlib.html"><link title="Raw backtraces" rel="Section" href="#6_Rawbacktraces">
<link title="Current call stack" rel="Section" href="#6_Currentcallstack">
<link title="Uncaught exceptions" rel="Section" href="#6_Uncaughtexceptions">
<link title="Manipulation of backtrace information" rel="Section" href="#6_Manipulationofbacktraceinformation">
<link title="Raw backtrace slots" rel="Section" href="#6_Rawbacktraceslots">
<link title="Exception slots" rel="Section" href="#6_Exceptionslots">
<title>Batteries user guide : Batteries.Printexc</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Batteries.Oo.html" title="Batteries.Oo">Previous</a>
&nbsp;<a class="up" href="Batteries.html" title="Batteries">Up</a>
&nbsp;<a class="post" href="Batteries.Printf.html" title="Batteries.Printf">Next</a>
</div>
<h1>Module <a href="type_Batteries.Printexc.html">Batteries.Printexc</a></h1>

<pre><span class="keyword">module</span> Printexc: <code class="type"><a href="BatPrintexc.html">BatPrintexc</a></code></pre><hr width="100%">

<pre><span id="VALpass"><span class="keyword">let</span> pass</span> : <code class="type">('a => 'b) => 'a => 'b</code></pre><div class="info ">
<code class="code"><span class="constructor">Printexc</span>.pass fn x</code> applies <code class="code">fn</code> to <code class="code">x</code> and returns the result.
    If the evaluation of <code class="code">fn x</code> raises any exception, the name of the
    exception is printed on standard error output, and the exception
    is raised again.  The typical use is to catch and report
    exceptions that escape a function application. This function is a
    renamed version of <code class="code"><span class="constructor">Printexc</span>.print</code> from stdlib.<br>
</div>

<pre><span id="VALcatch"><span class="keyword">let</span> catch</span> : <code class="type">('a => 'b) => 'a => 'b</code></pre><div class="info ">
<code class="code"><span class="constructor">Printexc</span>.catch fn x</code> is similar to <code class="code"><span class="constructor">Printexc</span>.print</code>, but aborts
    the program with exit code 2 after printing the uncaught exception.
    This function is deprecated: the runtime system is now able to
    print uncaught exceptions as precisely as <code class="code"><span class="constructor">Printexc</span>.catch</code> does.
    Moreover, calling <code class="code"><span class="constructor">Printexc</span>.catch</code> makes it harder to track the
    location of the exception using the debugger or the stack backtrace
    facility.  So, do not use <code class="code"><span class="constructor">Printexc</span>.catch</code> in new code.<br>
</div>

<pre><span id="VALto_string"><span class="keyword">let</span> to_string</span> : <code class="type">exn => string</code></pre><div class="info ">
<code class="code"><span class="constructor">Printexc</span>.to_string e</code> returns a string representation of the
    exception <code class="code">e</code>.<br>
</div>

<pre><span id="VALprint_backtrace"><span class="keyword">let</span> print_backtrace</span> : <code class="type"><a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> 'a => unit</code></pre><div class="info ">
<code class="code">print_backtrace oc</code> Prints the an exception backtrace on the
    output channel <code class="code">oc</code>.  The backtrace lists the program locations
    where the most-recently raised exception was raised and where it
    was propagated through function calls.<br>
<b>Since</b> 1.4.0<br>
</div>

<pre><span id="VALget_backtrace"><span class="keyword">let</span> get_backtrace</span> : <code class="type">unit => string</code></pre><div class="info ">
<code class="code"><span class="constructor">Printexc</span>.get_backtrace ()</code> returns a string containing the same
    exception backtrace that <code class="code"><span class="constructor">Printexc</span>.print_backtrace</code> would print.<br>
</div>

<pre><span id="VALrecord_backtrace"><span class="keyword">let</span> record_backtrace</span> : <code class="type">bool => unit</code></pre><div class="info ">
<code class="code"><span class="constructor">Printexc</span>.record_backtrace b</code> turns recording of exception
    backtraces on (if <code class="code">b = <span class="keyword">true</span></code>) or off (if <code class="code">b = <span class="keyword">false</span></code>).  Initially,
    backtraces are not recorded, unless the <code class="code">b</code> flag is given to the
    program through the <code class="code"><span class="constructor">OCAMLRUNPARAM</span></code> variable.<br>
</div>

<pre><span id="VALbacktrace_status"><span class="keyword">let</span> backtrace_status</span> : <code class="type">unit => bool</code></pre><div class="info ">
<code class="code"><span class="constructor">Printexc</span>.backtrace_status()</code> returns <code class="code"><span class="keyword">true</span></code> if exception
    backtraces are currently recorded, <code class="code"><span class="keyword">false</span></code> if not.<br>
</div>

<pre><span id="VALregister_printer"><span class="keyword">let</span> register_printer</span> : <code class="type">(exn => option string) => unit</code></pre><div class="info ">
<code class="code"><span class="constructor">Printexc</span>.register_printer fn</code> registers <code class="code">fn</code> as an exception
    printer.  The printer should return <code class="code"><span class="constructor">None</span></code> or raise an exception
    if it does not know how to convert the passed exception, and <code class="code"><span class="constructor">Some</span>
    s</code> with <code class="code">s</code> the resulting string if it can convert the passed
    exception. Exceptions raised by the printer are ignored.
<p>

    When converting an exception into a string, the printers will be invoked
    in the reverse order of their registrations, until a printer returns
    a <code class="code"><span class="constructor">Some</span> s</code> value (if no such printer exists, the runtime will use a
    generic printer).<br>
</div>

<pre><span id="VALprint"><span class="keyword">let</span> print</span> : <code class="type"><a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> 'a => exn => unit</code></pre><div class="info ">
Print an exception.  The stdlib <code class="code">print</code> function is now named <code class="code">!pass</code>.<br>
</div>
<br>
<h6 id="6_Rawbacktraces">Raw backtraces</h6><br>

<pre><span id="TYPEraw_backtrace"><span class="keyword">type</span> raw_backtrace<code class="type"></code></span> = <code class="type">Printexc.raw_backtrace</code> </pre>
<div class="info ">
The abstract type <code class="code">raw_backtrace</code> stores a backtrace in
    a low-level format, instead of directly exposing them as string as
    the <code class="code">get_backtrace()</code> function does.
<p>

    This allows delaying the formatting of backtraces to when they are
    actually printed, which may be useful if you record more
    backtraces than you print.
<p>

    Raw backtraces cannot be marshalled. If you need marshalling, you
    should use the array returned by the <code class="code">backtrace_slots</code> function of
    the next section.<br>
<b>Since</b> 2.2.0 and OCaml 4.01.0<br>
</div>


<pre><span id="VALget_raw_backtrace"><span class="keyword">let</span> get_raw_backtrace</span> : <code class="type">unit => <a href="BatPrintexc.html#TYPEraw_backtrace">raw_backtrace</a></code></pre><div class="info ">
<code class="code"><span class="constructor">Printexc</span>.get_raw_backtrace ()</code> returns the same exception
    backtrace that <code class="code"><span class="constructor">Printexc</span>.print_backtrace</code> would print, but in
    a raw format.<br>
<b>Since</b> 2.2.0 and OCaml 4.01.0<br>
</div>

<pre><span id="VALprint_raw_backtrace"><span class="keyword">let</span> print_raw_backtrace</span> : <code class="type">Pervasives.out_channel => <a href="BatPrintexc.html#TYPEraw_backtrace">raw_backtrace</a> => unit</code></pre><div class="info ">
Print a raw backtrace in the same format
    <code class="code"><span class="constructor">Printexc</span>.print_backtrace</code> uses.<br>
<b>Since</b> 2.2.0 and OCaml 4.01.0<br>
</div>

<pre><span id="VALraw_backtrace_to_string"><span class="keyword">let</span> raw_backtrace_to_string</span> : <code class="type"><a href="BatPrintexc.html#TYPEraw_backtrace">raw_backtrace</a> => string</code></pre><div class="info ">
Return a string from a raw backtrace, in the same format
    <code class="code"><span class="constructor">Printexc</span>.get_backtrace</code> uses.<br>
<b>Since</b> 2.2.0 and OCaml 4.01.0<br>
</div>
<br>
<h6 id="6_Currentcallstack">Current call stack</h6><br>

<pre><span id="VALget_callstack"><span class="keyword">let</span> get_callstack</span> : <code class="type">int => <a href="BatPrintexc.html#TYPEraw_backtrace">raw_backtrace</a></code></pre><div class="info ">
<code class="code"><span class="constructor">Printexc</span>.get_callstack n</code> returns a description of the top of the
    call stack on the current program point (for the current thread),
    with at most <code class="code">n</code> entries.  (Note: this function is not related to
    exceptions at all, despite being part of the <code class="code"><span class="constructor">Printexc</span></code> module.)<br>
<b>Since</b> 2.2.0 and OCaml 4.01.0<br>
</div>
<br>
<h6 id="6_Uncaughtexceptions">Uncaught exceptions</h6><br>

<pre><span id="VALset_uncaught_exception_handler"><span class="keyword">let</span> set_uncaught_exception_handler</span> : <code class="type">(exn => <a href="BatPrintexc.html#TYPEraw_backtrace">raw_backtrace</a> => unit) => unit</code></pre><div class="info ">
<code class="code"><span class="constructor">Printexc</span>.set_uncaught_exception_handler fn</code> registers <code class="code">fn</code> as the handler
    for uncaught exceptions. The default handler prints the exception and
    backtrace on standard error output.
<p>

    Note that when <code class="code">fn</code> is called all the functions registered with
    <code class="code"><span class="constructor">Pervasives</span>.at_exit</code> have already been called. Because of this you must
    make sure any output channel <code class="code">fn</code> writes on is flushed.
<p>

    If <code class="code">fn</code> raises an exception, it is ignored.<br>
<b>Since</b> 2.3.0 and OCaml 4.02.0<br>
</div>
<br>
<h6 id="6_Manipulationofbacktraceinformation">Manipulation of backtrace information</h6>
<p>

    Those function allow to traverse the slots of a raw backtrace,
    extract information from them in a programmer-friendly format.<br>

<pre><span id="TYPEbacktrace_slot"><span class="keyword">type</span> backtrace_slot<code class="type"></code></span> = <code class="type">Printexc.backtrace_slot</code> </pre>
<div class="info ">
The abstract type <code class="code">backtrace_slot</code> represents a single slot of
    a backtrace.<br>
<b>Since</b> 2.3.0 and OCaml 4.02<br>
</div>


<pre><span id="VALbacktrace_slots"><span class="keyword">let</span> backtrace_slots</span> : <code class="type"><a href="BatPrintexc.html#TYPEraw_backtrace">raw_backtrace</a> => option (array <a href="BatPrintexc.html#TYPEbacktrace_slot">backtrace_slot</a>)</code></pre><div class="info ">
Returns the slots of a raw backtrace, or <code class="code"><span class="constructor">None</span></code> if none of them
    contain useful information.
<p>

    In the return array, the slot at index <code class="code">0</code> corresponds to the most
    recent function call, raise, or primitive <code class="code">get_backtrace</code> call in
    the trace.
<p>

    Some possible reasons for returning <code class="code"><span class="constructor">None</span></code> are as follow:<ul>
<li>none of the slots in the trace come from modules compiled with
    debug information (<code class="code">-g</code>)</li>
<li>the program is a bytecode program that has not been linked with
    debug information enabled (<code class="code">ocamlc -g</code>)</li>
</ul>
<br>
<b>Since</b> 2.3.0 and OCaml 4.02.0<br>
</div>

<pre><span id="TYPElocation"><span class="keyword">type</span> location<code class="type"></code></span> = <code class="type">Printexc.location</code> = {</pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlocation.filename">filename</span>&nbsp;: <code class="type">string</code>,</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlocation.line_number">line_number</span>&nbsp;: <code class="type">int</code>,</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlocation.start_char">start_char</span>&nbsp;: <code class="type">int</code>,</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlocation.end_char">end_char</span>&nbsp;: <code class="type">int</code>,</code></td>

</tr></table>
}

<div class="info ">
The type of location information found in backtraces. <code class="code">start_char</code>
    and <code class="code">end_char</code> are positions relative to the beginning of the
    line.<br>
<b>Since</b> 2.3.0 and OCaml 4.02<br>
</div>


<pre><span class="keyword">module</span> <a href="BatPrintexc.Slot.html">Slot</a>: <code class="code">{</code> <a href="BatPrintexc.Slot.html">..</a> <code class="code">}</code></pre><br>
<h6 id="6_Rawbacktraceslots">Raw backtrace slots</h6><br>

<pre><span id="TYPEraw_backtrace_slot"><span class="keyword">type</span> raw_backtrace_slot<code class="type"></code></span> = <code class="type">Printexc.raw_backtrace_slot</code> </pre>
<div class="info ">
This type allows direct access to raw backtrace slots, without any
    conversion in an OCaml-usable data-structure. Being
    process-specific, they must absolutely not be marshalled, and are
    unsafe to use for this reason (marshalling them may not fail, but
    un-marshalling and using the result will result in
    undefined behavior).
<p>

    Elements of this type can still be compared and hashed: when two
    elements are equal, then they represent the same source location
    (the converse is not necessarily true in presence of inlining,
    for example).<br>
</div>


<pre><span id="VALraw_backtrace_length"><span class="keyword">let</span> raw_backtrace_length</span> : <code class="type"><a href="BatPrintexc.html#TYPEraw_backtrace">raw_backtrace</a> => int</code></pre><div class="info ">
<code class="code">raw_backtrace_length bckt</code> returns the number of slots in the
    backtrace <code class="code">bckt</code>.<br>
<b>Since</b> 2.3.0 and OCaml 4.02<br>
</div>

<pre><span id="VALget_raw_backtrace_slot"><span class="keyword">let</span> get_raw_backtrace_slot</span> : <code class="type"><a href="BatPrintexc.html#TYPEraw_backtrace">raw_backtrace</a> => int => <a href="BatPrintexc.html#TYPEraw_backtrace_slot">raw_backtrace_slot</a></code></pre><div class="info ">
<code class="code">get_slot bckt pos</code> returns the slot in position <code class="code">pos</code> in the
    backtrace <code class="code">bckt</code>.<br>
<b>Since</b> 2.3.0 and OCaml 4.02<br>
</div>

<pre><span id="VALconvert_raw_backtrace_slot"><span class="keyword">let</span> convert_raw_backtrace_slot</span> : <code class="type"><a href="BatPrintexc.html#TYPEraw_backtrace_slot">raw_backtrace_slot</a> => <a href="BatPrintexc.html#TYPEbacktrace_slot">backtrace_slot</a></code></pre><div class="info ">
Extracts the user-friendly <code class="code">backtrace_slot</code> from a low-level
    <code class="code">raw_backtrace_slot</code>.<br>
<b>Since</b> 2.3.0 and OCaml 4.02<br>
</div>
<br>
<h6 id="6_Exceptionslots">Exception slots</h6><br>

<pre><span id="VALexn_slot_id"><span class="keyword">let</span> exn_slot_id</span> : <code class="type">exn => int</code></pre><div class="info ">
<code class="code"><span class="constructor">Printexc</span>.exn_slot_id</code> returns an integer which uniquely identifies
    the constructor used to create the exception value <code class="code">exn</code>
    (in the current runtime).<br>
<b>Since</b> 2.3.0 and OCaml 4.02.0<br>
</div>

<pre><span id="VALexn_slot_name"><span class="keyword">let</span> exn_slot_name</span> : <code class="type">exn => string</code></pre><div class="info ">
<code class="code"><span class="constructor">Printexc</span>.exn_slot_id exn</code> returns the internal name of the constructor
    used to create the exception value <code class="code">exn</code>.<br>
<b>Since</b> 2.3.0 and OCaml 4.02.0<br>
</div>
</body></html>