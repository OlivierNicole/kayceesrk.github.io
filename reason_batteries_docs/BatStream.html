<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="BatStack.html">
<link rel="next" href="BatString.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="BatArray" rel="Chapter" href="BatArray.html">
<link title="BatAvlTree" rel="Chapter" href="BatAvlTree.html">
<link title="BatBase64" rel="Chapter" href="BatBase64.html">
<link title="BatBig_int" rel="Chapter" href="BatBig_int.html">
<link title="BatBigarray" rel="Chapter" href="BatBigarray.html">
<link title="BatBitSet" rel="Chapter" href="BatBitSet.html">
<link title="BatBool" rel="Chapter" href="BatBool.html">
<link title="BatBounded" rel="Chapter" href="BatBounded.html">
<link title="BatBuffer" rel="Chapter" href="BatBuffer.html">
<link title="BatBytes" rel="Chapter" href="BatBytes.html">
<link title="BatCache" rel="Chapter" href="BatCache.html">
<link title="BatChar" rel="Chapter" href="BatChar.html">
<link title="BatCharParser" rel="Chapter" href="BatCharParser.html">
<link title="BatComplex" rel="Chapter" href="BatComplex.html">
<link title="BatConcurrent" rel="Chapter" href="BatConcurrent.html">
<link title="BatDeque" rel="Chapter" href="BatDeque.html">
<link title="BatDigest" rel="Chapter" href="BatDigest.html">
<link title="BatDllist" rel="Chapter" href="BatDllist.html">
<link title="BatDynArray" rel="Chapter" href="BatDynArray.html">
<link title="BatEnum" rel="Chapter" href="BatEnum.html">
<link title="BatFile" rel="Chapter" href="BatFile.html">
<link title="BatFingerTree" rel="Chapter" href="BatFingerTree.html">
<link title="BatFloat" rel="Chapter" href="BatFloat.html">
<link title="BatFormat" rel="Chapter" href="BatFormat.html">
<link title="BatGc" rel="Chapter" href="BatGc.html">
<link title="BatGenlex" rel="Chapter" href="BatGenlex.html">
<link title="BatGlobal" rel="Chapter" href="BatGlobal.html">
<link title="BatHashcons" rel="Chapter" href="BatHashcons.html">
<link title="BatHashtbl" rel="Chapter" href="BatHashtbl.html">
<link title="BatHeap" rel="Chapter" href="BatHeap.html">
<link title="BatIMap" rel="Chapter" href="BatIMap.html">
<link title="BatIO" rel="Chapter" href="BatIO.html">
<link title="BatISet" rel="Chapter" href="BatISet.html">
<link title="BatInnerIO" rel="Chapter" href="BatInnerIO.html">
<link title="BatInnerPervasives" rel="Chapter" href="BatInnerPervasives.html">
<link title="BatInnerWeaktbl" rel="Chapter" href="BatInnerWeaktbl.html">
<link title="BatInt" rel="Chapter" href="BatInt.html">
<link title="BatInt32" rel="Chapter" href="BatInt32.html">
<link title="BatInt64" rel="Chapter" href="BatInt64.html">
<link title="BatInterfaces" rel="Chapter" href="BatInterfaces.html">
<link title="BatLazyList" rel="Chapter" href="BatLazyList.html">
<link title="BatLexing" rel="Chapter" href="BatLexing.html">
<link title="BatList" rel="Chapter" href="BatList.html">
<link title="BatLog" rel="Chapter" href="BatLog.html">
<link title="BatLogger" rel="Chapter" href="BatLogger.html">
<link title="BatMap" rel="Chapter" href="BatMap.html">
<link title="BatMarshal" rel="Chapter" href="BatMarshal.html">
<link title="BatMultiMap" rel="Chapter" href="BatMultiMap.html">
<link title="BatMultiPMap" rel="Chapter" href="BatMultiPMap.html">
<link title="BatMutex" rel="Chapter" href="BatMutex.html">
<link title="BatNativeint" rel="Chapter" href="BatNativeint.html">
<link title="BatNum" rel="Chapter" href="BatNum.html">
<link title="BatNumber" rel="Chapter" href="BatNumber.html">
<link title="BatOo" rel="Chapter" href="BatOo.html">
<link title="BatOptParse" rel="Chapter" href="BatOptParse.html">
<link title="BatOption" rel="Chapter" href="BatOption.html">
<link title="BatOrd" rel="Chapter" href="BatOrd.html">
<link title="BatParserCo" rel="Chapter" href="BatParserCo.html">
<link title="BatPathGen" rel="Chapter" href="BatPathGen.html">
<link title="BatPervasives" rel="Chapter" href="BatPervasives.html">
<link title="BatPrintexc" rel="Chapter" href="BatPrintexc.html">
<link title="BatPrintf" rel="Chapter" href="BatPrintf.html">
<link title="BatQueue" rel="Chapter" href="BatQueue.html">
<link title="BatRMutex" rel="Chapter" href="BatRMutex.html">
<link title="BatRandom" rel="Chapter" href="BatRandom.html">
<link title="BatRef" rel="Chapter" href="BatRef.html">
<link title="BatRefList" rel="Chapter" href="BatRefList.html">
<link title="BatResult" rel="Chapter" href="BatResult.html">
<link title="BatReturn" rel="Chapter" href="BatReturn.html">
<link title="BatScanf" rel="Chapter" href="BatScanf.html">
<link title="BatSeq" rel="Chapter" href="BatSeq.html">
<link title="BatSet" rel="Chapter" href="BatSet.html">
<link title="BatSplay" rel="Chapter" href="BatSplay.html">
<link title="BatStack" rel="Chapter" href="BatStack.html">
<link title="BatStream" rel="Chapter" href="BatStream.html">
<link title="BatString" rel="Chapter" href="BatString.html">
<link title="BatSubstring" rel="Chapter" href="BatSubstring.html">
<link title="BatSys" rel="Chapter" href="BatSys.html">
<link title="BatText" rel="Chapter" href="BatText.html">
<link title="BatTuple" rel="Chapter" href="BatTuple.html">
<link title="BatUChar" rel="Chapter" href="BatUChar.html">
<link title="BatUTF8" rel="Chapter" href="BatUTF8.html">
<link title="BatUnit" rel="Chapter" href="BatUnit.html">
<link title="BatUnix" rel="Chapter" href="BatUnix.html">
<link title="BatUref" rel="Chapter" href="BatUref.html">
<link title="BatVect" rel="Chapter" href="BatVect.html">
<link title="Batteries" rel="Chapter" href="Batteries.html">
<link title="BatteriesConfig" rel="Chapter" href="BatteriesConfig.html">
<link title="BatteriesExceptionless" rel="Chapter" href="BatteriesExceptionless.html">
<link title="BatteriesPrint" rel="Chapter" href="BatteriesPrint.html">
<link title="BatteriesThread" rel="Chapter" href="BatteriesThread.html">
<link title="Extlib" rel="Chapter" href="Extlib.html"><link title="Stream builders" rel="Section" href="#6_Streambuilders">
<link title="Other Stream builders" rel="Section" href="#6_OtherStreambuilders">
<link title="Stream iterator" rel="Section" href="#6_Streamiterator">
<link title="Predefined parsers" rel="Section" href="#6_Predefinedparsers">
<link title="Useful functions" rel="Section" href="#6_Usefulfunctions">
<link title="Conversion functions" rel="Section" href="#6_Conversionfunctions">
<link title="Stream consumers" rel="Section" href="#6_Streamconsumers">
<link title="Computation over stream" rel="Section" href="#6_Computationoverstream">
<link title="Streams pair arithmetic" rel="Section" href="#6_Streamspairarithmetic">
<link title="Stream arithmetic" rel="Section" href="#6_Streamarithmetic">
<link title="Predefined parsers" rel="Section" href="#6_Predefinedparsers">
<title>Batteries user guide : BatStream</title>
</head>
<body>
<div class="navbar"><a class="pre" href="BatStack.html" title="BatStack">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="BatString.html" title="BatString">Next</a>
</div>
<h1>Module <a href="type_BatStream.html">BatStream</a></h1>

<pre><span class="keyword">module</span> BatStream: <code class="code">{</code> <a href="BatStream.html">..</a> <code class="code">}</code></pre><div class="info module top">
Streams and stream parsers
<p>

   Streams are a read-and-forget data structure, comparable to enumerations.
   In Batteries Included, streams are deprecated in favor of enumerations,
   defined in module <a href="BatEnum.html"><code class="code"><span class="constructor">BatEnum</span></code></a>.
<p>

   <b>Note</b> This module is provided essentially for backwards-compatibility.
   If you feel like using <code class="code"><span class="constructor">Stream</span>.t</code>, please take a look at <code class="code"><span class="constructor">BatEnum</span></code>
   or <code class="code"><span class="constructor">LazyList</span></code>.
<p>

   This module is based on <a href="http://www.pps.jussieu.fr/~li/software/sdflow/">Zheng Li's SDFlow</a>
<p>

   This module replaces Stdlib's
   <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Stream.html">Stream</a>
   module.<br>
<b>Author(s):</b> Zheng Li (SDFlow), David Teller<br>
</div>
<hr width="100%">

<pre><span id="TYPEt"><span class="keyword">type</span> t <code class="type">'a</code></span> = <code class="type">Stream.t 'a</code> </pre>


<pre><span class="keyword">include</span> <a href="BatEnum.Enumerable.html">BatEnum.Enumerable</a></pre>

<pre><span class="keyword">include</span> <a href="BatInterfaces.Mappable.html">BatInterfaces.Mappable</a></pre>
<br>
The type of streams holding values of type <code class="code"><span class="keywordsign">'</span>a</code>.<br>

<pre><span id="EXCEPTIONFailure"><span class="keyword">exception</span> Failure</span></pre>
<div class="info ">
Raised by parsers when none of the first components of the stream
    patterns is accepted.<br>
</div>

<pre><span id="EXCEPTIONError"><span class="keyword">exception</span> Error</span> <span class="keyword">of</span> <code class="type">string</code></pre>
<div class="info ">
Raised by parsers when the first component of a stream pattern is
    accepted, but one of the following components is rejected.<br>
</div>
<br>
<h6 id="6_Streambuilders">Stream builders</h6><br>

<pre><span id="VALfrom"><span class="keyword">let</span> from</span> : <code class="type">(int => option 'a) => <a href="BatStream.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code"><span class="constructor">Stream</span>.from f</code> returns a stream built from the function <code class="code">f</code>.
    To create a new stream element, the function <code class="code">f</code> is called with
    the current stream count. The user function <code class="code">f</code> must return either
    <code class="code"><span class="constructor">Some</span> &lt;value&gt;</code> for a value or <code class="code"><span class="constructor">None</span></code> to specify the end of the
    stream.<br>
</div>

<pre><span id="VALof_list"><span class="keyword">let</span> of_list</span> : <code class="type">list 'a => <a href="BatStream.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Return the stream holding the elements of the list in the same
    order.<br>
</div>

<pre><span id="VALof_string"><span class="keyword">let</span> of_string</span> : <code class="type">string => <a href="BatStream.html#TYPEt">t</a> char</code></pre><div class="info ">
Return the stream of the characters of the string parameter.<br>
</div>

<pre><span id="VALof_bytes"><span class="keyword">let</span> of_bytes</span> : <code class="type">Bytes.t => <a href="BatStream.html#TYPEt">t</a> char</code></pre><div class="info ">
Return the stream of the characters of the bytes parameter.<br>
<b>Since</b> 2.3.0<br>
</div>

<pre><span id="VALof_channel"><span class="keyword">let</span> of_channel</span> : <code class="type">Pervasives.in_channel => <a href="BatStream.html#TYPEt">t</a> char</code></pre><div class="info ">
Return the stream of the characters read from the input channel.<br>
</div>
<br>
<h6 id="6_OtherStreambuilders">Other Stream builders</h6>
<p>

    Warning: these functions create streams with fast access; it is illegal
    to mix them with streams built with <code class="code">[&lt; &gt;]</code>; would raise <code class="code"><span class="constructor">Failure</span></code>
    when accessing such mixed streams.<br>

<pre><span id="VALof_fun"><span class="keyword">let</span> of_fun</span> : <code class="type">(unit => 'a) => <a href="BatStream.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code"><span class="constructor">Stream</span>.of_fun f</code> returns a stream built from the function <code class="code">f</code>.
    To create a new stream element, the function <code class="code">f</code> is called with
    the current stream count. The user function <code class="code">f</code> must return either
    <code class="code"><span class="constructor">Some</span> &lt;value&gt;</code> for a value or <code class="code"><span class="constructor">None</span></code> to specify the end of the
    stream.<br>
</div>
<br>
<h6 id="6_Streamiterator">Stream iterator</h6><br>

<pre><span id="VALiter"><span class="keyword">let</span> iter</span> : <code class="type">('a => unit) => <a href="BatStream.html#TYPEt">t</a> 'a => unit</code></pre><div class="info ">
<code class="code"><span class="constructor">Stream</span>.iter f s</code> scans the whole stream s, applying function <code class="code">f</code>
    in turn to each stream element encountered.<br>
</div>

<pre><span id="VALfoldl"><span class="keyword">let</span> foldl</span> : <code class="type">('a => 'b => ('a, option bool)) => 'a => <a href="BatStream.html#TYPEt">t</a> 'b => 'a</code></pre><div class="info ">
<code class="code">foldl f init stream</code> is a lazy fold_left. <code class="code">f accu elt</code> should return
    <code class="code">(new_accu, state)</code> where <code class="code">new_accu</code> is normal accumulation result, and
    <code class="code">state</code> is a flag representing whether the computation should continue
    and whether the last operation is valid: <code class="code"><span class="constructor">None</span></code> means continue, <code class="code"><span class="constructor">Some</span> b</code>
    means stop where <code class="code">b = <span class="keyword">true</span></code> means the last addition is still valid and <code class="code">b
    = <span class="keyword">false</span></code> means the last addition is invalid and should be revert.<br>
</div>

<pre><span id="VALfoldr"><span class="keyword">let</span> foldr</span> : <code class="type">('a => lazy_t 'b => 'b) => 'b => <a href="BatStream.html#TYPEt">t</a> 'a => 'b</code></pre><div class="info ">
<code class="code">foldr f init stream</code> is a lazy fold_right. Unlike the normal fold_right,
    the accumulation parameter of <code class="code">f elt accu</code> is lazy, hence it can decide
    not to force the evaluation of <code class="code">accu</code> if the current element <code class="code">elt</code> can
    determin the result by itself.<br>
</div>

<pre><span id="VALfold"><span class="keyword">let</span> fold</span> : <code class="type">('a => 'a => ('a, option bool)) => <a href="BatStream.html#TYPEt">t</a> 'a => 'a</code></pre><div class="info ">
<code class="code">fold</code> is <code class="code">foldl</code> without initialization value, where the first
    element of stream is taken as <code class="code">init</code>. It raises <code class="code"><span class="constructor">End_of_stream</span></code> exception
    when the input stream is empty.<br>
</div>

<pre><span id="VALfilter"><span class="keyword">let</span> filter</span> : <code class="type">('a => bool) => <a href="BatStream.html#TYPEt">t</a> 'a => <a href="BatStream.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">filter test stream</code> picks all the elements satisfying <code class="code">test</code> from <code class="code">stream</code>
    and return the results in the same order as a stream.<br>
</div>
<br>
<h6 id="6_Predefinedparsers">Predefined parsers</h6><br>

<pre><span id="VALnext"><span class="keyword">let</span> next</span> : <code class="type"><a href="BatStream.html#TYPEt">t</a> 'a => 'a</code></pre><div class="info ">
Return the first element of the stream and remove it from the
    stream.<br>
<b>Raises</b> <code>Stream.Failure</code> if the stream is empty.<br>
</div>

<pre><span id="VALempty"><span class="keyword">let</span> empty</span> : <code class="type"><a href="BatStream.html#TYPEt">t</a> 'a => unit</code></pre><div class="info ">
Return <code class="code">()</code> if the stream is empty, else raise <code class="code"><span class="constructor">Stream</span>.<span class="constructor">Failure</span></code>.<br>
</div>
<br>
<h6 id="6_Usefulfunctions">Useful functions</h6><br>

<pre><span id="VALpeek"><span class="keyword">let</span> peek</span> : <code class="type"><a href="BatStream.html#TYPEt">t</a> 'a => option 'a</code></pre><div class="info ">
Return <code class="code"><span class="constructor">Some</span></code> of "the first element" of the stream, or <code class="code"><span class="constructor">None</span></code> if
    the stream is empty.<br>
</div>

<pre><span id="VALjunk"><span class="keyword">let</span> junk</span> : <code class="type"><a href="BatStream.html#TYPEt">t</a> 'a => unit</code></pre><div class="info ">
Remove the first element of the stream, possibly unfreezing
    it before.<br>
</div>

<pre><span id="VALcount"><span class="keyword">let</span> count</span> : <code class="type"><a href="BatStream.html#TYPEt">t</a> 'a => int</code></pre><div class="info ">
Return the current count of the stream elements, i.e. the number
    of the stream elements discarded.<br>
</div>

<pre><span id="VALnpeek"><span class="keyword">let</span> npeek</span> : <code class="type">int => <a href="BatStream.html#TYPEt">t</a> 'a => list 'a</code></pre><div class="info ">
<code class="code">npeek n</code> returns the list of the <code class="code">n</code> first elements of
    the stream, or all its remaining elements if less than <code class="code">n</code>
    elements are available.<br>
</div>
<br>
<h6 id="6_Conversionfunctions">Conversion functions</h6><br>

<pre><span id="VALenum"><span class="keyword">let</span> enum</span> : <code class="type"><a href="BatStream.html#TYPEt">t</a> 'a => <a href="BatEnum.html#TYPEt">BatEnum.t</a> 'a</code></pre><div class="info ">
Convert a stream to an enumeration.
    Reading the resulting enumeration will consume elements from the stream.
    This is the preferred manner of converting from a stream to any other
    data structure.<br>
</div>

<pre><span id="VALof_enum"><span class="keyword">let</span> of_enum</span> : <code class="type"><a href="BatEnum.html#TYPEt">BatEnum.t</a> 'a => <a href="BatStream.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Convert an enumeration to a stream.
    Reading the resulting stream will consume elements from the enumeration.
    This is the preferred manner of creating a stream.<br>
</div>

<pre><span id="VALof_input"><span class="keyword">let</span> of_input</span> : <code class="type"><a href="BatIO.html#TYPEinput">BatIO.input</a> => <a href="BatStream.html#TYPEt">t</a> char</code></pre><div class="info ">
Convert an <code class="code">input</code> to a stream.<br>
</div>

<pre><span id="VALto_list"><span class="keyword">let</span> to_list</span> : <code class="type"><a href="BatStream.html#TYPEt">t</a> 'a => list 'a</code></pre><div class="info ">
Convert a stream to a list<br>
</div>

<pre><span id="VALto_string"><span class="keyword">let</span> to_string</span> : <code class="type"><a href="BatStream.html#TYPEt">t</a> char => string</code></pre><div class="info ">
convert stream of chars to string, using buffer<br>
</div>

<pre><span id="VALto_string_fmt"><span class="keyword">let</span> to_string_fmt</span> : <code class="type">Pervasives.format 'a => string unit string => <a href="BatStream.html#TYPEt">t</a> 'a => string</code></pre><div class="info ">
convert stream to string, using Printf with given format<br>
</div>

<pre><span id="VALto_string_fun"><span class="keyword">let</span> to_string_fun</span> : <code class="type">('a => string) => <a href="BatStream.html#TYPEt">t</a> 'a => string</code></pre><div class="info ">
convert stream to string, using given conversion function<br>
</div>
<br>
<h6 id="6_Streamconsumers">Stream consumers</h6><br>

<pre><span id="VALon_output"><span class="keyword">let</span> on_output</span> : <code class="type"><a href="BatIO.html#TYPEoutput">BatIO.output</a> 'a => <a href="BatStream.html#TYPEt">t</a> char => unit</code></pre><div class="info ">
Convert an <code class="code">output</code> to a stream.<br>
</div>
<br>
<h6 id="6_Computationoverstream">Computation over stream</h6>
<p>

    All the functions in this part are lazy.<br>

<pre><span id="VALmap"><span class="keyword">let</span> map</span> : <code class="type">('a => 'b) => <a href="BatStream.html#TYPEt">t</a> 'a => <a href="BatStream.html#TYPEt">t</a> 'b</code></pre><div class="info ">
<code class="code">map f stream</code> applies <code class="code">f</code> in turn to elements from <code class="code">stream</code> and return the
    results as a stream in the same order.<br>
</div>

<pre><span id="VALmap2"><span class="keyword">let</span> map2</span> : <code class="type">('a => 'b => 'c) => <a href="BatStream.html#TYPEt">t</a> 'a => <a href="BatStream.html#TYPEt">t</a> 'b => <a href="BatStream.html#TYPEt">t</a> 'c</code></pre><div class="info ">
<code class="code">map2 f streama streamb</code> applies <code class="code">f</code> in turn to elements of corresponding
    positions from <code class="code">streama</code> and <code class="code">streamb</code>. The results are constructed in the
    same order as a stream. If one stream is short, excess elements of the longer
    stream are ignored.<br>
</div>

<pre><span id="VALscanl"><span class="keyword">let</span> scanl</span> : <code class="type">('a => 'b => 'a) => 'a => <a href="BatStream.html#TYPEt">t</a> 'b => <a href="BatStream.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">scanl f init stream</code> returns a stream of successive reduced
    values from the left: <code class="code">scanl f init [&lt; <span class="keywordsign">'</span>e0; <span class="keywordsign">'</span>e1; ... &gt;]</code> is
    equivalent to
      <code class="code">[&lt; <span class="keywordsign">'</span>init; <span class="keywordsign">'</span>(f init e0); <span class="keywordsign">'</span>(f (f init e0) e1); ... &gt;]</code><br>
</div>

<pre><span id="VALscan"><span class="keyword">let</span> scan</span> : <code class="type">('a => 'a => 'a) => <a href="BatStream.html#TYPEt">t</a> 'a => <a href="BatStream.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">scan</code> is similar to <code class="code">scanl</code> but without the <code class="code">init</code> value:
    <code class="code">scanl f init [&lt; <span class="keywordsign">'</span>e0; <span class="keywordsign">'</span>e1; <span class="keywordsign">'</span>e2; ... &gt;]</code> is equivalent to
      <code class="code">[&lt; <span class="keywordsign">'</span>e0; <span class="keywordsign">'</span>(f e0 e1); <span class="keywordsign">'</span>(f (f e0 e1) e2); ... &gt;]</code><br>
</div>

<pre><span id="VALconcat"><span class="keyword">let</span> concat</span> : <code class="type"><a href="BatStream.html#TYPEt">t</a> (<a href="BatStream.html#TYPEt">t</a> 'a) => <a href="BatStream.html#TYPEt">t</a> 'a</code></pre><div class="info ">
concatenate a stream of streams<br>
</div>

<pre><span id="VALconcat_map"><span class="keyword">let</span> concat_map</span> : <code class="type">('a => <a href="BatStream.html#TYPEt">t</a> 'b) => <a href="BatStream.html#TYPEt">t</a> 'a => <a href="BatStream.html#TYPEt">t</a> 'b</code></pre><div class="info ">
Composition of <a href="BatStream.html#VALconcat"><code class="code"><span class="constructor">BatStream</span>.concat</code></a> and <a href="BatStream.html#VALmap"><code class="code"><span class="constructor">BatStream</span>.map</code></a>.
    <code class="code">concat_map f e</code> is the same as <code class="code">concat (map f e)</code>.<br>
<b>Since</b> 2.3.0<br>
</div>

<pre><span id="VALtake"><span class="keyword">let</span> take</span> : <code class="type">int => <a href="BatStream.html#TYPEt">t</a> 'a => <a href="BatStream.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">take n stream</code> returns the prefix of <code class="code">stream</code> of length <code class="code">n</code>, or <code class="code">stream</code>
    itself if <code class="code">n</code> is greater than the length of <code class="code">stream</code><br>
</div>

<pre><span id="VALdrop"><span class="keyword">let</span> drop</span> : <code class="type">int => <a href="BatStream.html#TYPEt">t</a> 'a => <a href="BatStream.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">drop n stream</code> returns the suffix of <code class="code">stream</code> after the first <code class="code">n</code> elements,
    or a empty stream if <code class="code">n</code> is greater than the length of <code class="code">stream</code><br>
</div>

<pre><span id="VALtake_while"><span class="keyword">let</span> take_while</span> : <code class="type">('a => bool) => <a href="BatStream.html#TYPEt">t</a> 'a => <a href="BatStream.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">take_while test stream</code> returns the longest (possibly empty) prefix of
    <code class="code">stream</code> of elements that satisfy <code class="code">test</code>.<br>
</div>

<pre><span id="VALdrop_while"><span class="keyword">let</span> drop_while</span> : <code class="type">('a => bool) => <a href="BatStream.html#TYPEt">t</a> 'a => <a href="BatStream.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">drop_while test stream</code> returns the remaining suffix of <code class="code">take_while test
    stream</code>.<br>
</div>
<br>
<h6 id="6_Streamspairarithmetic">Streams pair arithmetic</h6>
<p>

    All the functions in this part are lazy.<br>

<pre><span id="VALdup"><span class="keyword">let</span> dup</span> : <code class="type"><a href="BatStream.html#TYPEt">t</a> 'a => (<a href="BatStream.html#TYPEt">t</a> 'a, <a href="BatStream.html#TYPEt">t</a> 'a)</code></pre><div class="info ">
<code class="code">dup stream</code> returns a pair of streams which are identical to <code class="code">stream</code>. Note
    that stream is a destructive data structure, the point of <code class="code">dup</code> is to
    return two streams can be used independently.
<p>

    NOT IMPLEMENTED CORRECTLY - WILL RAISE Failure UNTIL CORRECT
    IMPLEMENTATION FOUND<br>
</div>

<pre><span id="VALcomb"><span class="keyword">let</span> comb</span> : <code class="type">(<a href="BatStream.html#TYPEt">t</a> 'a, <a href="BatStream.html#TYPEt">t</a> 'b) => <a href="BatStream.html#TYPEt">t</a> ('a, 'b)</code></pre><div class="info ">
<code class="code">comb</code> transform a pair of stream into a stream of pairs of corresponding
    elements. If one stream is short, excess elements of the longer stream are
    ignored.<br>
</div>

<pre><span id="VALsplit"><span class="keyword">let</span> split</span> : <code class="type"><a href="BatStream.html#TYPEt">t</a> ('a, 'b) => (<a href="BatStream.html#TYPEt">t</a> 'a, <a href="BatStream.html#TYPEt">t</a> 'b)</code></pre><div class="info ">
<code class="code">split</code> is the opposite of <code class="code">comb</code><br>
</div>

<pre><span id="VALmerge"><span class="keyword">let</span> merge</span> : <code class="type">(bool => 'a => bool) => (<a href="BatStream.html#TYPEt">t</a> 'a, <a href="BatStream.html#TYPEt">t</a> 'a) => <a href="BatStream.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">merge test (streama, streamb)</code> merge the elements from <code class="code">streama</code> and
    <code class="code">streamb</code> into a single stream. The <code class="code">bool</code> type here represents the id of the
    two input streams where <code class="code"><span class="keyword">true</span></code> is the first and <code class="code"><span class="keyword">false</span></code> represents the
    second. The <code class="code">test</code> function is applied to each element of the output stream
    together with the id of the input stream from which it was extracted, to
    decide which stream should the next element come from. The first element is
    always taken from <code class="code">streama</code>. When a stream runs out of elements, the merge
    process will continue to take elements from the other stream until both
    streams reach their ends.<br>
</div>

<pre><span id="VALswitch"><span class="keyword">let</span> switch</span> : <code class="type">('a => bool) => <a href="BatStream.html#TYPEt">t</a> 'a => (<a href="BatStream.html#TYPEt">t</a> 'a, <a href="BatStream.html#TYPEt">t</a> 'a)</code></pre><div class="info ">
<code class="code">switch test stream</code> split <code class="code">stream</code> into two streams, where the first stream have
    all the elements satisfying <code class="code">test</code>, the second stream is opposite. The
    order of elements in the source stream is preserved.<br>
</div>
<br>
<h6 id="6_Streamarithmetic">Stream arithmetic</h6>
<p>

    All the functions in this part are lazy.<br>

<pre><span id="VALcons"><span class="keyword">let</span> cons</span> : <code class="type">'a => <a href="BatStream.html#TYPEt">t</a> 'a => <a href="BatStream.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">cons x stream</code> equals <code class="code">[&lt;<span class="keywordsign">'</span>x; stream&gt;]</code>.<br>
</div>

<pre><span id="VALapnd"><span class="keyword">let</span> apnd</span> : <code class="type"><a href="BatStream.html#TYPEt">t</a> 'a => <a href="BatStream.html#TYPEt">t</a> 'a => <a href="BatStream.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">apnd fla flb</code> equals <code class="code">[&lt;fla;flb&gt;]</code>.<br>
</div>

<pre><span id="VALis_empty"><span class="keyword">let</span> is_empty</span> : <code class="type"><a href="BatStream.html#TYPEt">t</a> 'a => bool</code></pre><div class="info ">
<code class="code">is_empty stream</code> tests whether <code class="code">stream</code> is empty. But note that it forces
    the evaluation of the head element if any.<br>
</div>
<br>
<h6 id="6_Predefinedparsers">Predefined parsers</h6><br>

<pre><span id="VALnext"><span class="keyword">let</span> next</span> : <code class="type"><a href="BatStream.html#TYPEt">t</a> 'a => 'a</code></pre><div class="info ">
Return the first element of the stream and remove it from the
    stream.<br>
<b>Raises</b> <code>Stream.Failure</code> if the stream is empty.<br>
</div>

<pre><span class="keyword">module</span> <a href="BatStream.StreamLabels.html">StreamLabels</a>: <code class="code">{</code> <a href="BatStream.StreamLabels.html">..</a> <code class="code">}</code></pre></body></html>