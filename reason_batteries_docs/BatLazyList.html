<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="BatInterfaces.html">
<link rel="next" href="BatLexing.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="BatArray" rel="Chapter" href="BatArray.html">
<link title="BatAvlTree" rel="Chapter" href="BatAvlTree.html">
<link title="BatBase64" rel="Chapter" href="BatBase64.html">
<link title="BatBig_int" rel="Chapter" href="BatBig_int.html">
<link title="BatBigarray" rel="Chapter" href="BatBigarray.html">
<link title="BatBitSet" rel="Chapter" href="BatBitSet.html">
<link title="BatBool" rel="Chapter" href="BatBool.html">
<link title="BatBounded" rel="Chapter" href="BatBounded.html">
<link title="BatBuffer" rel="Chapter" href="BatBuffer.html">
<link title="BatBytes" rel="Chapter" href="BatBytes.html">
<link title="BatCache" rel="Chapter" href="BatCache.html">
<link title="BatChar" rel="Chapter" href="BatChar.html">
<link title="BatCharParser" rel="Chapter" href="BatCharParser.html">
<link title="BatComplex" rel="Chapter" href="BatComplex.html">
<link title="BatConcurrent" rel="Chapter" href="BatConcurrent.html">
<link title="BatDeque" rel="Chapter" href="BatDeque.html">
<link title="BatDigest" rel="Chapter" href="BatDigest.html">
<link title="BatDllist" rel="Chapter" href="BatDllist.html">
<link title="BatDynArray" rel="Chapter" href="BatDynArray.html">
<link title="BatEnum" rel="Chapter" href="BatEnum.html">
<link title="BatFile" rel="Chapter" href="BatFile.html">
<link title="BatFingerTree" rel="Chapter" href="BatFingerTree.html">
<link title="BatFloat" rel="Chapter" href="BatFloat.html">
<link title="BatFormat" rel="Chapter" href="BatFormat.html">
<link title="BatGc" rel="Chapter" href="BatGc.html">
<link title="BatGenlex" rel="Chapter" href="BatGenlex.html">
<link title="BatGlobal" rel="Chapter" href="BatGlobal.html">
<link title="BatHashcons" rel="Chapter" href="BatHashcons.html">
<link title="BatHashtbl" rel="Chapter" href="BatHashtbl.html">
<link title="BatHeap" rel="Chapter" href="BatHeap.html">
<link title="BatIMap" rel="Chapter" href="BatIMap.html">
<link title="BatIO" rel="Chapter" href="BatIO.html">
<link title="BatISet" rel="Chapter" href="BatISet.html">
<link title="BatInnerIO" rel="Chapter" href="BatInnerIO.html">
<link title="BatInnerPervasives" rel="Chapter" href="BatInnerPervasives.html">
<link title="BatInnerWeaktbl" rel="Chapter" href="BatInnerWeaktbl.html">
<link title="BatInt" rel="Chapter" href="BatInt.html">
<link title="BatInt32" rel="Chapter" href="BatInt32.html">
<link title="BatInt64" rel="Chapter" href="BatInt64.html">
<link title="BatInterfaces" rel="Chapter" href="BatInterfaces.html">
<link title="BatLazyList" rel="Chapter" href="BatLazyList.html">
<link title="BatLexing" rel="Chapter" href="BatLexing.html">
<link title="BatList" rel="Chapter" href="BatList.html">
<link title="BatLog" rel="Chapter" href="BatLog.html">
<link title="BatLogger" rel="Chapter" href="BatLogger.html">
<link title="BatMap" rel="Chapter" href="BatMap.html">
<link title="BatMarshal" rel="Chapter" href="BatMarshal.html">
<link title="BatMultiMap" rel="Chapter" href="BatMultiMap.html">
<link title="BatMultiPMap" rel="Chapter" href="BatMultiPMap.html">
<link title="BatMutex" rel="Chapter" href="BatMutex.html">
<link title="BatNativeint" rel="Chapter" href="BatNativeint.html">
<link title="BatNum" rel="Chapter" href="BatNum.html">
<link title="BatNumber" rel="Chapter" href="BatNumber.html">
<link title="BatOo" rel="Chapter" href="BatOo.html">
<link title="BatOptParse" rel="Chapter" href="BatOptParse.html">
<link title="BatOption" rel="Chapter" href="BatOption.html">
<link title="BatOrd" rel="Chapter" href="BatOrd.html">
<link title="BatParserCo" rel="Chapter" href="BatParserCo.html">
<link title="BatPathGen" rel="Chapter" href="BatPathGen.html">
<link title="BatPervasives" rel="Chapter" href="BatPervasives.html">
<link title="BatPrintexc" rel="Chapter" href="BatPrintexc.html">
<link title="BatPrintf" rel="Chapter" href="BatPrintf.html">
<link title="BatQueue" rel="Chapter" href="BatQueue.html">
<link title="BatRMutex" rel="Chapter" href="BatRMutex.html">
<link title="BatRandom" rel="Chapter" href="BatRandom.html">
<link title="BatRef" rel="Chapter" href="BatRef.html">
<link title="BatRefList" rel="Chapter" href="BatRefList.html">
<link title="BatResult" rel="Chapter" href="BatResult.html">
<link title="BatReturn" rel="Chapter" href="BatReturn.html">
<link title="BatScanf" rel="Chapter" href="BatScanf.html">
<link title="BatSeq" rel="Chapter" href="BatSeq.html">
<link title="BatSet" rel="Chapter" href="BatSet.html">
<link title="BatSplay" rel="Chapter" href="BatSplay.html">
<link title="BatStack" rel="Chapter" href="BatStack.html">
<link title="BatStream" rel="Chapter" href="BatStream.html">
<link title="BatString" rel="Chapter" href="BatString.html">
<link title="BatSubstring" rel="Chapter" href="BatSubstring.html">
<link title="BatSys" rel="Chapter" href="BatSys.html">
<link title="BatText" rel="Chapter" href="BatText.html">
<link title="BatTuple" rel="Chapter" href="BatTuple.html">
<link title="BatUChar" rel="Chapter" href="BatUChar.html">
<link title="BatUTF8" rel="Chapter" href="BatUTF8.html">
<link title="BatUnit" rel="Chapter" href="BatUnit.html">
<link title="BatUnix" rel="Chapter" href="BatUnix.html">
<link title="BatUref" rel="Chapter" href="BatUref.html">
<link title="BatVect" rel="Chapter" href="BatVect.html">
<link title="Batteries" rel="Chapter" href="Batteries.html">
<link title="BatteriesConfig" rel="Chapter" href="BatteriesConfig.html">
<link title="BatteriesExceptionless" rel="Chapter" href="BatteriesExceptionless.html">
<link title="BatteriesPrint" rel="Chapter" href="BatteriesPrint.html">
<link title="BatteriesThread" rel="Chapter" href="BatteriesThread.html">
<link title="Extlib" rel="Chapter" href="Extlib.html"><link title="Exceptions" rel="Section" href="#6_Exceptions">
<link title=" Type" rel="Section" href="#6_Type">
<link title="Access " rel="Section" href="#6_Access">
<link title="List creation" rel="Section" href="#6_Listcreation">
<link title="Higher-order functions" rel="Section" href="#6_Higherorderfunctions">
<link title="Finding" rel="Section" href="#6_Finding">
<link title=" Common functions" rel="Section" href="#6_Commonfunctions">
<link title="Association lists" rel="Section" href="#6_Associationlists">
<link title="Transformations" rel="Section" href="#6_Transformations">
<link title="Dropping elements" rel="Section" href="#6_Droppingelements">
<link title=" Conversions" rel="Section" href="#6_Conversions">
<link title=" Predicates" rel="Section" href="#6_Predicates">
<link title="Misc." rel="Section" href="#6_Misc">
<link title="Sorting" rel="Section" href="#6_Sorting">
<link title="Operations on two lists" rel="Section" href="#6_Operationsontwolists">
<link title="Boilerplate code" rel="Section" href="#6_Boilerplatecode">
<link title="Boilerplate code" rel="Section" href="#6_Boilerplatecode">
<link title="Override modules" rel="Section" href="#6_Overridemodules">
<link title="Override modules" rel="Section" href="#6_Overridemodules">
<link title="Printing" rel="Subsection" href="#7_Printing">
<title>Batteries user guide : BatLazyList</title>
</head>
<body>
<div class="navbar"><a class="pre" href="BatInterfaces.html" title="BatInterfaces">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="BatLexing.html" title="BatLexing">Next</a>
</div>
<h1>Module <a href="type_BatLazyList.html">BatLazyList</a></h1>

<pre><span class="keyword">module</span> BatLazyList: <code class="code">{</code> <a href="BatLazyList.html">..</a> <code class="code">}</code></pre><div class="info module top">
Lazy lists of elements.
<p>

     Lazy lists are similar to lists, with the exception that their contents are
     only computed whenever requested. This makes them particularly useful in
     contexts where streams of data are to be handled.
<p>

     <b>Note</b> For this documentation, we will assume the existence of
     a lazy list syntax extension such that <code class="code">[^ ^]</code> is the empty lazy
     list and <code class="code">[^ a;b;c ^]</code> is the lazy list containing elements <code class="code">a</code>,
     <code class="code">b</code>, <code class="code">c</code>.
<p>

     <b>Note</b> Enumerations (as featured in module <a href="BatEnum.html"><code class="code"><span class="constructor">BatEnum</span></code></a>) and lazy
     lists (as featured in this module) are quite similar in
     purpose. Lazy lists are slightly higher level, insofar as no
     cloning is required to get them to work, which makes them
     slightly more useful in contexts where backtracking is
     common. Enumerations, on the other hand, are closer to
     traditional stream processing, and require more low-level marking
     whenever backtracking is required, but may be faster and more
     memory-efficient when used properly. Either choice is recommended
     over OCaml's built-in <code class="code"><span class="constructor">Stream</span></code>.<br>
<b>Author(s):</b> David Teller<br>
</div>
<hr width="100%">
<br>
<h6 id="6_Exceptions">Exceptions</h6><br>

<pre><span id="EXCEPTIONEmpty_list"><span class="keyword">exception</span> Empty_list</span></pre>
<div class="info ">
<code class="code"><span class="constructor">Empty_list</span></code> is raised when an operation applied on an empty list
    is invalid. For instance, <code class="code">hd nil</code> will raise <code class="code"><span class="constructor">Empty_list</span></code>.<br>
</div>

<pre><span id="EXCEPTIONInvalid_index"><span class="keyword">exception</span> Invalid_index</span> <span class="keyword">of</span> <code class="type">int</code></pre>
<div class="info ">
<code class="code"><span class="constructor">Invalid_index</span></code> is raised when an indexed access on a list is
    out of list bounds.<br>
</div>

<pre><span id="EXCEPTIONDifferent_list_size"><span class="keyword">exception</span> Different_list_size</span> <span class="keyword">of</span> <code class="type">string</code></pre>
<div class="info ">
<code class="code"><span class="constructor">Different_list_size</span></code> is raised when applying functions such as
    <code class="code">iter2</code> on two lists having different size.<br>
</div>

<pre><span id="EXCEPTIONNo_more_elements"><span class="keyword">exception</span> No_more_elements</span></pre>
<div class="info ">
See <a href="BatLazyList.html#VALfrom"><code class="code"><span class="constructor">BatLazyList</span>.from</code></a> and <a href="BatLazyList.html#VALfrom_loop"><code class="code"><span class="constructor">BatLazyList</span>.from_loop</code></a> for more information on this exception.<br>
</div>
<br>
<h6 id="6_Type"> Type</h6>
<p>

   <b>Note</b> The types are kept concrete so as to allow pattern-matching.
   However, it is generally easier to manipulate <a href="BatLazyList.html#VALnil"><code class="code"><span class="constructor">BatLazyList</span>.nil</code></a> and <a href="BatLazyList.html#VALcons"><code class="code"><span class="constructor">BatLazyList</span>.cons</code></a>.<br>

<pre><span id="TYPEt"><span class="keyword">type</span> t <code class="type">'a</code></span> = <code class="type">Lazy.t (<a href="BatLazyList.html#TYPEnode_t">node_t</a> 'a)</code> </pre>
<div class="info ">
The type of a lazy list.<br>
</div>


<pre><code><span id="TYPEnode_t"><span class="keyword">type</span> node_t <code class="type">'a</code></span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTnode_t.Nil"><span class="constructor">Nil</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTnode_t.Cons"><span class="constructor">Cons</span></span> <span class="keyword">of</span> <code class="type">'a <a href="BatLazyList.html#TYPEt">t</a> 'a</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
The type of an item in the list.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>



<pre><span class="keyword">include</span> <a href="BatEnum.Enumerable.html">BatEnum.Enumerable</a></pre>

<pre><span class="keyword">include</span> <a href="BatInterfaces.Mappable.html">BatInterfaces.Mappable</a></pre>
<br>
<h6 id="6_Access">Access </h6><br>

<pre><span id="VALnil"><span class="keyword">let</span> nil</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
The empty list.<br>
</div>

<pre><span id="VALcons"><span class="keyword">let</span> cons</span> : <code class="type">'a => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Build a list from a head and a tail.<br>
</div>

<pre><span id="VAL(^:^)"><span class="keyword">let</span> (^:^)</span> : <code class="type">'a => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
As <code class="code">cons</code>: <code class="code">x^:^l</code> is the lazy list with head <code class="code">x</code> and tail <code class="code">l</code><br>
</div>

<pre><span id="VALpeek"><span class="keyword">let</span> peek</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => option 'a</code></pre><div class="info ">
<code class="code">peek l</code> returns the first element of <code class="code">l</code>, if it exists.<br>
</div>

<pre><span id="VALget"><span class="keyword">let</span> get</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => option ('a, <a href="BatLazyList.html#TYPEt">t</a> 'a)</code></pre><div class="info ">
<code class="code">get l</code> returns the head and tail of <code class="code">l</code>, if <code class="code">l</code> is not empty.<br>
</div>
<br>
<h6 id="6_Listcreation">List creation</h6><br>

<pre><span id="VALfrom"><span class="keyword">let</span> from</span> : <code class="type">(unit => 'a) => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">from next</code> creates a (possibly infinite) lazy list from the successive
   results of <code class="code">next</code>.<br>
<b>Raises</b> <code>LazyList.No_more_elements</code> to denote the end of the list.<br>
</div>

<pre><span id="VALfrom_while"><span class="keyword">let</span> from_while</span> : <code class="type">(unit => option 'a) => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">from next</code> creates a (possibly infinite) lazy list from the successive
   results of <code class="code">next</code>.
   The list ends whenever <code class="code">next</code> returns <code class="code"><span class="constructor">None</span></code>.<br>
</div>

<pre><span id="VALfrom_loop"><span class="keyword">let</span> from_loop</span> : <code class="type">'b => ('b => ('a, 'b)) => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">from_loop data next</code> creates a (possibly infinite) lazy list from
   the successive results of applying <code class="code">next</code> to <code class="code">data</code>, then to the
   result, etc. The list ends whenever the function raises
   <code class="code"><span class="constructor">LazyList</span>.<span class="constructor">No_more_elements</span></code>.<br>
</div>

<pre><span id="VALseq"><span class="keyword">let</span> seq</span> : <code class="type">'a => ('a => 'a) => ('a => bool) => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">seq init step cond</code> creates a sequence of data, which starts
    from <code class="code">init</code>,  extends by <code class="code">step</code>,  until the condition <code class="code">cond</code>
    fails. E.g. <code class="code">seq 1 ((+) 1) ((&gt;) 100)</code> returns <code class="code">[^1, 2, ... 99^]</code>. If <code class="code">cond
    init</code> is false, the result is empty.<br>
</div>

<pre><span id="VALunfold"><span class="keyword">let</span> unfold</span> : <code class="type">'b => ('b => option ('a, 'b)) => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">unfold data next</code> creates a (possibly infinite) lazy list from
   the successive results of applying <code class="code">next</code> to <code class="code">data</code>, then to the
   result, etc. The list ends whenever the function returns <code class="code"><span class="constructor">None</span></code><br>
</div>

<pre><span id="VALinit"><span class="keyword">let</span> init</span> : <code class="type">int => (int => 'a) => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Similar to <code class="code"><span class="constructor">Array</span>.init</code>, <code class="code">init n f</code> returns the lazy list
    containing the results of (f 0),(f 1).... (f (n-1)).<br>
<b>Raises</b> <code>Invalid_argument</code> <code class="code"><span class="string">"LazyList.init"</span></code> if n &lt; 0.<br>
</div>

<pre><span id="VALmake"><span class="keyword">let</span> make</span> : <code class="type">int => 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Similar to <code class="code"><span class="constructor">String</span>.make</code>, <code class="code">make n x</code> returns a
    list containing <code class="code">n</code> elements <code class="code">x</code>.<br>
</div>

<pre><span id="VALrange"><span class="keyword">let</span> range</span> : <code class="type">int => int => <a href="BatLazyList.html#TYPEt">t</a> int</code></pre><div class="info ">
Compute lazily a range of integers a .. b as a lazy list.
<p>

   The range is empty if b &lt;= a.<br>
</div>
<br>
<h6 id="6_Higherorderfunctions">Higher-order functions</h6><br>

<pre><span id="VALiter"><span class="keyword">let</span> iter</span> : <code class="type">('a => 'b) => <a href="BatLazyList.html#TYPEt">t</a> 'a => unit</code></pre><div class="info ">
Eager iteration
<p>

   <code class="code">iter f [^ a0; a1; ...; an ^]</code> applies function <code class="code">f</code> in turn to <code class="code">a0;
   a1; ...; an</code>.  It is equivalent to <code class="code"><span class="keyword">begin</span> f a0; f a1; ...; f an; ()
   <span class="keyword">end</span></code>. In particular, it causes all the elements of the list to be
   evaluated.<br>
</div>

<pre><span id="VALiteri"><span class="keyword">let</span> iteri</span> : <code class="type">(int => 'a => unit) => <a href="BatLazyList.html#TYPEt">t</a> 'a => unit</code></pre><div class="info ">
Eager iteration, with indices
<p>

   <code class="code">iteri f [^ a0; a1; ...; an ^]</code> applies function <code class="code">f</code> in turn to
   <code class="code">a0; a1;...; an</code>, along with the corresponding <code class="code">0,1..n</code> index.  It
   is equivalent to <code class="code"><span class="keyword">begin</span> f 0 a0; f 1 a1; ...; f n an; ()
   <span class="keyword">end</span></code>. In particular, it causes all the elements of the list to be
   evaluated.<br>
</div>

<pre><span id="VALmap"><span class="keyword">let</span> map</span> : <code class="type">('a => 'b) => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'b</code></pre><div class="info ">
Lazy map
<p>

   <code class="code">map f [^ a0; a1; ... ^]</code> builds the list <code class="code">[^ f a0; f a1; ... ^]</code>
   with the results returned by <code class="code">f</code>. Not tail-recursive. Evaluations
   of <code class="code">f</code> take place only when the contents of the list are forced.<br>
</div>

<pre><span id="VALmapi"><span class="keyword">let</span> mapi</span> : <code class="type">(int => 'a => 'b) => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'b</code></pre><div class="info ">
Lazy map, with indices
<p>

   <code class="code">mapi f [^ a0; a1; ... ^]</code> builds the list <code class="code">[^ f 0 a0; f 1 a1;
   ... ^]</code> with the results returned by <code class="code">f</code>. Not
   tail-recursive. Evaluations of <code class="code">f</code> take place only when the
   contents of the list are forced.<br>
</div>

<pre><span id="VALfold_left"><span class="keyword">let</span> fold_left</span> : <code class="type">('a => 'b => 'a) => 'a => <a href="BatLazyList.html#TYPEt">t</a> 'b => 'a</code></pre><div class="info ">
Eager fold_left
<p>

   <code class="code"><span class="constructor">LazyList</span>.fold_left f a [^ b0; b1; ...; bn ^]</code> is <code class="code">f (... (f (f
   a b0) b1) ...) bn</code>. This causes evaluation of all the elements of
   the list.<br>
</div>

<pre><span id="VALfold_right"><span class="keyword">let</span> fold_right</span> : <code class="type">('a => 'b => 'b) => 'b => <a href="BatLazyList.html#TYPEt">t</a> 'a => 'b</code></pre><div class="info ">
Eager fold_right
<p>

   <code class="code">fold_right f b [^ a0; a1; ...; an ^]</code> is <code class="code">f a0 (f a1 (... (f an b) ...))</code>.
   This causes evaluation of all the elements of the list. Not
   tail-recursive.
<p>

   Note that the argument order of this function is the same as
   <code class="code">fold_left</code> above, but inconsistent with other <code class="code">fold_right</code>
   functions in Batteries. We hope to fix this inconsistency in the
   next compatibility-breaking release, so you should rather use the
   more consistent <code class="code">eager_fold_right</code>.<br>
<b>Since</b> 2.2.0<br>
</div>

<pre><span id="VALeager_fold_right"><span class="keyword">let</span> eager_fold_right</span> : <code class="type">('a => 'b => 'b) => <a href="BatLazyList.html#TYPEt">t</a> 'a => 'b => 'b</code></pre><div class="info ">
Eager fold_right
<p>

    As <code class="code">fold_right</code> above, but with the usual argument order for
    a fold_right.
<p>

    Just as <code class="code">fold_left</code> on a structure <code class="code"><span class="keywordsign">'</span>a t</code> turns an element-level
    function of type <code class="code">('b -> 'a -> 'b)</code>, with the accumulator argument
    <code class="code"><span class="keywordsign">'</span>b</code> on the left, into a structure-level function
    <code class="code">'b -> 'a t -> 'b</code>, <code class="code">fold_right</code> turns a function
    <code class="code">('a -> 'b -> 'b)</code> (accumulator on the right) into
    a <code class="code">'a t -> 'b -> 'b</code>.<br>
</div>

<pre><span id="VALlazy_fold_right"><span class="keyword">let</span> lazy_fold_right</span> : <code class="type">('a => Lazy.t 'b => 'b) => <a href="BatLazyList.html#TYPEt">t</a> 'a => Lazy.t 'b => Lazy.t 'b</code></pre><div class="info ">
Lazy fold_right
   <code class="code">lazy_fold_right f (<span class="constructor">Cons</span> (a0, <span class="constructor">Cons</span> (a1, <span class="constructor">Cons</span> (a2, nil)))) b</code> is
   <code class="code"><span class="keyword">lazy</span> (f a0 (<span class="keyword">lazy</span> (f a1 (<span class="keyword">lazy</span> (f a2 b)))))</code>.
<p>

   Forcing the result of <code class="code">lazy_fold_right</code> forces the first element of
   the list; the rest is forced only if/when the function <code class="code">f</code> forces
   its accumulator argument.<br>
<b>Since</b> 2.1<br>
</div>
<br>
<h6 id="6_Finding">Finding</h6><br>

<pre><span id="VALmem"><span class="keyword">let</span> mem</span> : <code class="type">'a => <a href="BatLazyList.html#TYPEt">t</a> 'a => bool</code></pre><div class="info ">
<code class="code">mem x l</code> determines if <code class="code">x</code> is part of <code class="code">l</code>.
    Evaluates all the elements of <code class="code">l</code> which appear
    before <code class="code">x</code>.<br>
</div>

<pre><span id="VALmemq"><span class="keyword">let</span> memq</span> : <code class="type">'a => <a href="BatLazyList.html#TYPEt">t</a> 'a => bool</code></pre><div class="info ">
As <code class="code">mem</code>, but with physical equality<br>
</div>

<pre><span id="VALfind"><span class="keyword">let</span> find</span> : <code class="type">('a => bool) => <a href="BatLazyList.html#TYPEt">t</a> 'a => 'a</code></pre><div class="info ">
<code class="code">find p l</code> returns the first element of <code class="code">l</code> such as <code class="code">p x</code>
    returns <code class="code"><span class="keyword">true</span></code>.<br>
<b>Raises</b> <code>Not_found</code> if such an element has not been found.<br>
</div>

<pre><span id="VALrfind"><span class="keyword">let</span> rfind</span> : <code class="type">('a => bool) => <a href="BatLazyList.html#TYPEt">t</a> 'a => 'a</code></pre><div class="info ">
<code class="code">rfind p l</code> returns the last element <code class="code">x</code> of <code class="code">l</code> such as <code class="code">p x</code> returns
    <code class="code"><span class="keyword">true</span></code>.<br>
<b>Raises</b> <code>Not_found</code> if such element as not been found.<br>
</div>

<pre><span id="VALfind_exn"><span class="keyword">let</span> find_exn</span> : <code class="type">('a => bool) => exn => <a href="BatLazyList.html#TYPEt">t</a> 'a => 'a</code></pre><div class="info ">
<code class="code">find_exn p e l</code> returns the first element of <code class="code">l</code> such as <code class="code">p x</code>
    returns <code class="code"><span class="keyword">true</span></code> or raises <code class="code">e</code> if such an element has not been found.<br>
</div>

<pre><span id="VALrfind_exn"><span class="keyword">let</span> rfind_exn</span> : <code class="type">('a => bool) => exn => <a href="BatLazyList.html#TYPEt">t</a> 'a => 'a</code></pre><div class="info ">
<code class="code">find_exn p e l</code> returns the last element of <code class="code">l</code> such as <code class="code">p x</code>
    returns <code class="code"><span class="keyword">true</span></code> or raises <code class="code">e</code> if such an element has not been found.<br>
</div>

<pre><span id="VALfindi"><span class="keyword">let</span> findi</span> : <code class="type">(int => 'a => bool) => <a href="BatLazyList.html#TYPEt">t</a> 'a => (int, 'a)</code></pre><div class="info ">
<code class="code">findi p e l</code> returns the first element <code class="code">ai</code> of <code class="code">l</code> along with its
    index <code class="code">i</code> such that <code class="code">p i ai</code> is true.<br>
<b>Raises</b> <code>Not_found</code> if no such element has been found.<br>
</div>

<pre><span id="VALrfindi"><span class="keyword">let</span> rfindi</span> : <code class="type">(int => 'a => bool) => <a href="BatLazyList.html#TYPEt">t</a> 'a => (int, 'a)</code></pre><div class="info ">
<code class="code">findi p e l</code> returns the last element <code class="code">ai</code> of <code class="code">l</code> along with its
    index <code class="code">i</code> such that <code class="code">p i ai</code> is true.<br>
<b>Raises</b> <code>Not_found</code> if no such element has been found.<br>
</div>

<pre><span id="VALindex_of"><span class="keyword">let</span> index_of</span> : <code class="type">'a => <a href="BatLazyList.html#TYPEt">t</a> 'a => option int</code></pre><div class="info ">
<code class="code">index_of e l</code> returns the index of the first occurrence of <code class="code">e</code>
    in <code class="code">l</code>, or <code class="code"><span class="constructor">None</span></code> if there is no occurrence of <code class="code">e</code> in <code class="code">l</code><br>
</div>

<pre><span id="VALindex_ofq"><span class="keyword">let</span> index_ofq</span> : <code class="type">'a => <a href="BatLazyList.html#TYPEt">t</a> 'a => option int</code></pre><div class="info ">
<code class="code">index_ofq e l</code> behaves as <code class="code">index_of e l</code> except it uses
    physical equality<br>
</div>

<pre><span id="VALrindex_of"><span class="keyword">let</span> rindex_of</span> : <code class="type">'a => <a href="BatLazyList.html#TYPEt">t</a> 'a => option int</code></pre><div class="info ">
<code class="code">index_of e l</code> returns the index of the last occurrence of <code class="code">e</code>
    in <code class="code">l</code>, or <code class="code"><span class="constructor">None</span></code> if there is no occurrence of <code class="code">e</code> in <code class="code">l</code><br>
</div>

<pre><span id="VALrindex_ofq"><span class="keyword">let</span> rindex_ofq</span> : <code class="type">'a => <a href="BatLazyList.html#TYPEt">t</a> 'a => option int</code></pre><div class="info ">
<code class="code">rindex_ofq e l</code> behaves as <code class="code">rindex_of e l</code> except it uses
    physical equality<br>
</div>
<br>
<h6 id="6_Commonfunctions"> Common functions</h6><br>

<pre><span id="VALnext"><span class="keyword">let</span> next</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEnode_t">node_t</a> 'a</code></pre><div class="info ">
Compute and return the next value of the list<br>
</div>

<pre><span id="VALlength"><span class="keyword">let</span> length</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => int</code></pre><div class="info ">
Return the length (number of elements) of the given list.
<p>

   Causes the evaluation of all the elements of the list.<br>
</div>

<pre><span id="VALis_empty"><span class="keyword">let</span> is_empty</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => bool</code></pre><div class="info ">
Returns <code class="code"><span class="keyword">true</span></code> if the list is empty, false otherwise.<br>
</div>

<pre><span id="VALwould_at_fail"><span class="keyword">let</span> would_at_fail</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => int => bool</code></pre><div class="info ">
<code class="code">would_at_fail l n</code> returns <code class="code"><span class="keyword">true</span></code> if <code class="code">l</code> contains strictly less
   than <code class="code">n</code> elements, <code class="code"><span class="keyword">false</span></code> otherwise<br>
</div>

<pre><span id="VALhd"><span class="keyword">let</span> hd</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => 'a</code></pre><div class="info ">
Return the first element of the given list.<br>
<b>Raises</b> <code>Empty_list</code> if the list is empty.
<p>

   Note: this function does not comply with the usual exceptionless error-management
   recommendations, as doing so would essentially render it useless.<br>
</div>

<pre><span id="VALtl"><span class="keyword">let</span> tl</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Return the given list without its first element.<br>
<b>Raises</b> <code>Empty_list</code> if the list is empty.
<p>

   Note: this function does not comply with the usual exceptionless error-management
   recommendations, as doing so would essentially render it useless.<br>
</div>

<pre><span id="VALfirst"><span class="keyword">let</span> first</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => 'a</code></pre><div class="info ">
As <code class="code">hd</code><br>
</div>

<pre><span id="VALlast"><span class="keyword">let</span> last</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => 'a</code></pre><div class="info ">
Returns the last element of the list.<br>
<b>Raises</b> <code>Empty_list</code> if
    the list is empty. This function takes linear time and causes the
    evaluation of all elements of the list<br>
</div>

<pre><span id="VALat"><span class="keyword">let</span> at</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => int => 'a</code></pre><div class="info ">
<code class="code">at l n</code> returns the element at index <code class="code">n</code> (starting from <code class="code">0</code>) in
    the list <code class="code">l</code>.<br>
<b>Raises</b> <code>Invalid_index</code> is the index is outside of
    <code class="code">l</code> bounds.<br>
</div>

<pre><span id="VALnth"><span class="keyword">let</span> nth</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => int => 'a</code></pre><div class="info ">
Obsolete. As <code class="code">at</code><br>
</div>
<br>
<h6 id="6_Associationlists">Association lists</h6>
<p>

    These lists behave essentially as <code class="code"><span class="constructor">HashMap</span></code>, although they are
    typically faster for short number of associations, and much
    slower for for large number of associations.<br>

<pre><span id="VALassoc"><span class="keyword">let</span> assoc</span> : <code class="type">'a => <a href="BatLazyList.html#TYPEt">t</a> ('a, 'b) => 'b</code></pre><div class="info ">
<code class="code">assoc a l</code> returns the value associated with key <code class="code">a</code> in the list of
    pairs <code class="code">l</code>. That is, <code class="code">assoc a [^ ...; (a,b); ...^] = b</code>
    if <code class="code">(a,b)</code> is the leftmost binding of <code class="code">a</code> in list <code class="code">l</code>.<br>
<b>Raises</b> <code>Not_found</code> if there is no value associated with <code class="code">a</code> in the
    list <code class="code">l</code>.<br>
</div>

<pre><span id="VALassq"><span class="keyword">let</span> assq</span> : <code class="type">'a => <a href="BatLazyList.html#TYPEt">t</a> ('a, 'b) => 'b</code></pre><div class="info ">
As <a href="BatLazyList.html#VALassoc"><code class="code"><span class="constructor">BatLazyList</span>.assoc</code></a> but with physical equality<br>
</div>

<pre><span id="VALmem_assoc"><span class="keyword">let</span> mem_assoc</span> : <code class="type">'a => <a href="BatLazyList.html#TYPEt">t</a> ('a, 'b) => bool</code></pre><div class="info ">
As <a href="BatLazyList.html#VALassoc"><code class="code"><span class="constructor">BatLazyList</span>.assoc</code></a> but simply returns <code class="code"><span class="keyword">true</span></code> if a binding exists, <code class="code"><span class="keyword">false</span></code>
    otherwise.<br>
</div>

<pre><span id="VALmem_assq"><span class="keyword">let</span> mem_assq</span> : <code class="type">'a => <a href="BatLazyList.html#TYPEt">t</a> ('a, 'b) => bool</code></pre><div class="info ">
As <a href="BatLazyList.html#VALmem_assoc"><code class="code"><span class="constructor">BatLazyList</span>.mem_assoc</code></a> but with physical equality.<br>
</div>

<pre><span id="VALrev"><span class="keyword">let</span> rev</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Eager list reversal.<br>
</div>
<br>
<h6 id="6_Transformations">Transformations</h6><br>

<pre><span id="VALeager_append"><span class="keyword">let</span> eager_append</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Evaluate a list and append another list after this one.
<p>

   Cost is linear in the length of the first list, not tail-recursive.<br>
</div>

<pre><span id="VALrev_append"><span class="keyword">let</span> rev_append</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Eager reverse-and-append
<p>

   Cost is linear in the length of the first list, tail-recursive.<br>
</div>

<pre><span id="VALappend"><span class="keyword">let</span> append</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Lazy append
<p>

   Cost is constant. All evaluation is delayed until the contents
   of the list are actually read. Reading itself is delayed by
   a constant.<br>
</div>

<pre><span id="VAL(^@^)"><span class="keyword">let</span> (^@^)</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
As lazy append<br>
</div>

<pre><span id="VALconcat"><span class="keyword">let</span> concat</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> (<a href="BatLazyList.html#TYPEt">t</a> 'a) => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Lazy concatenation of a lazy list of lazy lists<br>
</div>

<pre><span id="VALflatten"><span class="keyword">let</span> flatten</span> : <code class="type">list (<a href="BatLazyList.html#TYPEt">t</a> 'a) => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Lazy concatenation of a list of lazy lists<br>
</div>

<pre><span id="VALsplit_at"><span class="keyword">let</span> split_at</span> : <code class="type">int => <a href="BatLazyList.html#TYPEt">t</a> 'a => (<a href="BatLazyList.html#TYPEt">t</a> 'a, <a href="BatLazyList.html#TYPEt">t</a> 'a)</code></pre><div class="info ">
<code class="code">split_at n l</code> returns two lists <code class="code">l1</code> and <code class="code">l2</code>, <code class="code">l1</code> containing the
    first <code class="code">n</code> elements of <code class="code">l</code> and <code class="code">l2</code> the others.<br>
<b>Raises</b> <code>Invalid_index</code> if
    <code class="code">n</code> is outside of <code class="code">l</code> size bounds.<br>
</div>

<pre><span id="VALsplit_nth"><span class="keyword">let</span> split_nth</span> : <code class="type">int => <a href="BatLazyList.html#TYPEt">t</a> 'a => (<a href="BatLazyList.html#TYPEt">t</a> 'a, <a href="BatLazyList.html#TYPEt">t</a> 'a)</code></pre><div class="info ">
Obsolete. As <code class="code">split_at</code>.<br>
</div>
<br>
<h6 id="6_Droppingelements">Dropping elements</h6><br>

<pre><span id="VALunique"><span class="keyword">let</span> unique</span> : <code class="type">cmp::('a => 'a => int)? => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">unique cmp l</code> returns the list <code class="code">l</code> without any duplicate element.
    Default comparator ( = ) is used if no comparison function specified.<br>
</div>

<pre><span id="VALunique_eq"><span class="keyword">let</span> unique_eq</span> : <code class="type">eq::('a => 'a => bool)? => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
as <code class="code">unique</code> except only uses an equality function.  Use for
    short lists when comparing is expensive compared to equality
    testing<br>
<b>Since</b> 1.3.0<br>
</div>

<pre><span id="VALremove"><span class="keyword">let</span> remove</span> : <code class="type">'a => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">remove l x</code> returns the list <code class="code">l</code> without the first element <code class="code">x</code> found
    or returns  <code class="code">l</code> if no element is equal to <code class="code">x</code>. Elements are compared
    using ( = ).<br>
</div>

<pre><span id="VALremove_if"><span class="keyword">let</span> remove_if</span> : <code class="type">('a => bool) => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">remove_if cmp l</code> is similar to <code class="code">remove</code>, but with <code class="code">cmp</code> used
    instead of ( = ).<br>
</div>

<pre><span id="VALremove_all"><span class="keyword">let</span> remove_all</span> : <code class="type">'a => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">remove_all l x</code> is similar to <code class="code">remove</code> but removes all elements that
    are equal to <code class="code">x</code> and not only the first one.<br>
</div>

<pre><span id="VALremove_all_such"><span class="keyword">let</span> remove_all_such</span> : <code class="type">('a => bool) => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">remove_all_such f l</code> is similar to <code class="code">remove</code> but removes all elements
    that satisfy the predicate <code class="code">f</code> and not only the first one.<br>
</div>

<pre><span id="VALtake"><span class="keyword">let</span> take</span> : <code class="type">int => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">take n l</code> returns up to the <code class="code">n</code> first elements from list <code class="code">l</code>, if
    available.<br>
</div>

<pre><span id="VALdrop"><span class="keyword">let</span> drop</span> : <code class="type">int => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">drop n l</code> returns <code class="code">l</code> without the first <code class="code">n</code> elements, or the empty
    list if <code class="code">l</code> have less than <code class="code">n</code> elements.<br>
</div>

<pre><span id="VALtake_while"><span class="keyword">let</span> take_while</span> : <code class="type">('a => bool) => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">take_while f xs</code> returns the first elements of list <code class="code">xs</code>
    which satisfy the predicate <code class="code">f</code>.<br>
</div>

<pre><span id="VALdrop_while"><span class="keyword">let</span> drop_while</span> : <code class="type">('a => bool) => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
<code class="code">drop_while f xs</code> returns the list <code class="code">xs</code> with the first
    elements satisfying the predicate <code class="code">f</code> dropped.<br>
</div>
<br>
<h6 id="6_Conversions"> Conversions</h6><br>

<pre><span id="VALto_list"><span class="keyword">let</span> to_list</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => list 'a</code></pre><div class="info ">
Eager conversion to string.<br>
</div>

<pre><span id="VALto_stream"><span class="keyword">let</span> to_stream</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => Stream.t 'a</code></pre><div class="info ">
Lazy conversion to stream.<br>
</div>

<pre><span id="VALto_array"><span class="keyword">let</span> to_array</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => array 'a</code></pre><div class="info ">
Eager conversion to array.<br>
</div>

<pre><span id="VALenum"><span class="keyword">let</span> enum</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatEnum.html#TYPEt">BatEnum.t</a> 'a</code></pre><div class="info ">
Lazy conversion to enumeration<br>
</div>

<pre><span id="VALof_list"><span class="keyword">let</span> of_list</span> : <code class="type">list 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Lazy conversion from lists
<p>

   Albeit slower than eager conversion, this is the default mechanism for converting from regular
   lists to lazy lists.  This for two reasons :
   * if you're using lazy lists, total speed probably isn't as much an issue as start-up speed
   * this will let you convert regular infinite lists to lazy lists.<br>
</div>

<pre><span id="VALof_stream"><span class="keyword">let</span> of_stream</span> : <code class="type">Stream.t 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Lazy conversion from stream.<br>
</div>

<pre><span id="VALof_enum"><span class="keyword">let</span> of_enum</span> : <code class="type"><a href="BatEnum.html#TYPEt">BatEnum.t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Lazy conversion from enum.<br>
</div>

<pre><span id="VALeager_of_list"><span class="keyword">let</span> eager_of_list</span> : <code class="type">list 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Eager conversion from lists.
<p>

   This function is much faster than <a href="BatLazyList.html#VALof_list"><code class="code"><span class="constructor">BatLazyList</span>.of_list</code></a> but will freeze on cyclic lists.<br>
</div>

<pre><span id="VALof_array"><span class="keyword">let</span> of_array</span> : <code class="type">array 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Eager conversion from array<br>
</div>
<br>
<h6 id="6_Predicates"> Predicates</h6><br>

<pre><span id="VALfilter"><span class="keyword">let</span> filter</span> : <code class="type">('a => bool) => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Lazy filtering.
<p>

   <code class="code">filter p l</code> returns all the elements of the list <code class="code">l</code>  that satisfy the predicate <code class="code">p</code>.
   The order of the elements in the input list is preserved.<br>
</div>

<pre><span id="VALexists"><span class="keyword">let</span> exists</span> : <code class="type">('a => bool) => <a href="BatLazyList.html#TYPEt">t</a> 'a => bool</code></pre><div class="info ">
Eager existential.
<p>

   <code class="code">exists p [^ a0; a1; ... ^]</code> checks if at least one element of the list satisfies the predicate <code class="code">p</code>.
   That is, it returns <code class="code"> (p a0) <span class="keywordsign">||</span> (p a1) <span class="keywordsign">||</span> ... </code>.<br>
</div>

<pre><span id="VALfor_all"><span class="keyword">let</span> for_all</span> : <code class="type">('a => bool) => <a href="BatLazyList.html#TYPEt">t</a> 'a => bool</code></pre><div class="info ">
Eager universal.
<p>

   <code class="code">for_all p [^ a0; a1; ... ^]</code> checks if all elements of the list satisfy the predicate <code class="code">p</code>.
   That is, it returns <code class="code">(p a0) <span class="keywordsign">&amp;&amp;</span> (p a1) <span class="keywordsign">&amp;&amp;</span> ... </code>.<br>
</div>

<pre><span id="VALfilter_map"><span class="keyword">let</span> filter_map</span> : <code class="type">('a => option 'b) => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'b</code></pre><div class="info ">
Lazily eliminate some elements and transform others.
<p>

   <code class="code">filter_map f [^ a0; a1; ... ^]</code> applies lazily <code class="code">f</code> to each <code class="code">a0</code>,
   <code class="code">a1</code>... If <code class="code">f ai</code> evaluates to <code class="code"><span class="constructor">None</span></code>, the element is not included
   in the result. Otherwise, if <code class="code">f ai</code> evaluates to <code class="code"><span class="constructor">Some</span> x</code>, element
   <code class="code">x</code> is included in the result.
<p>

   This is equivalent to
   <code class="code"><span class="keyword">match</span> f a0 <span class="keyword">with</span>
     <span class="keywordsign">|</span> <span class="constructor">Some</span> x0 <span class="keywordsign">-&gt;</span> x0 ^:^ (<span class="keyword">match</span> f a1 <span class="keyword">with</span>
            <span class="keywordsign">|</span> <span class="constructor">Some</span> x1 <span class="keywordsign">-&gt;</span> x1 ^:^ ...
            <span class="keywordsign">|</span> <span class="constructor">None</span> <span class="keywordsign">-&gt;</span> [^ ^])
     <span class="keywordsign">|</span> <span class="constructor">None</span>   <span class="keywordsign">-&gt;</span> [^ ^] </code>.<br>
</div>
<br>
<h6 id="6_Misc">Misc.</h6><br>

<pre><span id="VALeternity"><span class="keyword">let</span> eternity</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> unit</code></pre><div class="info ">
An infinite list of nothing<br>
</div>
<br>
<h6 id="6_Sorting">Sorting</h6><br>

<pre><span id="VALsort"><span class="keyword">let</span> sort</span> : <code class="type">cmp::('a => 'a => int)? => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><div class="info ">
Sort the list using optional comparator (by default <code class="code">compare</code>).<br>
</div>

<pre><span id="VALstable_sort"><span class="keyword">let</span> stable_sort</span> : <code class="type">('a => 'a => int) => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'a</code></pre><br>
<h6 id="6_Operationsontwolists">Operations on two lists</h6><br>

<pre><span id="VALmap2"><span class="keyword">let</span> map2</span> : <code class="type">('a => 'b => 'c) => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'b => <a href="BatLazyList.html#TYPEt">t</a> 'c</code></pre><div class="info ">
<code class="code">map2 f [^ a0; a1; ...^] [^ b0; b1; ... ^]</code> is <code class="code">[^ f a0 b0; f a1
    b1; ... ^]</code>.<br>
<b>Raises</b> <code>Different_list_size</code> if the two lists have
    different lengths. Not tail-recursive, lazy. In particular, the
    exception is raised only after the shortest list has been
    entirely consumed.<br>
</div>

<pre><span id="VALiter2"><span class="keyword">let</span> iter2</span> : <code class="type">('a => 'b => unit) => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'b => unit</code></pre><div class="info ">
<code class="code">iter2 f [^ a0; ...; an ^] [^ b0; ...; bn ^]</code> calls in turn
    <code class="code">f a0 b0; ...; f an bn</code>. Tail-recursive, eager.<br>
<b>Raises</b> <code>Different_list_size</code> if the two lists have
    different lengths.<br>
</div>

<pre><span id="VALfold_left2"><span class="keyword">let</span> fold_left2</span> : <code class="type">('a => 'b => 'c => 'a) => 'a => <a href="BatLazyList.html#TYPEt">t</a> 'b => <a href="BatLazyList.html#TYPEt">t</a> 'c => 'a</code></pre><div class="info ">
<code class="code">fold_left2 f a [^ b0; b1; ...; bn ^] [^ c0; c1; ...; cn ^]</code> is
    <code class="code">f (... (f (f a b0 c0) b1 c1) ...) bn cn</code>. Eager.<br>
<b>Raises</b> <code>Different_list_size</code> if the two lists have
    different lengths.<br>
</div>

<pre><span id="VALfold_right2"><span class="keyword">let</span> fold_right2</span> : <code class="type">('a => 'b => 'c => 'c) => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'b => 'c => 'c</code></pre><div class="info ">
<code class="code">fold_right2 f [^ a0; a1; ...; an ^] [^ b0; b1; ...; bn ^] c</code> is
    <code class="code">f a0 b0 (f a1 b1 (... (f an bn c) ...))</code>. Eager.<br>
<b>Raises</b> <code>Different_list_size</code> if the two lists have
    different lengths.  Tail-recursive.<br>
</div>

<pre><span id="VALfor_all2"><span class="keyword">let</span> for_all2</span> : <code class="type">('a => 'b => bool) => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'b => bool</code></pre><div class="info ">
Same as <a href="BatLazyList.html#VALfor_all"><code class="code"><span class="constructor">BatLazyList</span>.for_all</code></a>, but for a two-argument predicate.<br>
<b>Raises</b> <code>Different_list_size</code> if the two lists have
    different lengths.<br>
</div>

<pre><span id="VALexists2"><span class="keyword">let</span> exists2</span> : <code class="type">('a => 'b => bool) => <a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'b => bool</code></pre><div class="info ">
Same as <a href="BatLazyList.html#VALexists"><code class="code"><span class="constructor">BatLazyList</span>.exists</code></a>, but for a two-argument predicate.<br>
<b>Raises</b> <code>Different_list_size</code> if the two lists have
    different lengths.<br>
</div>

<pre><span id="VALcombine"><span class="keyword">let</span> combine</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'b => <a href="BatLazyList.html#TYPEt">t</a> ('a, 'b)</code></pre><div class="info ">
Transform a pair of lists into a list of pairs:
    <code class="code">combine [^ a0; a1; ... ^] [^ b0; b1; ... ^]</code> is
    <code class="code">[^ (a0, b0); (a1, b1); ... ^]</code>.<br>
<b>Raises</b> <code>Different_list_size</code> if the two lists
    have different lengths.  Tail-recursive, lazy.<br>
</div>

<pre><span id="VALuncombine"><span class="keyword">let</span> uncombine</span> : <code class="type"><a href="BatLazyList.html#TYPEt">t</a> ('a, 'b) => (<a href="BatLazyList.html#TYPEt">t</a> 'a, <a href="BatLazyList.html#TYPEt">t</a> 'b)</code></pre><div class="info ">
Divide a list of pairs into a pair of lists.<br>
</div>

<pre><span class="keyword">module</span> <a href="BatLazyList.Infix.html">Infix</a>: <code class="code">{</code> <a href="BatLazyList.Infix.html">..</a> <code class="code">}</code></pre><div class="info">
Infix submodule regrouping all infix operators
</div>
<br>
<h6 id="6_Boilerplatecode">Boilerplate code</h6><br>
<br>
<h6 id="6_Boilerplatecode">Boilerplate code</h6><br>
<br>
<div class="h7" id="7_Printing">Printing</div><br>

<pre><span id="VALprint"><span class="keyword">let</span> print</span> : <code class="type">first::string? =><br>       last::string? =><br>       sep::string? =><br>       (<a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> 'a => 'b => unit) =><br>       <a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> 'a => <a href="BatLazyList.html#TYPEt">t</a> 'b => unit</code></pre><br>
<h6 id="6_Overridemodules">Override modules</h6><br>
<br>
<h6 id="6_Overridemodules">Override modules</h6><br>
<br>
The following modules replace functions defined in <code class="code"><span class="constructor">LazyList</span></code> with functions
   behaving slightly differently but having the same name. This is by design:
   the functions meant to override the corresponding functions of <code class="code"><span class="constructor">LazyList</span></code>.<br>

<pre><span class="keyword">module</span> <a href="BatLazyList.Exceptionless.html">Exceptionless</a>: <code class="code">{</code> <a href="BatLazyList.Exceptionless.html">..</a> <code class="code">}</code></pre><div class="info">
Exceptionless counterparts for error-raising operations
</div>

<pre><span class="keyword">module</span> <a href="BatLazyList.Labels.html">Labels</a>: <code class="code">{</code> <a href="BatLazyList.Labels.html">..</a> <code class="code">}</code></pre><div class="info">
Operations on <code class="code"><span class="constructor">LazyList</span></code> with labels.
</div>
</body></html>