<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Batteries.Random.html">
<link rel="next" href="Batteries.Set.html">
<link rel="Up" href="Batteries.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="BatArray" rel="Chapter" href="BatArray.html">
<link title="BatAvlTree" rel="Chapter" href="BatAvlTree.html">
<link title="BatBase64" rel="Chapter" href="BatBase64.html">
<link title="BatBig_int" rel="Chapter" href="BatBig_int.html">
<link title="BatBigarray" rel="Chapter" href="BatBigarray.html">
<link title="BatBitSet" rel="Chapter" href="BatBitSet.html">
<link title="BatBool" rel="Chapter" href="BatBool.html">
<link title="BatBounded" rel="Chapter" href="BatBounded.html">
<link title="BatBuffer" rel="Chapter" href="BatBuffer.html">
<link title="BatBytes" rel="Chapter" href="BatBytes.html">
<link title="BatCache" rel="Chapter" href="BatCache.html">
<link title="BatChar" rel="Chapter" href="BatChar.html">
<link title="BatCharParser" rel="Chapter" href="BatCharParser.html">
<link title="BatComplex" rel="Chapter" href="BatComplex.html">
<link title="BatConcurrent" rel="Chapter" href="BatConcurrent.html">
<link title="BatDeque" rel="Chapter" href="BatDeque.html">
<link title="BatDigest" rel="Chapter" href="BatDigest.html">
<link title="BatDllist" rel="Chapter" href="BatDllist.html">
<link title="BatDynArray" rel="Chapter" href="BatDynArray.html">
<link title="BatEnum" rel="Chapter" href="BatEnum.html">
<link title="BatFile" rel="Chapter" href="BatFile.html">
<link title="BatFingerTree" rel="Chapter" href="BatFingerTree.html">
<link title="BatFloat" rel="Chapter" href="BatFloat.html">
<link title="BatFormat" rel="Chapter" href="BatFormat.html">
<link title="BatGc" rel="Chapter" href="BatGc.html">
<link title="BatGenlex" rel="Chapter" href="BatGenlex.html">
<link title="BatGlobal" rel="Chapter" href="BatGlobal.html">
<link title="BatHashcons" rel="Chapter" href="BatHashcons.html">
<link title="BatHashtbl" rel="Chapter" href="BatHashtbl.html">
<link title="BatHeap" rel="Chapter" href="BatHeap.html">
<link title="BatIMap" rel="Chapter" href="BatIMap.html">
<link title="BatIO" rel="Chapter" href="BatIO.html">
<link title="BatISet" rel="Chapter" href="BatISet.html">
<link title="BatInnerIO" rel="Chapter" href="BatInnerIO.html">
<link title="BatInnerPervasives" rel="Chapter" href="BatInnerPervasives.html">
<link title="BatInnerWeaktbl" rel="Chapter" href="BatInnerWeaktbl.html">
<link title="BatInt" rel="Chapter" href="BatInt.html">
<link title="BatInt32" rel="Chapter" href="BatInt32.html">
<link title="BatInt64" rel="Chapter" href="BatInt64.html">
<link title="BatInterfaces" rel="Chapter" href="BatInterfaces.html">
<link title="BatLazyList" rel="Chapter" href="BatLazyList.html">
<link title="BatLexing" rel="Chapter" href="BatLexing.html">
<link title="BatList" rel="Chapter" href="BatList.html">
<link title="BatLog" rel="Chapter" href="BatLog.html">
<link title="BatLogger" rel="Chapter" href="BatLogger.html">
<link title="BatMap" rel="Chapter" href="BatMap.html">
<link title="BatMarshal" rel="Chapter" href="BatMarshal.html">
<link title="BatMultiMap" rel="Chapter" href="BatMultiMap.html">
<link title="BatMultiPMap" rel="Chapter" href="BatMultiPMap.html">
<link title="BatMutex" rel="Chapter" href="BatMutex.html">
<link title="BatNativeint" rel="Chapter" href="BatNativeint.html">
<link title="BatNum" rel="Chapter" href="BatNum.html">
<link title="BatNumber" rel="Chapter" href="BatNumber.html">
<link title="BatOo" rel="Chapter" href="BatOo.html">
<link title="BatOptParse" rel="Chapter" href="BatOptParse.html">
<link title="BatOption" rel="Chapter" href="BatOption.html">
<link title="BatOrd" rel="Chapter" href="BatOrd.html">
<link title="BatParserCo" rel="Chapter" href="BatParserCo.html">
<link title="BatPathGen" rel="Chapter" href="BatPathGen.html">
<link title="BatPervasives" rel="Chapter" href="BatPervasives.html">
<link title="BatPrintexc" rel="Chapter" href="BatPrintexc.html">
<link title="BatPrintf" rel="Chapter" href="BatPrintf.html">
<link title="BatQueue" rel="Chapter" href="BatQueue.html">
<link title="BatRMutex" rel="Chapter" href="BatRMutex.html">
<link title="BatRandom" rel="Chapter" href="BatRandom.html">
<link title="BatRef" rel="Chapter" href="BatRef.html">
<link title="BatRefList" rel="Chapter" href="BatRefList.html">
<link title="BatResult" rel="Chapter" href="BatResult.html">
<link title="BatReturn" rel="Chapter" href="BatReturn.html">
<link title="BatScanf" rel="Chapter" href="BatScanf.html">
<link title="BatSeq" rel="Chapter" href="BatSeq.html">
<link title="BatSet" rel="Chapter" href="BatSet.html">
<link title="BatSplay" rel="Chapter" href="BatSplay.html">
<link title="BatStack" rel="Chapter" href="BatStack.html">
<link title="BatStream" rel="Chapter" href="BatStream.html">
<link title="BatString" rel="Chapter" href="BatString.html">
<link title="BatSubstring" rel="Chapter" href="BatSubstring.html">
<link title="BatSys" rel="Chapter" href="BatSys.html">
<link title="BatText" rel="Chapter" href="BatText.html">
<link title="BatTuple" rel="Chapter" href="BatTuple.html">
<link title="BatUChar" rel="Chapter" href="BatUChar.html">
<link title="BatUTF8" rel="Chapter" href="BatUTF8.html">
<link title="BatUnit" rel="Chapter" href="BatUnit.html">
<link title="BatUnix" rel="Chapter" href="BatUnix.html">
<link title="BatUref" rel="Chapter" href="BatUref.html">
<link title="BatVect" rel="Chapter" href="BatVect.html">
<link title="Batteries" rel="Chapter" href="Batteries.html">
<link title="BatteriesConfig" rel="Chapter" href="BatteriesConfig.html">
<link title="BatteriesExceptionless" rel="Chapter" href="BatteriesExceptionless.html">
<link title="BatteriesPrint" rel="Chapter" href="BatteriesPrint.html">
<link title="BatteriesThread" rel="Chapter" href="BatteriesThread.html">
<link title="Extlib" rel="Chapter" href="Extlib.html"><link title="Introduction" rel="Section" href="#6_Introduction">
<link title="Introduction" rel="Section" href="#6_Introduction">
<link title="Introduction" rel="Section" href="#6_Introduction">
<link title="Introduction" rel="Section" href="#6_Introduction">
<link title="Introduction" rel="Section" href="#6_Introduction">
<link title="Introduction" rel="Section" href="#6_Introduction">
<link title="Introduction" rel="Section" href="#6_Introduction">
<link title="Type of formatted input functions" rel="Section" href="#6_Typeofformattedinputfunctions">
<link title="The general formatted input function" rel="Section" href="#6_Thegeneralformattedinputfunction">
<link title="Format string description" rel="Section" href="#6_Formatstringdescription">
<link title="Format string description" rel="Section" href="#6_Formatstringdescription">
<link title="Format string description" rel="Section" href="#6_Formatstringdescription">
<link title="Format string description" rel="Section" href="#6_Formatstringdescription">
<link title="Format string description" rel="Section" href="#6_Formatstringdescription">
<link title="Format string description" rel="Section" href="#6_Formatstringdescription">
<link title="Format string description" rel="Section" href="#6_Formatstringdescription">
<link title="Format string description" rel="Section" href="#6_Formatstringdescription">
<link title="Format string description" rel="Section" href="#6_Formatstringdescription">
<link title="Format string description" rel="Section" href="#6_Formatstringdescription">
<link title="Format string description" rel="Section" href="#6_Formatstringdescription">
<link title="Specialized formatted input functions" rel="Section" href="#6_Specializedformattedinputfunctions">
<link title="Reading format strings from input" rel="Section" href="#6_Readingformatstringsfrominput">
<link title="Functional input with format strings" rel="Subsection" href="#7_Functionalinputwithformatstrings">
<link title="Functional input with format strings" rel="Subsection" href="#7_Functionalinputwithformatstrings">
<link title="Functional input with format strings" rel="Subsection" href="#7_Functionalinputwithformatstrings">
<link title="A simple example" rel="Subsection" href="#7_Asimpleexample">
<link title="Functional input with format strings" rel="Subsection" href="#7_Functionalinputwithformatstrings">
<link title="A simple example" rel="Subsection" href="#7_Asimpleexample">
<link title="Functional input with format strings" rel="Subsection" href="#7_Functionalinputwithformatstrings">
<link title="A simple example" rel="Subsection" href="#7_Asimpleexample">
<link title="Formatted input as a functional feature" rel="Subsection" href="#7_Formattedinputasafunctionalfeature">
<link title="Functional input with format strings" rel="Subsection" href="#7_Functionalinputwithformatstrings">
<link title="A simple example" rel="Subsection" href="#7_Asimpleexample">
<link title="Formatted input as a functional feature" rel="Subsection" href="#7_Formattedinputasafunctionalfeature">
<link title="The space character in format strings" rel="Subsection" href="#7_Thespacecharacterinformatstrings">
<link title="The space character in format strings" rel="Subsection" href="#7_Thespacecharacterinformatstrings">
<link title="The space character in format strings" rel="Subsection" href="#7_Thespacecharacterinformatstrings">
<link title="Conversion specifications in format strings" rel="Subsection" href="#7_Conversionspecificationsinformatstrings">
<link title="The space character in format strings" rel="Subsection" href="#7_Thespacecharacterinformatstrings">
<link title="Conversion specifications in format strings" rel="Subsection" href="#7_Conversionspecificationsinformatstrings">
<link title="The space character in format strings" rel="Subsection" href="#7_Thespacecharacterinformatstrings">
<link title="Conversion specifications in format strings" rel="Subsection" href="#7_Conversionspecificationsinformatstrings">
<link title="Scanning indications in format strings" rel="Subsection" href="#7_Scanningindicationsinformatstrings">
<link title="The space character in format strings" rel="Subsection" href="#7_Thespacecharacterinformatstrings">
<link title="Conversion specifications in format strings" rel="Subsection" href="#7_Conversionspecificationsinformatstrings">
<link title="Scanning indications in format strings" rel="Subsection" href="#7_Scanningindicationsinformatstrings">
<link title="The space character in format strings" rel="Subsection" href="#7_Thespacecharacterinformatstrings">
<link title="Conversion specifications in format strings" rel="Subsection" href="#7_Conversionspecificationsinformatstrings">
<link title="Scanning indications in format strings" rel="Subsection" href="#7_Scanningindicationsinformatstrings">
<link title="Exceptions during scanning" rel="Subsection" href="#7_Exceptionsduringscanning">
<link title="The space character in format strings" rel="Subsection" href="#7_Thespacecharacterinformatstrings">
<link title="Conversion specifications in format strings" rel="Subsection" href="#7_Conversionspecificationsinformatstrings">
<link title="Scanning indications in format strings" rel="Subsection" href="#7_Scanningindicationsinformatstrings">
<link title="Exceptions during scanning" rel="Subsection" href="#7_Exceptionsduringscanning">
<link title="The space character in format strings" rel="Subsection" href="#7_Thespacecharacterinformatstrings">
<link title="Conversion specifications in format strings" rel="Subsection" href="#7_Conversionspecificationsinformatstrings">
<link title="Scanning indications in format strings" rel="Subsection" href="#7_Scanningindicationsinformatstrings">
<link title="Exceptions during scanning" rel="Subsection" href="#7_Exceptionsduringscanning">
<title>Batteries user guide : Batteries.Scanf</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Batteries.Random.html" title="Batteries.Random">Previous</a>
&nbsp;<a class="up" href="Batteries.html" title="Batteries">Up</a>
&nbsp;<a class="post" href="Batteries.Set.html" title="Batteries.Set">Next</a>
</div>
<h1>Module <a href="type_Batteries.Scanf.html">Batteries.Scanf</a></h1>

<pre><span class="keyword">module</span> Scanf: <code class="type"><a href="BatScanf.html">BatScanf</a></code></pre><hr width="100%">
<br>
<h6 id="6_Introduction">Introduction</h6><br>
<br>
<h6 id="6_Introduction">Introduction</h6><br>
<br>
<div class="h7" id="7_Functionalinputwithformatstrings">Functional input with format strings</div><br>
<br>
<h6 id="6_Introduction">Introduction</h6><br>
<br>
<div class="h7" id="7_Functionalinputwithformatstrings">Functional input with format strings</div><br>
<br>
The module <code class="code"><span class="constructor">Scanf</span></code> provides formatted input functions or <em>scanners</em>.
<p>

    The formatted input functions can read from any kind of input, including
    strings, files, or anything that can return characters. The more general
    source of characters is named a <em>scanning buffer</em> and has type
    <a href="BatScanf.Scanning.html#TYPEscanbuf"><code class="code"><span class="constructor">BatScanf</span>.<span class="constructor">Scanning</span>.scanbuf</code></a>. The more general formatted input function reads from
    any scanning buffer and is named <code class="code">bscanf</code>.
<p>

    Generally speaking, the formatted input functions have 3 arguments:<ul>
<li>the first argument is a source of characters for the input,</li>
<li>the second argument is a format string that specifies the values to
      read,</li>
<li>the third argument is a <em>receiver function</em> that is applied to the
      values read.</li>
</ul>

    Hence, a typical call to the formatted input function <code class="code"><span class="constructor">Scanf</span>.bscanf</code> is
    <code class="code">bscanf ib fmt f</code>, where:
<p>
<ul>
<li><code class="code">ib</code> is a source of characters (typically a <em>    scanning buffer</em> with type <a href="BatScanf.Scanning.html#TYPEscanbuf"><code class="code"><span class="constructor">BatScanf</span>.<span class="constructor">Scanning</span>.scanbuf</code></a>),</li>
</ul>
<ul>
<li><code class="code">fmt</code> is a format string (the same format strings as those used to print
    material with module <code class="code"><span class="constructor">Printf</span></code> or <code class="code"><span class="constructor">Format</span></code>),</li>
</ul>
<ul>
<li><code class="code">f</code> is a function that has as many arguments as the number of values to
    read in the input.</li>
</ul>
<br>
<br>
<h6 id="6_Introduction">Introduction</h6><br>
<br>
<div class="h7" id="7_Functionalinputwithformatstrings">Functional input with format strings</div><br>
<br>
The module <code class="code"><span class="constructor">Scanf</span></code> provides formatted input functions or <em>scanners</em>.
<p>

    The formatted input functions can read from any kind of input, including
    strings, files, or anything that can return characters. The more general
    source of characters is named a <em>scanning buffer</em> and has type
    <a href="BatScanf.Scanning.html#TYPEscanbuf"><code class="code"><span class="constructor">BatScanf</span>.<span class="constructor">Scanning</span>.scanbuf</code></a>. The more general formatted input function reads from
    any scanning buffer and is named <code class="code">bscanf</code>.
<p>

    Generally speaking, the formatted input functions have 3 arguments:<ul>
<li>the first argument is a source of characters for the input,</li>
<li>the second argument is a format string that specifies the values to
      read,</li>
<li>the third argument is a <em>receiver function</em> that is applied to the
      values read.</li>
</ul>

    Hence, a typical call to the formatted input function <code class="code"><span class="constructor">Scanf</span>.bscanf</code> is
    <code class="code">bscanf ib fmt f</code>, where:
<p>
<ul>
<li><code class="code">ib</code> is a source of characters (typically a <em>    scanning buffer</em> with type <a href="BatScanf.Scanning.html#TYPEscanbuf"><code class="code"><span class="constructor">BatScanf</span>.<span class="constructor">Scanning</span>.scanbuf</code></a>),</li>
</ul>
<ul>
<li><code class="code">fmt</code> is a format string (the same format strings as those used to print
    material with module <code class="code"><span class="constructor">Printf</span></code> or <code class="code"><span class="constructor">Format</span></code>),</li>
</ul>
<ul>
<li><code class="code">f</code> is a function that has as many arguments as the number of values to
    read in the input.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Asimpleexample">A simple example</div><br>
<br>
<h6 id="6_Introduction">Introduction</h6><br>
<br>
<div class="h7" id="7_Functionalinputwithformatstrings">Functional input with format strings</div><br>
<br>
The module <code class="code"><span class="constructor">Scanf</span></code> provides formatted input functions or <em>scanners</em>.
<p>

    The formatted input functions can read from any kind of input, including
    strings, files, or anything that can return characters. The more general
    source of characters is named a <em>scanning buffer</em> and has type
    <a href="BatScanf.Scanning.html#TYPEscanbuf"><code class="code"><span class="constructor">BatScanf</span>.<span class="constructor">Scanning</span>.scanbuf</code></a>. The more general formatted input function reads from
    any scanning buffer and is named <code class="code">bscanf</code>.
<p>

    Generally speaking, the formatted input functions have 3 arguments:<ul>
<li>the first argument is a source of characters for the input,</li>
<li>the second argument is a format string that specifies the values to
      read,</li>
<li>the third argument is a <em>receiver function</em> that is applied to the
      values read.</li>
</ul>

    Hence, a typical call to the formatted input function <code class="code"><span class="constructor">Scanf</span>.bscanf</code> is
    <code class="code">bscanf ib fmt f</code>, where:
<p>
<ul>
<li><code class="code">ib</code> is a source of characters (typically a <em>    scanning buffer</em> with type <a href="BatScanf.Scanning.html#TYPEscanbuf"><code class="code"><span class="constructor">BatScanf</span>.<span class="constructor">Scanning</span>.scanbuf</code></a>),</li>
</ul>
<ul>
<li><code class="code">fmt</code> is a format string (the same format strings as those used to print
    material with module <code class="code"><span class="constructor">Printf</span></code> or <code class="code"><span class="constructor">Format</span></code>),</li>
</ul>
<ul>
<li><code class="code">f</code> is a function that has as many arguments as the number of values to
    read in the input.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Asimpleexample">A simple example</div><br>
<br>
As suggested above, the expression <code class="code">bscanf ib <span class="string">"%d"</span> f</code> reads a decimal
    integer <code class="code">n</code> from the source of characters <code class="code">ib</code> and returns <code class="code">f n</code>.
<p>

    For instance,
<p>
<ul>
<li>if we use <code class="code">stdib</code> as the source of characters (<a href="BatScanf.Scanning.html#VALstdib"><code class="code"><span class="constructor">BatScanf</span>.<span class="constructor">Scanning</span>.stdib</code></a> is
    the predefined input buffer that reads from standard input),</li>
</ul>
<ul>
<li>if we define the receiver <code class="code">f</code> as <code class="code"><span class="keyword">let</span> f x = x + 1</code>,</li>
</ul>

    then <code class="code">bscanf stdib <span class="string">"%d"</span> f</code> reads an integer <code class="code">n</code> from the standard input
    and returns <code class="code">f n</code> (that is <code class="code">n + 1</code>). Thus, if we evaluate <code class="code">bscanf stdib
    <span class="string">"%d"</span> f</code>, and then enter <code class="code">41</code> at the keyboard, we get <code class="code">42</code> as the final
    result.<br>
<br>
<h6 id="6_Introduction">Introduction</h6><br>
<br>
<div class="h7" id="7_Functionalinputwithformatstrings">Functional input with format strings</div><br>
<br>
The module <code class="code"><span class="constructor">Scanf</span></code> provides formatted input functions or <em>scanners</em>.
<p>

    The formatted input functions can read from any kind of input, including
    strings, files, or anything that can return characters. The more general
    source of characters is named a <em>scanning buffer</em> and has type
    <a href="BatScanf.Scanning.html#TYPEscanbuf"><code class="code"><span class="constructor">BatScanf</span>.<span class="constructor">Scanning</span>.scanbuf</code></a>. The more general formatted input function reads from
    any scanning buffer and is named <code class="code">bscanf</code>.
<p>

    Generally speaking, the formatted input functions have 3 arguments:<ul>
<li>the first argument is a source of characters for the input,</li>
<li>the second argument is a format string that specifies the values to
      read,</li>
<li>the third argument is a <em>receiver function</em> that is applied to the
      values read.</li>
</ul>

    Hence, a typical call to the formatted input function <code class="code"><span class="constructor">Scanf</span>.bscanf</code> is
    <code class="code">bscanf ib fmt f</code>, where:
<p>
<ul>
<li><code class="code">ib</code> is a source of characters (typically a <em>    scanning buffer</em> with type <a href="BatScanf.Scanning.html#TYPEscanbuf"><code class="code"><span class="constructor">BatScanf</span>.<span class="constructor">Scanning</span>.scanbuf</code></a>),</li>
</ul>
<ul>
<li><code class="code">fmt</code> is a format string (the same format strings as those used to print
    material with module <code class="code"><span class="constructor">Printf</span></code> or <code class="code"><span class="constructor">Format</span></code>),</li>
</ul>
<ul>
<li><code class="code">f</code> is a function that has as many arguments as the number of values to
    read in the input.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Asimpleexample">A simple example</div><br>
<br>
As suggested above, the expression <code class="code">bscanf ib <span class="string">"%d"</span> f</code> reads a decimal
    integer <code class="code">n</code> from the source of characters <code class="code">ib</code> and returns <code class="code">f n</code>.
<p>

    For instance,
<p>
<ul>
<li>if we use <code class="code">stdib</code> as the source of characters (<a href="BatScanf.Scanning.html#VALstdib"><code class="code"><span class="constructor">BatScanf</span>.<span class="constructor">Scanning</span>.stdib</code></a> is
    the predefined input buffer that reads from standard input),</li>
</ul>
<ul>
<li>if we define the receiver <code class="code">f</code> as <code class="code"><span class="keyword">let</span> f x = x + 1</code>,</li>
</ul>

    then <code class="code">bscanf stdib <span class="string">"%d"</span> f</code> reads an integer <code class="code">n</code> from the standard input
    and returns <code class="code">f n</code> (that is <code class="code">n + 1</code>). Thus, if we evaluate <code class="code">bscanf stdib
    <span class="string">"%d"</span> f</code>, and then enter <code class="code">41</code> at the keyboard, we get <code class="code">42</code> as the final
    result.<br>
<br>
<div class="h7" id="7_Formattedinputasafunctionalfeature">Formatted input as a functional feature</div><br>
<br>
<h6 id="6_Introduction">Introduction</h6><br>
<br>
<div class="h7" id="7_Functionalinputwithformatstrings">Functional input with format strings</div><br>
<br>
The module <code class="code"><span class="constructor">Scanf</span></code> provides formatted input functions or <em>scanners</em>.
<p>

    The formatted input functions can read from any kind of input, including
    strings, files, or anything that can return characters. The more general
    source of characters is named a <em>scanning buffer</em> and has type
    <a href="BatScanf.Scanning.html#TYPEscanbuf"><code class="code"><span class="constructor">BatScanf</span>.<span class="constructor">Scanning</span>.scanbuf</code></a>. The more general formatted input function reads from
    any scanning buffer and is named <code class="code">bscanf</code>.
<p>

    Generally speaking, the formatted input functions have 3 arguments:<ul>
<li>the first argument is a source of characters for the input,</li>
<li>the second argument is a format string that specifies the values to
      read,</li>
<li>the third argument is a <em>receiver function</em> that is applied to the
      values read.</li>
</ul>

    Hence, a typical call to the formatted input function <code class="code"><span class="constructor">Scanf</span>.bscanf</code> is
    <code class="code">bscanf ib fmt f</code>, where:
<p>
<ul>
<li><code class="code">ib</code> is a source of characters (typically a <em>    scanning buffer</em> with type <a href="BatScanf.Scanning.html#TYPEscanbuf"><code class="code"><span class="constructor">BatScanf</span>.<span class="constructor">Scanning</span>.scanbuf</code></a>),</li>
</ul>
<ul>
<li><code class="code">fmt</code> is a format string (the same format strings as those used to print
    material with module <code class="code"><span class="constructor">Printf</span></code> or <code class="code"><span class="constructor">Format</span></code>),</li>
</ul>
<ul>
<li><code class="code">f</code> is a function that has as many arguments as the number of values to
    read in the input.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Asimpleexample">A simple example</div><br>
<br>
As suggested above, the expression <code class="code">bscanf ib <span class="string">"%d"</span> f</code> reads a decimal
    integer <code class="code">n</code> from the source of characters <code class="code">ib</code> and returns <code class="code">f n</code>.
<p>

    For instance,
<p>
<ul>
<li>if we use <code class="code">stdib</code> as the source of characters (<a href="BatScanf.Scanning.html#VALstdib"><code class="code"><span class="constructor">BatScanf</span>.<span class="constructor">Scanning</span>.stdib</code></a> is
    the predefined input buffer that reads from standard input),</li>
</ul>
<ul>
<li>if we define the receiver <code class="code">f</code> as <code class="code"><span class="keyword">let</span> f x = x + 1</code>,</li>
</ul>

    then <code class="code">bscanf stdib <span class="string">"%d"</span> f</code> reads an integer <code class="code">n</code> from the standard input
    and returns <code class="code">f n</code> (that is <code class="code">n + 1</code>). Thus, if we evaluate <code class="code">bscanf stdib
    <span class="string">"%d"</span> f</code>, and then enter <code class="code">41</code> at the keyboard, we get <code class="code">42</code> as the final
    result.<br>
<br>
<div class="h7" id="7_Formattedinputasafunctionalfeature">Formatted input as a functional feature</div><br>
<br>
The OCaml scanning facility is reminiscent of the corresponding C feature.
    However, it is also largely different, simpler, and yet more powerful:
    the formatted input functions are higher-order functionals and the
    parameter passing mechanism is just the regular function application not
    the variable assigment based mechanism which is typical for formatted
    input in imperative languages; the OCaml format strings also feature
    useful additions to easily define complex tokens; as expected within a
    functional programming language, the formatted input functions also
    support polymorphism, in particular arbitrary interaction with
    polymorphic user-defined scanners.  Furthermore, the OCaml formatted input
    facility is fully type-checked at compile time.<br>

<pre><span class="keyword">module</span> <a href="BatScanf.Scanning.html">Scanning</a>: <code class="code">{</code> <a href="BatScanf.Scanning.html">..</a> <code class="code">}</code></pre><div class="info">
Scanning buffers
</div>
<br>
<h6 id="6_Typeofformattedinputfunctions">Type of formatted input functions</h6><br>

<pre><span id="TYPEscanner"><span class="keyword">type</span> scanner <code class="type">'a 'b 'c 'd</code></span> = <code class="type">Pervasives.format6 'a <a href="BatScanf.Scanning.html#TYPEscanbuf">Scanning.scanbuf</a> 'b 'c 'a => 'd 'd => 'c</code> </pre>
<div class="info ">
The type of formatted input scanners: <code class="code">(<span class="keywordsign">'</span>a, <span class="keywordsign">'</span>b, <span class="keywordsign">'</span>c, <span class="keywordsign">'</span>d) scanner</code> is the
    type of a formatted input function that reads from some scanning buffer
    according to some format string; more precisely, if <code class="code">scan</code> is some
    formatted input function, then <code class="code">scan ib fmt f</code> applies <code class="code">f</code> to the arguments
    specified by the format string <code class="code">fmt</code>, when <code class="code">scan</code> has read those arguments
    from the scanning input buffer <code class="code">ib</code>.
<p>

    For instance, the <code class="code">scanf</code> function below has type <code class="code">(<span class="keywordsign">'</span>a, <span class="keywordsign">'</span>b, <span class="keywordsign">'</span>c, <span class="keywordsign">'</span>d)
    scanner</code>, since it is a formatted input function that reads from <code class="code">stdib</code>:
    <code class="code">scanf fmt f</code> applies <code class="code">f</code> to the arguments specified by <code class="code">fmt</code>, reading
    those arguments from <code class="code">stdin</code> as expected.
<p>

    If the format <code class="code">fmt</code> has some <code class="code">%r</code> indications, the corresponding input
    functions must be provided before the receiver <code class="code">f</code> argument. For
    instance, if <code class="code">read_elem</code> is an input function for values of type <code class="code">t</code>,
    then <code class="code">bscanf ib <span class="string">"%r;"</span> read_elem f</code> reads a value <code class="code">v</code> of type <code class="code">t</code> followed
    by a <code class="code"><span class="string">';'</span></code> character, and returns <code class="code">f v</code>.<br>
</div>


<pre><span id="EXCEPTIONScan_failure"><span class="keyword">exception</span> Scan_failure</span> <span class="keyword">of</span> <code class="type">string</code></pre>
<div class="info ">
The exception that formatted input functions raise when the input cannot be
    read according to the given format.<br>
</div>
<br>
<h6 id="6_Thegeneralformattedinputfunction">The general formatted input function</h6><br>

<pre><span id="VALbscanf"><span class="keyword">let</span> bscanf</span> : <code class="type"><a href="BatScanf.Scanning.html#TYPEscanbuf">Scanning.scanbuf</a> => <a href="BatScanf.html#TYPEscanner">scanner</a> 'a 'b 'c 'd</code></pre><div class="info ">
<code class="code">bscanf ib fmt r1 ... rN f</code> reads arguments for the function <code class="code">f</code>, from the
    scanning buffer <code class="code">ib</code>, according to the format string <code class="code">fmt</code>, and applies <code class="code">f</code>
    to these values.
    The result of this call to <code class="code">f</code> is returned as the result of the entire
    <code class="code">bscanf</code> call.
    For instance, if <code class="code">f</code> is the function <code class="code"><span class="keyword">fun</span> s i <span class="keywordsign">-&gt;</span> i + 1</code>, then
    <code class="code"><span class="constructor">Scanf</span>.sscanf <span class="string">"x=  1"</span> <span class="string">"%s = %i"</span> f</code> returns <code class="code">2</code>.
<p>

    Arguments <code class="code">r1</code> to <code class="code">rN</code> are user-defined input functions that read the
    argument corresponding to a <code class="code">%r</code> conversion.<br>
</div>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
The format is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input,</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code>,</li>
<li>scanning indications to specify boundaries of tokens.</li>
</ul>
<br>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
The format is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input,</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code>,</li>
<li>scanning indications to specify boundaries of tokens.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Thespacecharacterinformatstrings">The space character in format strings</div><br>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
The format is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input,</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code>,</li>
<li>scanning indications to specify boundaries of tokens.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Thespacecharacterinformatstrings">The space character in format strings</div><br>
<br>
As mentioned above, a plain character in the format string is just
    matched with the characters of the input; however, one character is a
    special exception to this simple rule: the space character (ASCII code
    32) does not match a single space character, but any amount of
    ``whitespace'' in the input. More precisely, a space inside the format
    string matches <em>any number</em> of tab, space, line feed and carriage
    return characters.
<p>

    Matching <em>any</em> amount of whitespace, a space in the format string
    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib
    <span class="string">"Price = %d $"</span> (<span class="keyword">fun</span> p <span class="keywordsign">-&gt;</span> p)</code> succeds and returns <code class="code">1</code> when reading an
    input with various whitespace in it, such as <code class="code"><span class="constructor">Price</span> = 1 $</code>,
    <code class="code"><span class="constructor">Price</span>  =  1    $</code>, or even <code class="code"><span class="constructor">Price</span>=1$</code>.<br>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
The format is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input,</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code>,</li>
<li>scanning indications to specify boundaries of tokens.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Thespacecharacterinformatstrings">The space character in format strings</div><br>
<br>
As mentioned above, a plain character in the format string is just
    matched with the characters of the input; however, one character is a
    special exception to this simple rule: the space character (ASCII code
    32) does not match a single space character, but any amount of
    ``whitespace'' in the input. More precisely, a space inside the format
    string matches <em>any number</em> of tab, space, line feed and carriage
    return characters.
<p>

    Matching <em>any</em> amount of whitespace, a space in the format string
    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib
    <span class="string">"Price = %d $"</span> (<span class="keyword">fun</span> p <span class="keywordsign">-&gt;</span> p)</code> succeds and returns <code class="code">1</code> when reading an
    input with various whitespace in it, such as <code class="code"><span class="constructor">Price</span> = 1 $</code>,
    <code class="code"><span class="constructor">Price</span>  =  1    $</code>, or even <code class="code"><span class="constructor">Price</span>=1$</code>.<br>
<br>
<div class="h7" id="7_Conversionspecificationsinformatstrings">Conversion specifications in format strings</div><br>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
The format is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input,</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code>,</li>
<li>scanning indications to specify boundaries of tokens.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Thespacecharacterinformatstrings">The space character in format strings</div><br>
<br>
As mentioned above, a plain character in the format string is just
    matched with the characters of the input; however, one character is a
    special exception to this simple rule: the space character (ASCII code
    32) does not match a single space character, but any amount of
    ``whitespace'' in the input. More precisely, a space inside the format
    string matches <em>any number</em> of tab, space, line feed and carriage
    return characters.
<p>

    Matching <em>any</em> amount of whitespace, a space in the format string
    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib
    <span class="string">"Price = %d $"</span> (<span class="keyword">fun</span> p <span class="keywordsign">-&gt;</span> p)</code> succeds and returns <code class="code">1</code> when reading an
    input with various whitespace in it, such as <code class="code"><span class="constructor">Price</span> = 1 $</code>,
    <code class="code"><span class="constructor">Price</span>  =  1    $</code>, or even <code class="code"><span class="constructor">Price</span>=1$</code>.<br>
<br>
<div class="h7" id="7_Conversionspecificationsinformatstrings">Conversion specifications in format strings</div><br>
<br>
Conversion specifications consist in the <code class="code">%</code> character, followed by
    an optional flag, an optional field width, and followed by one or
    two conversion characters. The conversion characters and their
    meanings are:
<p>
<ul>
<li><code class="code">d</code>: reads an optionally signed decimal integer.</li>
<li><code class="code">i</code>: reads an optionally signed integer
      (usual input formats for hexadecimal (<code class="code">0x[d]+</code> and <code class="code">0<span class="constructor">X</span>[d]+</code>),
       octal (<code class="code">0o[d]+</code>), and binary <code class="code">0b[d]+</code> notations are understood).</li>
<li><code class="code">u</code>: reads an unsigned decimal integer.</li>
<li><code class="code">x</code> or <code class="code"><span class="constructor">X</span></code>: reads an unsigned hexadecimal integer.</li>
<li><code class="code">o</code>: reads an unsigned octal integer.</li>
<li><code class="code">s</code>: reads a string argument that spreads as much as possible, until the
      following bounding condition holds: a whitespace has been found, a
      scanning indication has been encountered, or the end-of-input has been
      reached.
      Hence, this conversion always succeeds: it returns an empty
      string, if the bounding condition holds when the scan begins.</li>
<li><code class="code"><span class="constructor">S</span></code>: reads a delimited string argument (delimiters and special
      escaped characters follow the lexical conventions of OCaml).</li>
<li><code class="code">c</code>: reads a single character. To test the current input character
      without reading it, specify a null field width, i.e. use
      specification <code class="code">%0c</code>.</li>
</ul>
<br>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
The format is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input,</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code>,</li>
<li>scanning indications to specify boundaries of tokens.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Thespacecharacterinformatstrings">The space character in format strings</div><br>
<br>
As mentioned above, a plain character in the format string is just
    matched with the characters of the input; however, one character is a
    special exception to this simple rule: the space character (ASCII code
    32) does not match a single space character, but any amount of
    ``whitespace'' in the input. More precisely, a space inside the format
    string matches <em>any number</em> of tab, space, line feed and carriage
    return characters.
<p>

    Matching <em>any</em> amount of whitespace, a space in the format string
    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib
    <span class="string">"Price = %d $"</span> (<span class="keyword">fun</span> p <span class="keywordsign">-&gt;</span> p)</code> succeds and returns <code class="code">1</code> when reading an
    input with various whitespace in it, such as <code class="code"><span class="constructor">Price</span> = 1 $</code>,
    <code class="code"><span class="constructor">Price</span>  =  1    $</code>, or even <code class="code"><span class="constructor">Price</span>=1$</code>.<br>
<br>
<div class="h7" id="7_Conversionspecificationsinformatstrings">Conversion specifications in format strings</div><br>
<br>
Conversion specifications consist in the <code class="code">%</code> character, followed by
    an optional flag, an optional field width, and followed by one or
    two conversion characters. The conversion characters and their
    meanings are:
<p>
<ul>
<li><code class="code">d</code>: reads an optionally signed decimal integer.</li>
<li><code class="code">i</code>: reads an optionally signed integer
      (usual input formats for hexadecimal (<code class="code">0x[d]+</code> and <code class="code">0<span class="constructor">X</span>[d]+</code>),
       octal (<code class="code">0o[d]+</code>), and binary <code class="code">0b[d]+</code> notations are understood).</li>
<li><code class="code">u</code>: reads an unsigned decimal integer.</li>
<li><code class="code">x</code> or <code class="code"><span class="constructor">X</span></code>: reads an unsigned hexadecimal integer.</li>
<li><code class="code">o</code>: reads an unsigned octal integer.</li>
<li><code class="code">s</code>: reads a string argument that spreads as much as possible, until the
      following bounding condition holds: a whitespace has been found, a
      scanning indication has been encountered, or the end-of-input has been
      reached.
      Hence, this conversion always succeeds: it returns an empty
      string, if the bounding condition holds when the scan begins.</li>
<li><code class="code"><span class="constructor">S</span></code>: reads a delimited string argument (delimiters and special
      escaped characters follow the lexical conventions of OCaml).</li>
<li><code class="code">c</code>: reads a single character. To test the current input character
      without reading it, specify a null field width, i.e. use
      specification <code class="code">%0c</code>.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Scanningindicationsinformatstrings">Scanning indications in format strings</div><br>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
The format is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input,</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code>,</li>
<li>scanning indications to specify boundaries of tokens.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Thespacecharacterinformatstrings">The space character in format strings</div><br>
<br>
As mentioned above, a plain character in the format string is just
    matched with the characters of the input; however, one character is a
    special exception to this simple rule: the space character (ASCII code
    32) does not match a single space character, but any amount of
    ``whitespace'' in the input. More precisely, a space inside the format
    string matches <em>any number</em> of tab, space, line feed and carriage
    return characters.
<p>

    Matching <em>any</em> amount of whitespace, a space in the format string
    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib
    <span class="string">"Price = %d $"</span> (<span class="keyword">fun</span> p <span class="keywordsign">-&gt;</span> p)</code> succeds and returns <code class="code">1</code> when reading an
    input with various whitespace in it, such as <code class="code"><span class="constructor">Price</span> = 1 $</code>,
    <code class="code"><span class="constructor">Price</span>  =  1    $</code>, or even <code class="code"><span class="constructor">Price</span>=1$</code>.<br>
<br>
<div class="h7" id="7_Conversionspecificationsinformatstrings">Conversion specifications in format strings</div><br>
<br>
Conversion specifications consist in the <code class="code">%</code> character, followed by
    an optional flag, an optional field width, and followed by one or
    two conversion characters. The conversion characters and their
    meanings are:
<p>
<ul>
<li><code class="code">d</code>: reads an optionally signed decimal integer.</li>
<li><code class="code">i</code>: reads an optionally signed integer
      (usual input formats for hexadecimal (<code class="code">0x[d]+</code> and <code class="code">0<span class="constructor">X</span>[d]+</code>),
       octal (<code class="code">0o[d]+</code>), and binary <code class="code">0b[d]+</code> notations are understood).</li>
<li><code class="code">u</code>: reads an unsigned decimal integer.</li>
<li><code class="code">x</code> or <code class="code"><span class="constructor">X</span></code>: reads an unsigned hexadecimal integer.</li>
<li><code class="code">o</code>: reads an unsigned octal integer.</li>
<li><code class="code">s</code>: reads a string argument that spreads as much as possible, until the
      following bounding condition holds: a whitespace has been found, a
      scanning indication has been encountered, or the end-of-input has been
      reached.
      Hence, this conversion always succeeds: it returns an empty
      string, if the bounding condition holds when the scan begins.</li>
<li><code class="code"><span class="constructor">S</span></code>: reads a delimited string argument (delimiters and special
      escaped characters follow the lexical conventions of OCaml).</li>
<li><code class="code">c</code>: reads a single character. To test the current input character
      without reading it, specify a null field width, i.e. use
      specification <code class="code">%0c</code>.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Scanningindicationsinformatstrings">Scanning indications in format strings</div><br>
<br>
Scanning indications appear just after the string conversions <code class="code">%s</code>
    and <code class="code">%[ range ]</code> to delimit the end of the token. A scanning
    indication is introduced by a <code class="code">@</code> character, followed by some
    constant character <code class="code">c</code>. It means that the string token should end
    just before the next matching <code class="code">c</code> (which is skipped). If no <code class="code">c</code>
    character is encountered, the string token spreads as much as
    possible. For instance, <code class="code"><span class="string">"%s@\t"</span></code> reads a string up to the next
    tab character or to the end of input. If a scanning
    indication <code class="code">@c</code> does not follow a string conversion, it is treated
    as a plain <code class="code">c</code> character.
<p>

    Note:
<p>
<ul>
<li>the scanning indications introduce slight differences in the syntax of
    <code class="code"><span class="constructor">Scanf</span></code> format strings, compared to those used for the <code class="code"><span class="constructor">Printf</span></code>
    module. However, the scanning indications are similar to those used in
    the <code class="code"><span class="constructor">Format</span></code> module; hence, when producing formatted text to be scanned
    by <code class="code">!<span class="constructor">Scanf</span>.bscanf</code>, it is wise to use printing functions from the
    <code class="code"><span class="constructor">Format</span></code> module (or, if you need to use functions from <code class="code"><span class="constructor">Printf</span></code>, banish
    or carefully double check the format strings that contain <code class="code"><span class="string">'@'</span></code>
    characters).</li>
</ul>
<br>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
The format is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input,</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code>,</li>
<li>scanning indications to specify boundaries of tokens.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Thespacecharacterinformatstrings">The space character in format strings</div><br>
<br>
As mentioned above, a plain character in the format string is just
    matched with the characters of the input; however, one character is a
    special exception to this simple rule: the space character (ASCII code
    32) does not match a single space character, but any amount of
    ``whitespace'' in the input. More precisely, a space inside the format
    string matches <em>any number</em> of tab, space, line feed and carriage
    return characters.
<p>

    Matching <em>any</em> amount of whitespace, a space in the format string
    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib
    <span class="string">"Price = %d $"</span> (<span class="keyword">fun</span> p <span class="keywordsign">-&gt;</span> p)</code> succeds and returns <code class="code">1</code> when reading an
    input with various whitespace in it, such as <code class="code"><span class="constructor">Price</span> = 1 $</code>,
    <code class="code"><span class="constructor">Price</span>  =  1    $</code>, or even <code class="code"><span class="constructor">Price</span>=1$</code>.<br>
<br>
<div class="h7" id="7_Conversionspecificationsinformatstrings">Conversion specifications in format strings</div><br>
<br>
Conversion specifications consist in the <code class="code">%</code> character, followed by
    an optional flag, an optional field width, and followed by one or
    two conversion characters. The conversion characters and their
    meanings are:
<p>
<ul>
<li><code class="code">d</code>: reads an optionally signed decimal integer.</li>
<li><code class="code">i</code>: reads an optionally signed integer
      (usual input formats for hexadecimal (<code class="code">0x[d]+</code> and <code class="code">0<span class="constructor">X</span>[d]+</code>),
       octal (<code class="code">0o[d]+</code>), and binary <code class="code">0b[d]+</code> notations are understood).</li>
<li><code class="code">u</code>: reads an unsigned decimal integer.</li>
<li><code class="code">x</code> or <code class="code"><span class="constructor">X</span></code>: reads an unsigned hexadecimal integer.</li>
<li><code class="code">o</code>: reads an unsigned octal integer.</li>
<li><code class="code">s</code>: reads a string argument that spreads as much as possible, until the
      following bounding condition holds: a whitespace has been found, a
      scanning indication has been encountered, or the end-of-input has been
      reached.
      Hence, this conversion always succeeds: it returns an empty
      string, if the bounding condition holds when the scan begins.</li>
<li><code class="code"><span class="constructor">S</span></code>: reads a delimited string argument (delimiters and special
      escaped characters follow the lexical conventions of OCaml).</li>
<li><code class="code">c</code>: reads a single character. To test the current input character
      without reading it, specify a null field width, i.e. use
      specification <code class="code">%0c</code>.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Scanningindicationsinformatstrings">Scanning indications in format strings</div><br>
<br>
Scanning indications appear just after the string conversions <code class="code">%s</code>
    and <code class="code">%[ range ]</code> to delimit the end of the token. A scanning
    indication is introduced by a <code class="code">@</code> character, followed by some
    constant character <code class="code">c</code>. It means that the string token should end
    just before the next matching <code class="code">c</code> (which is skipped). If no <code class="code">c</code>
    character is encountered, the string token spreads as much as
    possible. For instance, <code class="code"><span class="string">"%s@\t"</span></code> reads a string up to the next
    tab character or to the end of input. If a scanning
    indication <code class="code">@c</code> does not follow a string conversion, it is treated
    as a plain <code class="code">c</code> character.
<p>

    Note:
<p>
<ul>
<li>the scanning indications introduce slight differences in the syntax of
    <code class="code"><span class="constructor">Scanf</span></code> format strings, compared to those used for the <code class="code"><span class="constructor">Printf</span></code>
    module. However, the scanning indications are similar to those used in
    the <code class="code"><span class="constructor">Format</span></code> module; hence, when producing formatted text to be scanned
    by <code class="code">!<span class="constructor">Scanf</span>.bscanf</code>, it is wise to use printing functions from the
    <code class="code"><span class="constructor">Format</span></code> module (or, if you need to use functions from <code class="code"><span class="constructor">Printf</span></code>, banish
    or carefully double check the format strings that contain <code class="code"><span class="string">'@'</span></code>
    characters).</li>
</ul>
<br>
<br>
<div class="h7" id="7_Exceptionsduringscanning">Exceptions during scanning</div><br>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
The format is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input,</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code>,</li>
<li>scanning indications to specify boundaries of tokens.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Thespacecharacterinformatstrings">The space character in format strings</div><br>
<br>
As mentioned above, a plain character in the format string is just
    matched with the characters of the input; however, one character is a
    special exception to this simple rule: the space character (ASCII code
    32) does not match a single space character, but any amount of
    ``whitespace'' in the input. More precisely, a space inside the format
    string matches <em>any number</em> of tab, space, line feed and carriage
    return characters.
<p>

    Matching <em>any</em> amount of whitespace, a space in the format string
    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib
    <span class="string">"Price = %d $"</span> (<span class="keyword">fun</span> p <span class="keywordsign">-&gt;</span> p)</code> succeds and returns <code class="code">1</code> when reading an
    input with various whitespace in it, such as <code class="code"><span class="constructor">Price</span> = 1 $</code>,
    <code class="code"><span class="constructor">Price</span>  =  1    $</code>, or even <code class="code"><span class="constructor">Price</span>=1$</code>.<br>
<br>
<div class="h7" id="7_Conversionspecificationsinformatstrings">Conversion specifications in format strings</div><br>
<br>
Conversion specifications consist in the <code class="code">%</code> character, followed by
    an optional flag, an optional field width, and followed by one or
    two conversion characters. The conversion characters and their
    meanings are:
<p>
<ul>
<li><code class="code">d</code>: reads an optionally signed decimal integer.</li>
<li><code class="code">i</code>: reads an optionally signed integer
      (usual input formats for hexadecimal (<code class="code">0x[d]+</code> and <code class="code">0<span class="constructor">X</span>[d]+</code>),
       octal (<code class="code">0o[d]+</code>), and binary <code class="code">0b[d]+</code> notations are understood).</li>
<li><code class="code">u</code>: reads an unsigned decimal integer.</li>
<li><code class="code">x</code> or <code class="code"><span class="constructor">X</span></code>: reads an unsigned hexadecimal integer.</li>
<li><code class="code">o</code>: reads an unsigned octal integer.</li>
<li><code class="code">s</code>: reads a string argument that spreads as much as possible, until the
      following bounding condition holds: a whitespace has been found, a
      scanning indication has been encountered, or the end-of-input has been
      reached.
      Hence, this conversion always succeeds: it returns an empty
      string, if the bounding condition holds when the scan begins.</li>
<li><code class="code"><span class="constructor">S</span></code>: reads a delimited string argument (delimiters and special
      escaped characters follow the lexical conventions of OCaml).</li>
<li><code class="code">c</code>: reads a single character. To test the current input character
      without reading it, specify a null field width, i.e. use
      specification <code class="code">%0c</code>.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Scanningindicationsinformatstrings">Scanning indications in format strings</div><br>
<br>
Scanning indications appear just after the string conversions <code class="code">%s</code>
    and <code class="code">%[ range ]</code> to delimit the end of the token. A scanning
    indication is introduced by a <code class="code">@</code> character, followed by some
    constant character <code class="code">c</code>. It means that the string token should end
    just before the next matching <code class="code">c</code> (which is skipped). If no <code class="code">c</code>
    character is encountered, the string token spreads as much as
    possible. For instance, <code class="code"><span class="string">"%s@\t"</span></code> reads a string up to the next
    tab character or to the end of input. If a scanning
    indication <code class="code">@c</code> does not follow a string conversion, it is treated
    as a plain <code class="code">c</code> character.
<p>

    Note:
<p>
<ul>
<li>the scanning indications introduce slight differences in the syntax of
    <code class="code"><span class="constructor">Scanf</span></code> format strings, compared to those used for the <code class="code"><span class="constructor">Printf</span></code>
    module. However, the scanning indications are similar to those used in
    the <code class="code"><span class="constructor">Format</span></code> module; hence, when producing formatted text to be scanned
    by <code class="code">!<span class="constructor">Scanf</span>.bscanf</code>, it is wise to use printing functions from the
    <code class="code"><span class="constructor">Format</span></code> module (or, if you need to use functions from <code class="code"><span class="constructor">Printf</span></code>, banish
    or carefully double check the format strings that contain <code class="code"><span class="string">'@'</span></code>
    characters).</li>
</ul>
<br>
<br>
<div class="h7" id="7_Exceptionsduringscanning">Exceptions during scanning</div><br>
<br>
Scanners may raise the following exceptions when the input cannot be read
    according to the format string:
<p>

    -<br>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
The format is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input,</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code>,</li>
<li>scanning indications to specify boundaries of tokens.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Thespacecharacterinformatstrings">The space character in format strings</div><br>
<br>
As mentioned above, a plain character in the format string is just
    matched with the characters of the input; however, one character is a
    special exception to this simple rule: the space character (ASCII code
    32) does not match a single space character, but any amount of
    ``whitespace'' in the input. More precisely, a space inside the format
    string matches <em>any number</em> of tab, space, line feed and carriage
    return characters.
<p>

    Matching <em>any</em> amount of whitespace, a space in the format string
    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib
    <span class="string">"Price = %d $"</span> (<span class="keyword">fun</span> p <span class="keywordsign">-&gt;</span> p)</code> succeds and returns <code class="code">1</code> when reading an
    input with various whitespace in it, such as <code class="code"><span class="constructor">Price</span> = 1 $</code>,
    <code class="code"><span class="constructor">Price</span>  =  1    $</code>, or even <code class="code"><span class="constructor">Price</span>=1$</code>.<br>
<br>
<div class="h7" id="7_Conversionspecificationsinformatstrings">Conversion specifications in format strings</div><br>
<br>
Conversion specifications consist in the <code class="code">%</code> character, followed by
    an optional flag, an optional field width, and followed by one or
    two conversion characters. The conversion characters and their
    meanings are:
<p>
<ul>
<li><code class="code">d</code>: reads an optionally signed decimal integer.</li>
<li><code class="code">i</code>: reads an optionally signed integer
      (usual input formats for hexadecimal (<code class="code">0x[d]+</code> and <code class="code">0<span class="constructor">X</span>[d]+</code>),
       octal (<code class="code">0o[d]+</code>), and binary <code class="code">0b[d]+</code> notations are understood).</li>
<li><code class="code">u</code>: reads an unsigned decimal integer.</li>
<li><code class="code">x</code> or <code class="code"><span class="constructor">X</span></code>: reads an unsigned hexadecimal integer.</li>
<li><code class="code">o</code>: reads an unsigned octal integer.</li>
<li><code class="code">s</code>: reads a string argument that spreads as much as possible, until the
      following bounding condition holds: a whitespace has been found, a
      scanning indication has been encountered, or the end-of-input has been
      reached.
      Hence, this conversion always succeeds: it returns an empty
      string, if the bounding condition holds when the scan begins.</li>
<li><code class="code"><span class="constructor">S</span></code>: reads a delimited string argument (delimiters and special
      escaped characters follow the lexical conventions of OCaml).</li>
<li><code class="code">c</code>: reads a single character. To test the current input character
      without reading it, specify a null field width, i.e. use
      specification <code class="code">%0c</code>.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Scanningindicationsinformatstrings">Scanning indications in format strings</div><br>
<br>
Scanning indications appear just after the string conversions <code class="code">%s</code>
    and <code class="code">%[ range ]</code> to delimit the end of the token. A scanning
    indication is introduced by a <code class="code">@</code> character, followed by some
    constant character <code class="code">c</code>. It means that the string token should end
    just before the next matching <code class="code">c</code> (which is skipped). If no <code class="code">c</code>
    character is encountered, the string token spreads as much as
    possible. For instance, <code class="code"><span class="string">"%s@\t"</span></code> reads a string up to the next
    tab character or to the end of input. If a scanning
    indication <code class="code">@c</code> does not follow a string conversion, it is treated
    as a plain <code class="code">c</code> character.
<p>

    Note:
<p>
<ul>
<li>the scanning indications introduce slight differences in the syntax of
    <code class="code"><span class="constructor">Scanf</span></code> format strings, compared to those used for the <code class="code"><span class="constructor">Printf</span></code>
    module. However, the scanning indications are similar to those used in
    the <code class="code"><span class="constructor">Format</span></code> module; hence, when producing formatted text to be scanned
    by <code class="code">!<span class="constructor">Scanf</span>.bscanf</code>, it is wise to use printing functions from the
    <code class="code"><span class="constructor">Format</span></code> module (or, if you need to use functions from <code class="code"><span class="constructor">Printf</span></code>, banish
    or carefully double check the format strings that contain <code class="code"><span class="string">'@'</span></code>
    characters).</li>
</ul>
<br>
<br>
<div class="h7" id="7_Exceptionsduringscanning">Exceptions during scanning</div><br>
<br>
Scanners may raise the following exceptions when the input cannot be read
    according to the format string:
<p>

    -<br>
<br>
<h6 id="6_Specializedformattedinputfunctions">Specialized formatted input functions</h6><br>

<pre><span id="VALfscanf"><span class="keyword">let</span> fscanf</span> : <code class="type">Pervasives.in_channel => <a href="BatScanf.html#TYPEscanner">scanner</a> 'a 'b 'c 'd</code></pre><div class="info ">
Same as <code class="code"><span class="constructor">Scanf</span>.bscanf</code>, but reads from the given channel.
<p>

    Warning: since all formatted input functions operate from a scanning
    buffer, be aware that each <code class="code">fscanf</code> invocation will operate with a
    scanning buffer reading from the given channel. This extra level of
    bufferization can lead to strange scanning behaviour if you use low level
    primitives on the channel (reading characters, seeking the reading
    position, and so on).
<p>

    As a consequence, never mixt direct low level reading and high level
    scanning from the same input channel.<br>
</div>

<pre><span id="VALsscanf"><span class="keyword">let</span> sscanf</span> : <code class="type">string => <a href="BatScanf.html#TYPEscanner">scanner</a> 'a 'b 'c 'd</code></pre><div class="info ">
Same as <code class="code"><span class="constructor">Scanf</span>.bscanf</code>, but reads from the given string.<br>
</div>

<pre><span id="VALscanf"><span class="keyword">let</span> scanf</span> : <code class="type"><a href="BatScanf.html#TYPEscanner">scanner</a> 'a 'b 'c 'd</code></pre><div class="info ">
Same as <code class="code"><span class="constructor">Scanf</span>.bscanf</code>, but reads from the predefined scanning
    buffer <code class="code"><span class="constructor">Scanf</span>.<span class="constructor">Scanning</span>.stdib</code> that is connected to <code class="code">stdin</code>.<br>
</div>

<pre><span id="VALkscanf"><span class="keyword">let</span> kscanf</span> : <code class="type"><a href="BatScanf.Scanning.html#TYPEscanbuf">Scanning.scanbuf</a> =><br>       (<a href="BatScanf.Scanning.html#TYPEscanbuf">Scanning.scanbuf</a> => exn => 'd) => <a href="BatScanf.html#TYPEscanner">scanner</a> 'a 'b 'c 'd</code></pre><div class="info ">
Same as <code class="code"><span class="constructor">Scanf</span>.bscanf</code>, but takes an additional function argument
    <code class="code">ef</code> that is called in case of error: if the scanning process or
    some conversion fails, the scanning function aborts and calls the
    error handling function <code class="code">ef</code> with the scanning buffer and the
    exception that aborted the scanning process.<br>
</div>
<br>
<h6 id="6_Readingformatstringsfrominput">Reading format strings from input</h6><br>

<pre><span id="VALbscanf_format"><span class="keyword">let</span> bscanf_format</span> : <code class="type"><a href="BatScanf.Scanning.html#TYPEscanbuf">Scanning.scanbuf</a> =><br>       Pervasives.format6 'a 'b 'c 'd 'e 'f =><br>       (Pervasives.format6 'a 'b 'c 'd 'e 'f => 'g) => 'g</code></pre><div class="info ">
<code class="code">bscanf_format ib fmt f</code> reads a format string token from the scannning
    buffer <code class="code">ib</code>, according to the given format string <code class="code">fmt</code>, and applies <code class="code">f</code> to
    the resulting format string value.<br>
<b>Raises</b> <code>Scan_failure</code> if the format string value read does not have the
    same type as <code class="code">fmt</code>.<br>
</div>

<pre><span id="VALsscanf_format"><span class="keyword">let</span> sscanf_format</span> : <code class="type">string =><br>       Pervasives.format6 'a 'b 'c 'd 'e 'f =><br>       (Pervasives.format6 'a 'b 'c 'd 'e 'f => 'g) => 'g</code></pre><div class="info ">
Same as <code class="code"><span class="constructor">Scanf</span>.bscanf_format</code>, but reads from the given string.<br>
</div>

<pre><span id="VALformat_from_string"><span class="keyword">let</span> format_from_string</span> : <code class="type">string =><br>       Pervasives.format6 'a 'b 'c 'd 'e 'f => Pervasives.format6 'a 'b 'c 'd 'e 'f</code></pre><div class="info ">
<code class="code">format_from_string s fmt</code> converts a string argument to a format string,
    according to the given format string <code class="code">fmt</code>.<br>
<b>Raises</b> <code>Scan_failure</code> if <code class="code">s</code>, considered as a format string, does not
    have the same type as <code class="code">fmt</code>.<br>
</div>
</body></html>