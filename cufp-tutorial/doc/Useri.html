<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Anim.html">
<link rel="next" href="Useri_jsoo.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="G2048" rel="Chapter" href="G2048.html">
<link title="Utils" rel="Chapter" href="Utils.html">
<link title="Test" rel="Chapter" href="Test.html">
<link title="Render" rel="Chapter" href="Render.html">
<link title="Anim" rel="Chapter" href="Anim.html">
<link title="Useri" rel="Chapter" href="Useri.html">
<link title="Useri_jsoo" rel="Chapter" href="Useri_jsoo.html"><link title="Useri" rel="Section" href="#1_Useri">
<link title="Minimal example" rel="Section" href="#1_Minimalexample">
<link title="Integration with cooperative concurency" rel="Section" href="#cooperate">
<link title="Input, animation and rendering coordination" rel="Section" href="#rendercoord">
<title>Useri</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Anim.html" title="Anim">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Useri_jsoo.html" title="Useri_jsoo">Next</a>
</div>
<h1>Module <a href="type_Useri.html">Useri</a></h1>

<pre><span class="keyword">module</span> Useri: <code class="code"><span class="keyword">sig</span></code> <a href="Useri.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Simple declarative user interaction with <code class="code"><span class="constructor">React</span></code>.
<p>

    <code class="code"><span class="constructor">Useri</span></code> gathers user input as <code class="code"><span class="constructor">React</span></code> signals and events from
    a single rendering surface.
<p>

    Open the module to use it, this defines only modules in your scope.
<p>

    <b>Note.</b> Before <a href="Useri.App.html#VALinit"><code class="code"><span class="constructor">Useri</span>.<span class="constructor">App</span>.init</code></a> is called all signals hold invalid data.
<p>

    <b>Caveat.</b> Do not expect to be able to fully exploit the
    possibilities and flexibility of the platforms underlying the
    backends. This library is a <em>simple</em> abstraction library and
    thus remains limited by design.
<p>

    <em>Release %%VERSION%% â€” %%MAINTAINER%% </em><br>
</div>
<hr width="100%">
<br>
<h1 id="1_Useri">Useri</h1><br>

<pre><span class="keyword">module</span> <a href="Useri.Time.html">Time</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Useri.Time.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Monotonic time.
</div>

<pre><span class="keyword">module</span> <a href="Useri.Surface.html">Surface</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Useri.Surface.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Rendering surface.
</div>

<pre><span class="keyword">module</span> <a href="Useri.Mouse.html">Mouse</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Useri.Mouse.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
User mouse.
</div>

<pre><span class="keyword">module</span> <a href="Useri.Touch.html">Touch</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Useri.Touch.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
User touches.
</div>

<pre><span class="keyword">module</span> <a href="Useri.Key.html">Key</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Useri.Key.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
User keyboard.
</div>

<pre><span class="keyword">module</span> <a href="Useri.Text.html">Text</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Useri.Text.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
User textual input and clipboard.
</div>

<pre><span class="keyword">module</span> <a href="Useri.Drop.html">Drop</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Useri.Drop.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
User drag and drop.
</div>

<pre><span class="keyword">module</span> <a href="Useri.Human.html">Human</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Useri.Human.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Human factors.
</div>

<pre><span class="keyword">module</span> <a href="Useri.App.html">App</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Useri.App.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info">
Application
</div>
<br>
<h1 id="1_Minimalexample">Minimal example</h1>
<p>

   This minimal example can be used on both synchronous
   and asynchronous backends.
<pre class="codepre"><code class="code"></code></pre>
<p>

   <h1 id="cooperate">Integration with cooperative concurency</h1>
<p>

    A good way of managing side-effects at the boundaries of your
    functional reactive system is to use a cooperative concurency
    library and convert event occurences and signal changes to
    yielding futures/threads (to avoid the problem of forbidden
    recursive primitive feedback) and convert futures/threads to a
    primitive event with a single occurence.
<p>

    You will need however need to cooperate with <code class="code"><span class="constructor">Useri</span></code>'s event
    loop and give it a high priority as the ability to interact
    should <b>never</b> take over a long running computation.
<p>

    The following code shows how to do that with Lwt and Fut
<pre class="codepre"><code class="code"></code></pre>
<p>

  <h1 id="rendercoord">Input, animation and rendering coordination</h1>
<p>

  The <a href="Useri.Time.html"><code class="code"><span class="constructor">Useri</span>.<span class="constructor">Time</span></code></a> and <a href="Useri.Surface.html"><code class="code"><span class="constructor">Useri</span>.<span class="constructor">Surface</span></code></a> modules provide support for coordinating
  input, animation and rendering. We can distinguish two patterns for
  rendering:
  <ul>
<li>Rendering as an effectful event or signal. This is more likely to be
     done in simple cases whenever you are not using cooperative concurrency.
     In this case rendering is simply performed in a
     React update step
     simultanous with the <a href="Useri.Surface.html#VALrefresh"><code class="code"><span class="constructor">Useri</span>.<span class="constructor">Surface</span>.refresh</code></a> event, in this step you can
     sample signals needed for rendering (as long as they <em>do not</em>
     depend on <a href="Useri.Surface.html#VALrefresh"><code class="code"><span class="constructor">Useri</span>.<span class="constructor">Surface</span>.refresh</code></a>).</li>
<li>Rendering as a task, in more complex rendering scenarios and
     especially with <a href="Useri.html#cooperate">cooperative concurency</a>. In this
     case <a href="Useri.Surface.html#VALrefresh"><code class="code"><span class="constructor">Useri</span>.<span class="constructor">Surface</span>.refresh</code></a> occurences simply generate a task that is
     run outside React's update step, this means that the signals
     needed for rendering can be safely sampled using <code class="code"><span class="constructor">React</span>.<span class="constructor">S</span>.value</code>
     for rendering data.</li>
</ul>

  In both cases rendering is coordinated by the <a href="Useri.Surface.html#VALrefresh"><code class="code"><span class="constructor">Useri</span>.<span class="constructor">Surface</span>.refresh</code></a>
  event. It is important to use this event for the following reasons:
  <ul>
<li>It occurs at important times in the life cycle of the application.
     For example whenever the application surface is first shown to the user
     or immediately after the application surface
     <a href="Useri.Surface.html#VALraster_size"><code class="code"><span class="constructor">Useri</span>.<span class="constructor">Surface</span>.raster_size</code></a> changes.</li>
<li>If steady refreshes or timing signals are requested to perform animation
     it allows them to occur in an energy efficient way, avoiding overdraw.
     It will also gracefully cope with processing load by dropping animation
     frames if the rendering system cannot follow.</li>
</ul>

  There are various <em>non-exclusive</em> ways of generating occurences of
  <a href="Useri.Surface.html#VALrefresh"><code class="code"><span class="constructor">Useri</span>.<span class="constructor">Surface</span>.refresh</code></a>:
  <ul>
<li>Steady refresh. If for a given time span until an event occurs
     (which may be <code class="code"><span class="constructor">E</span>.never</code>) you need steady refreshing,
     use <a href="Useri.Surface.html#VALsteady_refresh"><code class="code"><span class="constructor">Useri</span>.<span class="constructor">Surface</span>.steady_refresh</code></a>.</li>
<li>Animation timing signals. <a href="Useri.Surface.html#VALrefresh"><code class="code"><span class="constructor">Useri</span>.<span class="constructor">Surface</span>.refresh</code></a> occurences are generated
     immediately after the following signals are created and updated:
     <ul>
<li><a href="Useri.Time.html#VALunit"><code class="code"><span class="constructor">Useri</span>.<span class="constructor">Time</span>.unit</code></a>, for animations with a known time span, returns
        a signal increasing from <code class="code">0.</code> to <code class="code">1.</code> during that time span.</li>
<li><a href="Useri.Time.html#VALcount"><code class="code"><span class="constructor">Useri</span>.<span class="constructor">Time</span>.count</code></a>, for animations with an unknown time span, returns
        a signal monotically increasing from <code class="code">0.</code> to the time until a specified
        event occurs.</li>
</ul>
</li>
<li>If there are a few events after which you know you need to redraw,
     <code class="code"><span class="constructor">E</span>.select</code> them and register the resulting event with
     <a href="Useri.Surface.html#VALset_refresher"><code class="code"><span class="constructor">Useri</span>.<span class="constructor">Surface</span>.set_refresher</code></a>.</li>
</ul>
<br>
</body></html>